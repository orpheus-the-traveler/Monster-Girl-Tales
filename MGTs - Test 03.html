<tw-storydata name="MGTs - Test 03" startnode="45" creator="Twine" creator-version="2.2.1" ifid="1703C82B-795D-4851-86D5-4FEC6DE3A93B" zoom="0.6" format="SugarCube" format-version="2.27.0" options="" hidden><style role="stylesheet" id="twine-user-stylesheet" type="text/twine-css">.left {
	text-align: left;
}

.right {
  	text-align: right;
}

.center {
  	text-align: center;
}

.twocolumn {
	-webkit-column-count: 2;
	-moz-column-count: 2;
	column-count: 2;
}

/* Status Bar styling. */
.status-bar {
	-webkit-box-sizing: border-box;
	-moz-box-sizing: border-box;
	box-sizing: border-box;
	width: 200px;
	height: 20px;
	padding: 5px;
	background: #ddd;
	-webkit-border-radius: 5px;
	-moz-border-radius: 5px;
	border-radius: 5px;
	position: relative;
}
.status-bar .bar {
	background: #c54;
	width: 100%;
	height: 10px;
	position: relative;
	transition: width .5s linear;
}
.status-bar .change {
	background: rgba(255,255,255,0.6);
	position: absolute;
	top: 0;
	right: 0;
	bottom: 0;
	width: 0px;
	transition: width .5s linear;
}

#health-bar .bar {
  		background: red;
}

#energy-bar .bar {
  		background: blue;
}
























</style><script role="script" id="twine-user-script" type="text/twine-javascript">Config.saves.autosave = "save"

predisplay['set-return-variable'] = function () {
	if (!tags().includes('noreturn')) {
		State.variables['return'] = passage();
	}
};

var locTagRe = /^loc\./;
predisplay['set-location'] = function () {
	var loc = tags().find(function (tag) {
		return locTagRe.test(tag);
	});

	if (loc) {
		State.variables['location'] = loc.replace(locTagRe, '').replace('_', ' ');
	}
};

// <<dialog>> macro
Macro.add('dialog', {
       tags : null,
    handler : function () {
        
        // handle args (if any)
        var content = (this.payload[0].contents) ? this.payload[0].contents : '';
        var title = (this.args.length > 0) ? this.args[0] : '';
        var classes = (this.args.length > 1) ? this.args.slice(1).flatten() : [];
        
        // add the macro- class
        classes.push('macro-' + this.name);
        
        // dialog box
        Dialog.setup(title, classes.join(' '));
        Dialog.wiki(content);
        Dialog.open();
        
    }

});

// <<popup>> macro
Macro.add('popup', {
    handler : function () {
        
        // errors
        if (this.args.length < 1) {
            return this.error('need at least one argument; the passage to display');
        }
        if (!Story.has(this.args[0])) {
            return this.error('the passage ' + this.args[0] + 'does not exist');
        }
        
        // passage name and title
        var psg   = this.args[0];
        var title = (this.args.length > 1) ? this.args[1] : '';
        var classes = (this.args.length > 2) ? this.args.slice(2).flatten() : [];
        
        // add the macro- class
        classes.push('macro-' + this.name);
        
        // dialog box
        Dialog.setup(title, classes.join(' '));
        Dialog.wiki(Story.get(psg).processText());
        Dialog.open();
        
    }

});


/*
	<<statusbar "identifier" "$maximum" "$current" "$changer">>

	identifier - The UNIQUE identifier used as the HTML element ID of this bar.
	$maximum   - The story variable that contains the maximum value this bar can be.
	$current   - The story variable than contains the current value of this bar.
	$changer   - The story variable this bar monitors to determine how much the current value should change by.

	eg. <<statusbar "sanity-bar" "$totalSanity" "$sanity" "$abuse">>
*/
Macro.add('statusbar', {
	skipArgs : false,
	handler  : function () {
		/* Check if correct parameters were passed. */
		if (this.args.length < 4) {
			return this.error('not enough parameters specified');
		}
		/* TODO: Validate each of the four parameters being passed to the macro. */

		var identifier  = this.args[0],
			maximum     = State.getVar(this.args[1]),
			current     = State.getVar(this.args[2]),
			change      = State.getVar(this.args[3]),
			barWidth    = (current / maximum) * 100,
			changeWidth = 0,
			delayReset  = false;

		/* Generate the HTML structure. */
		const $parent = jQuery(document.createElement('div'));
		$parent
			.addClass("status-bar")
			.attr({
				'id': identifier,
				'data-maximum': maximum,
				'data-current': current
			});

		const $bar = jQuery(document.createElement('div'));
		$bar
			.addClass("bar")
			.css('width', barWidth + "%")
			.appendTo($parent);

		const $change = jQuery(document.createElement('div'));
		$change
			.addClass("change")
			.css('width', changeWidth + "%")
			.appendTo($bar);

		$parent.appendTo(this.output);

		/* Handle any required change to the current value. */
		if (change != 0) {
			changeWidth = (change / current) * 100;
			current     -= change;
			barWidth    = (current / maximum) * 100;

			State.setVar(this.args[2], current);
			State.setVar(this.args[3], 0);
			delayReset = true;
		}

		/* Apply the change visual effect if needed. */
		if (delayReset) {
			setTimeout(function(){
				$change.css({'width': '0'});
				$bar.css('width', barWidth + "%");
			}, 500);
		}
	}
});


/*
	UNIVERSAL INVENTORY SYSTEM (UInv)
	by HiEv                    v0.9.7

	A JavaScript inventory "plugin" for Twine 2 / SugarCube 2.

	Home Page: https://github.com/HiEv/UInv

	v0.5.7 - March 29, 2018 - (preview release 1)
		- 62 functions written out of 108 planned functions
	v0.6.9 - April 6, 2018 - (preview release 2)
		- 28 new functions written + 23 new functions planned
		- some functions renamed to conform to consistent naming style
	v0.7.7 - April 18, 2018 - (preview release 3)
		- 32 new functions written + 27 new functions planned
		- some functions renamed to conform to consistent naming style
		- most previously incomplete functions are now complete
		- lots of debugging and additional error checking done
	v0.8.6 - April 24, 2018 - (preview release 4)
		- 25 new functions written + 13 new functions planned
		- some functions renamed to conform to consistent naming style
		- work on help file started (very preliminary)
	v0.9.1 - May 10, 2018 - (preview release 5)
		- 18 new functions written + 11 new functions planned
		- added default bags
		- major rework of engine to allow deletion of default properties
		- some bugs fixed
	v0.9.2 - May 23, 2018 - (preview release 6)
		- 10 new functions written + 8 new functions planned
		- renamed BagCount to GetBagCount for more consistent naming style
		- moved data sections to bottom to make updating UInv easier
		- some bugs fixed
		- Item Builder added to UInv help file
	v0.9.4 - July 8, 2018 - (preview release 7)
		- 22 new functions written + 19 new functions planned
		- some functions renamed to conform to consistent naming style
		- centralized more functions for display utilities
		- saved a bit more memory/history size
		- handled a potential problem with non-static default properties
		- improved compatibility with other browsers
		- moved utility functions inside UInv namespace
	v0.9.5 - July 23, 2018 - (preview release 8)
		- 12 new functions written + 12 new functions planned
		- revamped error handling to add thrown errors
		- added utility functions for engine detection
		- saved a bit more memory/history size
		- major restructuring of item data
		- added handling of variable items and variable bags
	v0.9.6 - September 25, 2018 - (preview release 9)
		- 31 new functions written + 27 new functions planned
		- major bugfix in SwapItems and many "Tag" functions
		- all utility function names now start lowercase
		- added the ability to cache images for online usage
		- the UInv Safe Save Code has been updated (see help)
		- added option for sending UInv errors to console
		- typing "xyzzy" now toggles console (F12) error log
		- began implementation of display elements
			* table
			* radialMenu
		- began implementation of event handlers
			"general" events:
				* MouseDown
				* MouseUp
			"bag" events:
				* Touched
			"table" events:
				* Accept
				* DragStart
				* Drop
				* DragStop
			"radialMenu" events:
				* Open
				* WedgeClick
				* DisabledWedgeClick
				* Cancel
			"cacheImages" events:
				* Loaded
				* Error
		- added Font Awesome support: https://fontawesome.com/free
		  just add the following line to your stylesheet section:
@import url('https://use.fontawesome.com/releases/v5.3.1/css/all.css');
		  see the "FA_Icons.html" sample for the list of icons
		- jQuery UI is now required to support display elements
		  https://api.jqueryui.com/category/all/
		  just include and load the jquery-ui.css and jquery-ui.js
		  files, along with the "images/ui-*.png" images
	v0.9.7 - December 29, 2018 - (preview release 10)
		- 40 new functions written (including 2 macros) + 38 new functions planned
		- added Pocket/Container functions; items can now contain other items
		- updated existing functions to work with pockets properly
		- updated more functions to support bag name arrays
		- added a <<UInvSet>> macro to shorten calls to multiple UInv functions
		- added a <<UInvTry>> macro to simplify error handling in TwineScript
		- added more ways to add default items to default bags
		- default return value on error was standardized to "undefined"
		- enforced stricter verification of values for item names (must be lowercase, etc...)
		- removed LockUpdates function; use IncrementUpdateLock and DecrementUpdateLock instead
		- removed capitalizeFirstLetter function; use SugarCube's .toUpperFirst() instead
		- discovered a function I wrote and apparently forgot to document anywhere (LOL)
		- renamed the following functions to conform to consistent naming style (aliases added):
			* ArrayHasAllBagProperties to BagHasAllProperties
			* ArrayHasAllItemProperties to ItemHasAllProperties
			* GetBagArrayWithAllProperties to GetBagsArrayWithAllProperties (added an "s")
			* GetHighestBagPropertyValue to GetBagWithHighestPropertyValue
			* GetHighestItemPropertyValue to GetItemWithHighestPropertyValue
			* GetLowestBagPropertyValue to GetBagWithLowestPropertyValue
			* GetLowestItemPropertyValue to GetItemWithLowestPropertyValue
			* SetItemsPropertyValues to SetItemsPropertyValue (removed an "s")
			* UpdateItemProperties to SetItemPropertyValues
		- fixes/improvements to valuesAreEqual, arraysAreEqual, and objectsAreEqual
		- corrected two minor inefficiencies in memory/history usage
		- fixed a few incorrect function names in error messages
		- fixed a problem with items changed to variable type still using default properties
		- fixed a problem where variable type items might not merge when they should
		- fixed GetBagWithHighestPropertyValue and GetBagWithLowestPropertyValue functions
		- fixed a bug in BagHasAllProperties
		- preliminary work on unit/regression testing tool (37 functions fully tested)
		- property values may now be set to "undefined"
		- new/updated general help file sections:
			* Changelog
			* Function Cheat Sheet
			* Basic UInv Functions (incomplete)
			* Error Handling (incomplete)
			* Efficient UInv Coding
			* Arrays vs Generic Objects (major improvements; incomplete)
			* The UInv Data Structure
		- worked on how help file entries should look for UInv functions (see "AddBag")
		- modified UInv structure to support internal-use-only functions and variables
			* this means you'll need to insert your bag, item, and alias definitions this update
		- Over 10,000 non-blank lines of code and comments!  Yay for arbitrary milestones!
*/

/*
	The next two comments block are to support JavaScript validators such as:
		https://eslint.org/demo/
		http://JSHint.com/
		https://deepscan.io/demo/
		http://beautifytools.com/javascript-validator.php
*/
/* jshint -W014 */
/*
	global UInv, $, setup, clone, opr, safari, Config, Browser, State,
	random, passage, window, document, navigator, alert, console, Image,
	setTimeout, Macro, Scripting, version
*/

// Increase SugarCube maxLoopIterations if needed.
if (Config.macros.maxLoopIterations < 2000) {
	Config.macros.maxLoopIterations = 2000;
}

if (setup.ImagePath === undefined) {  // Do this better later ***
	setup.ImagePath = "";
}

/* -- Universal Inventory System (UInv) -- */

// UInvObject: UInv constructor and initialization object:
function UInvObject () {

	if ((typeof version == "undefined") || (typeof version.title == "undefined") || (version.title != "SugarCube")
		|| (typeof version.major == "undefined") || (version.major < 2)
		|| (typeof version.minor == "undefined") || (version.minor < 8)) {
		throw new Error("UInv requires SugarCube v2.8.0 or greater.  Please upgrade to the latest version of the SugarCube v2 story format");
	}

	// deepFreeze: Freeze everything in an object's property tree.
	function deepFreeze (Obj) {
		var value, name, i, propNames = Object.getOwnPropertyNames(Obj);
		// Freeze the object's child properties before freezing the object.
		for (i = 0; i < propNames.length; i++) {
			name = propNames[i];
			value = Obj[name];
			Obj[name] = value && typeof value === "object" ? deepFreeze(value) : value;  // Recursively handle sub-properties, if any exist.
		}
		return Object.freeze(Obj);
	}

	/* parseUInvLine: Returns a string with "UInv." added in front of any UInv function names in the Txt string, provided that:
			* they're a valid UInv function name (including aliases)
			* they're preceded by a " ", tab, ",", "+", "-", "/", "*", "%", "=", "<", ">", "!", "&", "|", "?", "(", "[", "{", or ":"
			* they're immediately followed by a "(" (the left parenthesis)
			* they're not within a string (within a pair of single or double-quotes)
	*/
	function parseUInvLine (TxtIn) {
		var Prec = [" ", "	", ",", "+", "-", "/", "*", "%", "=", "<", ">", "!", "&", "|", "?", "(", "[", "{", ":"];
		var Group = ["'", '"'];
		TxtIn = TxtIn.trim();
		var TxtOut = "", Word = "", Prv = "+", n = 0, g = -1;
		while (n < TxtIn.length) {
			if (g < 0) {
				if (TxtIn[n] == "(") {
					if (Prec.includes(Prv) && (UInv.isFunction(UInv[Word]) || UInv.isProperty(UInv, Word))) {
						TxtOut += "UInv." + Word;
					} else {
						TxtOut += Word;
					}
					Word = "";
				}
				if (Prec.includes(TxtIn[n])) {
					TxtOut += Word + TxtIn[n];
					Prv = TxtIn[n];
					Word = "";
				} else if (Group.includes(TxtIn[n])) {
					g = Group.indexOf(TxtIn[n]);
					TxtOut += Word;
					Word = TxtIn[n];
				} else {
					Word += TxtIn[n];
				}
			} else {
				Word += TxtIn[n];
				if (TxtIn[n] == Group[g]) {
					Prv = Group[g];
					g = -1;
					TxtOut += Word;
					Word = "";
				}
			}
			n++;
		}
		TxtOut += Word;
		return TxtOut;
	}

	// Lock the existing property values to prevent accidental changes.
	deepFreeze(this);

	// Debugging Feature: Enables directing errors to the console by typing "xyzzy".
	var UInvDebugTrigger = "";
	$(document).on("keypress", function (ev) {
		UInvDebugTrigger += ev.key;
		if (UInvDebugTrigger.length > 5) {
			UInvDebugTrigger = UInvDebugTrigger.slice(-5);
		}
		if (UInvDebugTrigger === "xyzzy") {
			if (UInv.isUndefined(setup.UInvUserAlertsDebug)) {
				setup.UInvUserAlertsBackup = UInv.GetUserAlerts();
				UInv.SetUserAlerts(UInv.ERROR_SHOW_PASSAGE_NAME + UInv.ERROR_TO_CONSOLE);
				setup.UInvUserAlertsDebug = UInv.ERROR_SHOW_PASSAGE_NAME + UInv.ERROR_TO_CONSOLE;
				alert("UInv: Errors will now be shown in the console window.\nHit F12 to open the console window.");
				console.log("UInv: Error logging enabled.\n$UInvLastErrorMessage = " + State.variables.UInvLastErrorMessage);
			} else {
				UInv.SetUserAlerts(setup.UInvUserAlertsBackup);
				delete setup.UInvUserAlertsBackup;
				console.log("UInv: Error logging reverted to default. (" + setup.UInvUserAlertsDebug + ")");
				alert("UInv: Error logging reverted to default. (" + setup.UInvUserAlertsDebug + ")");
				delete setup.UInvUserAlertsDebug;
			}
		}
	});

	// Automatically link up UInv display elements when passage is rendered.
	$(document).on(":passagerender", function (ev) {
		if (!UInv.UpdatesAreLocked()) {
			UInv.UpdateDisplay(ev.content);
		}

		var el = $("#uinv-radial-menu").get(0);
		if (UInv.isUndefined(el)) {
			UInv.InitializeRadialMenu();
		} else {
			if (el.dataset.status == "opened") {  // Cancel radial menu
				ev.cancelType = "NewPassage";
				var Ret = UInv.CallEventHandler("radialMenu", "Cancel", ev);  // radialMenu Cancel event (New passage)
				if (Ret.keepOpen !== true) {
					el.dataset.status = "closed";
					el.style.transform = "scale(0, 0)";
					el.style.opacity = 0;
				}
				UInv.UpdateDisplay();
			}
		}

		// Textarea cursor fix for Chrome & Firefox.
		$(ev.content).find("textarea").mousemove(function (e) {
			var myPos = $(this).offset();
			myPos.bottom = $(this).offset().top + $(this).outerHeight();
			myPos.right = $(this).offset().left + $(this).outerWidth();
			if (myPos.right > e.pageX && e.pageX > myPos.right - 16) {
				if (myPos.bottom > e.pageY && e.pageY > myPos.bottom - 16) {
					if ($(this).css("cursor") != "ns-resize") {
						$(this).css("cursor", "ns-resize");  // Chrome fix
					}
				} else {
					if ($(this).prop("clientHeight") < $(this).prop("scrollHeight")) {
						if ($(this).css("cursor") != "default") {
							$(this).css("cursor", "default");  // Firefox fix
						}
					} else {
						if ($(this).css("cursor") != "auto") {
							$(this).css("cursor", "auto");
						}
					}
				}
			} else {
				if ($(this).css("cursor") != "auto") {
					$(this).css("cursor", "auto");
				}
			}
		});

	});

	// <<UInvSet>> macro: This macro wraps each line in <<set (line)>>, adds "UInv." in front of any UInv function calls (including custom aliases), and executes it.
	/* Usage:
			<<UInvSet>>
				AddBag("backpack")
				AddItem("", "pants")
				SetItemQuantity("", "", 5 + BagHasItem("", ""))
				_Items = GetType(_itemType)
			<</UInvSet>>
	*/
	Macro.add('UInvSet', {
		skipArgs : true,
		tags     : null,
		handler  : function () {
			var Lines = this.payload[0].contents.split("\n"), i, output = "";
			for (i = 0; i < Lines.length; i++) {
				Lines[i] = parseUInvLine(Lines[i]);
				if (Lines[i] != "") {
					output += "<<set " + Lines[i].trim() + ">>";
				}
			}
			$(this.output).wiki(output);
		}
	});

	// <<UInvTry>> macro: This macro tries to execute a <<set>> macro, adding "UInv." in front of any UInv functions.  Failure is determined by whether or not UInv (or any other code) throws an error.
	//                    If it succeeds, the chunk of code between <<UInvTry>> and <<Failure>> will execute normally, and the code between <<Failure>> and <</UInvTry>> will *not* execute.
	//                    If there is an error, the chunk of code between <<Failure>> and <</UInvTry>> will execute normally, and the code between <<UInvTry>> and <<Failure>> will *not* execute.
	/* Usage:
			<<UInvTry "AddBag('backpack')">>\
				Success!
			<<Fail>>\
				Failure: $UInvLastErrorMessage
			<</UInvTry>>\
	*/
	Macro.add('UInvTry', {
		skipArgs : false,
		tags     : ["Fail"],
		handler  : function () {
			if ((this.args.length < 1) || (!UInv.isString(this.args[0]))) {
				throw new Error("<<UInvTry>> macro needs a string of code as an argument to test.");
			}
			if (this.payload.length != 2) {
				throw new Error('<<UInvTry>> macro needs to be set up using the <<UInvTry "(code to try here)">>(success code here)<<Fail>>(failure code here)<</UInvTry>> format.');
			}
			var Action = "_UInvResult = " + parseUInvLine(this.args[0]);
			try {
				var TmpErr = UInv.GetLastError(true);
				Scripting.evalTwineScript(Action);
				if (UInv.GetLastError() === "") {
					if (TmpErr) {
						State.variables.UInvLastErrorMessage = TmpErr;
					}
					// Success
					$(this.output).wiki(this.payload[0].contents);
				} else {
					// Failure
					$(this.output).wiki(this.payload[1].contents);
				}
			} catch(error) {
				// Failure
				State.variables.UInvLastErrorMessage = "SugarCube Error: " + error.message;
				$(this.output).wiki(this.payload[1].contents);
			}
		}
	});
}
UInvObject.prototype = (function () {

	// UInv Private Functions:  (internal use only)
	// =======================

	// Error: Handle setting $UInvLastErrorMessage to the error string and possibly displaying UInv errors based on the value of $UInvShowAlerts.
	//        This can be used for debugging and/or letting users know how to report this error.
	function UInvError (ErrStr) {
		var AlertMsg = "Error: " + ErrStr, Txt, GUA = UInv.GetUserAlerts();
		if (GUA) {
			if (GUA & UInv.ERROR_SHOW_PASSAGE_NAME) {  // jshint ignore:line
				Txt = 'Passage="' + passage() + '"';
				State.variables.UInvLastErrorMessage += " - " + Txt;
				AlertMsg += "\n" + Txt;
			}
			if (UInv.isProperty(State.variables, "UInvErrorStringAddendum")) {
				Txt = State.variables.UInvErrorStringAddendum;
				State.variables.UInvLastErrorMessage += " - " + Txt;
				AlertMsg += "\n\n" + Txt;
			}
		}
		State.variables.UInvLastErrorMessage = AlertMsg;
		if (GUA & UInv.ERROR_SHOW_ALERT) {  // jshint ignore:line
			alert(AlertMsg);
		}
		if (GUA & UInv.ERROR_TO_CONSOLE) {  // jshint ignore:line
			console.log(AlertMsg);
		}
		if (GUA & UInv.ERROR_THROW_ERROR) {  // jshint ignore:line
			throw new Error("UInv " + State.variables.UInvLastErrorMessage);   // This must be last because it exits the function here.
		}
		return GUA;  // Success
	}

	// FixBagName: Returns $UInvCurrentBagName if BagName === "", else returns BagName, or undefined on error.
	function FixBagName (BagName) {
		if (UInv.isString(BagName)) {
			if ((BagName === "") && UInv.isString(UInv.GetCurrentBagName())) {
				return UInv.GetCurrentBagName();
			}
			return BagName;  // Success
		} else {
			UInvError('BagName passed to FixBagName is not a string.');  // Error
			return undefined;
		}
	}

	// ValidateItemName: Returns validated ItemName or undefined on failure.
	function ValidateItemName (ItemName) {
		if (UInv.isString(ItemName)) {
			var NewItemName = ItemName.toLowerCase();
			if (!UInv.ReservedBagProperties_LC.includes(NewItemName)) {
				return NewItemName;  // Success
			} else {
				return undefined;  // Failure
			}
		} else {
			return undefined;  // Failure
		}
	}

	// FixItemName: Returns $UInvCurrentItemName if ItemName === "", else returns ItemName, or undefined on error.
	function FixItemName (ItemName) {
		if (UInv.isString(ItemName)) {
			var NewItemName = ItemName.toLowerCase();  // fix case since all item names are lowercase
			if (!UInv.ReservedBagProperties_LC.includes(NewItemName)) {
				if ((NewItemName === "") && UInv.isString(UInv.GetCurrentItemName())) {  // OOO function call
					NewItemName = ValidateItemName(UInv.GetCurrentItemName());  // OOO function call
					if (NewItemName) {
						return NewItemName;  // Success
					} else {
						delete State.variables.UInvCurrentItemName;  // delete invalid value
						return "";  // Success
					}
				}
				return NewItemName;  // Success
			} else {
				UInvError('FixItemName failed.  Illegal item name "' + ItemName + '" used.');  // Error
				return undefined;
			}
		} else {
			UInvError('ItemName passed to FixItemName is not a string.');  // Error
			return undefined;
		}
	}

	function FixContainerReferences (OldBagName, OldItemName, NewBagName, NewItemName) {
		var PocketNames = UInv.GetItemPocketNameArray(NewBagName, NewItemName);
		if (PocketNames.length > 0) {
			var PocketBag, Containers, i, j;
			for (i = 0; i < PocketNames.length; i++) {  // Update pockets' references to match the container's new bag and/or item name(s)
				PocketBag = UInv.GetItemPocketBagName(NewBagName, NewItemName, PocketNames[i]);
				Containers = UInv.GetPocketBagContainerArray(PocketBag);
				for (j = 0; j < Containers.length; j++) {
					if ((Containers[j].ContainerBagName == OldBagName) && (Containers[j].ContainerName == OldItemName) && (Containers[j].PocketName == PocketNames[i])) {
						State.variables.UInvBags[PocketBag].UInvContainer[j].ContainerBagName = NewBagName;
						State.variables.UInvBags[PocketBag].UInvContainer[j].ContainerName = NewItemName;
					}
				}
			}
		}
		return true;  // Success
	}

	// tryIntParse: Attempts to parse strings to integers if Value is a string, returns either a number or undefined if Value isn't a number
	function tryIntParse (Value) {
		if (UInv.isString(Value)) {
			if (UInv.isNumber(parseInt(Value))) {
				Value = parseInt(Value);
			}
		}
		if (UInv.isNumber(Value)) {
			return Value;  // Success
		}
		return undefined;  // Unable to parse
	}

	// RemoveItemObjectsDefaultProperties: Removes all default properties from Obj.  Returns true on success or undefined on error.
	// !!!IMPORTANT!!! - The object passed to this function is directly modified by this function.  Do not pass objects that shouldn't be modified!!!
	function RemoveItemObjectsDefaultProperties (Obj, DefaultItemType) {
		if (UInv.isGenericObject(Obj)) {
			if (UInv.isString(DefaultItemType)) {
				var DefItem = UInv.GetDefaultItemObject(DefaultItemType);
				if (DefItem) {  // delete all properties that are equal to GetDefaultItemObject properties of DefaultItemType
					var DefKeys = Object.keys(DefItem), i;
					if ((DefKeys.length > 0) && (!DefKeys.includes("UInvVariableType"))) {
						for (i = 0; i < DefKeys.length; i++) {
							if (!["UInvPocket", "UInvQuantity"].includes(DefKeys[i])) {
								if (UInv.isProperty(Obj, DefKeys[i])) {
									if (UInv.valuesAreEqual(Obj[DefKeys[i]], DefItem[DefKeys[i]])) {
										delete Obj[DefKeys[i]];  // Matches default value of GetDefaultItemObject version
									}
								}
							}
						}
					}
				}
				return true;  // Success
			} else {
				UInvError('DefaultItemType passed to RemoveItemObjectsDefaultProperties is not a string.');  // Error
				return undefined;
			}
		} else {
			UInvError('RemoveItemObjectsDefaultProperties failed. Obj is not a generic object.');  // Error
			return undefined;
		}
	}

	return {

	// UInv Public Functions:
	// ======================

		// UInv Constructor:
		// =================

		constructor : UInvObject,

		// UInv Constants:
		// ===============

		// Values for UInvMergeItemMethod and UInv.SetMergeItemMethod to determine how UInv handles item collision.
		MERGE_USE_ONLY_DESTINATION_PROPERTIES : 1,  // Ignore source properties, just increment destination's quantity. (default)
		MERGE_USE_ONLY_SOURCE_PROPERTIES : 2,       // Delete the destination's properties, replace with the source's properties and values, and increment the quantity.
		MERGE_PREFER_DESTINATION_PROPERTIES : 3,    // Keep the properties and values in the destination, add any properties and values the source had but the destination didn't, and increment the quantity.
		MERGE_PREFER_SOURCE_PROPERTIES : 4,         // Keep the properties and values in the source, add any properties and values the destination had but source the didn't, and increment the quantity.
		MERGE_RENAME_SOURCE_ITEMNAME : 5,           // Rename the source's unique identifier so that it's stored separately in the destination bag.
		MERGE_FAIL_WITH_ERROR : 6,                  // Fail with an error.

		// Values for $UInvShowAlerts, used with SetUserAlerts.  Values can be added together except for ERROR_NONE.
		ERROR_NONE : false,           // Do not display any error messages to users.
		ERROR_SHOW_PASSAGE_NAME : 1,  // Displays the current passage name in any error messages.
		ERROR_SHOW_ALERT : 2,         // Displays a modal dialog box for each error message and pauses execution.
		ERROR_THROW_ERROR : 4,        // Throws traditional Twine/SugarCube error messages, instead of silently returning a value which indicates that a UInv error occurred.
		ERROR_TO_CONSOLE : 8,         // Outputs any error messages to the console window.

		// AP style says that positive integers less than 10 should be written as text.  This array converts values zero through nine a text.  (e.g. UInv.NumText[5] === "five")
		NumText : ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"],  // Used in Display functions.
		// AP style says that ordinals from one through nine should be written as text.  This array converts values one through nine to text.  (e.g. UInv.OrdinalText[5] === "fifth")
		OrdinalText : ["0th", "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth"],  // do not use 0
		OrdinalSuffix : ["th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th"],

		// The default maximum number of images to cache.
		DefaultMaxCache : 100,
		// The default maximum number of images to download at the same time using the image cache code.
		DefaultMaxConcurrent : 5,

		// Reserved property names within bags.
		ReservedBagProperties : ["", "-", "UInvTouched", "UInvProperties", "UInvDefaultBagType", "UInvContainer"],
		ReservedBagProperties_LC : ["", "-", "uinvtouched", "uinvproperties", "uinvdefaultbagtype", "uinvcontainer"],  // lowercase version
		// Reserved property names within items.
		ReservedItemProperties : ["UInvQuantity", "UInvDefaultItemType", "UInvVariableType", "UInvPocket", "UInvCell"],

		// This is the maximum pocket depth allowed on default items or bags to prevent accidental infinite recursion or exponential explosions.
		MaximumPocketDepth : 3,


		// UInv Utility Functions:
		// =======================

		// isArray: Returns if a value is an array.
		isArray : function (Value) {
			return Array.isArray(Value);
		},

		// isBoolean: Returns if a value is a boolean.
		isBoolean : function (Value) {
			return typeof Value === "boolean";
		},

		// isDate: Returns if value is a date object.
		isDate : function (Value) {
			return Value instanceof Date;
		},

		// isFunction: Returns if a value is a function.
		isFunction : function (Value) {
			return typeof Value === "function";
		},

		// isGenericObject: Returns if a value is a generic object.
		isGenericObject : function (Value) {
			return !!Value && typeof Value === "object" && Value.constructor === Object;
		},

		// isInteger: Returns if a value is an integer.
		isInteger : function (Value) {
			return Number.isInteger(Value);
		},

		// isNumber: Returns if a value is a number.
		isNumber : function (Value) {
			return typeof Value === "number" && Number.isFinite(Value);
		},

		// isObject: Returns if a value is an object.
		isObject : function (Value) {
			return !!Value && typeof Value === "object";
		},

		// isProperty: Returns if Prop is a property of the object Obj.
		isProperty : function (Obj, Prop) {
			if (UInv.isObject(Obj)) {
				return Obj ? hasOwnProperty.call(Obj, Prop) : false;
			}
			return false;
		},

		// Returns if a value is a regexp.
		isRegExp : function (Value) {
			return !!Value && typeof Value === "object" && Value.constructor === RegExp;
		},

		// isString: Returns if a value is a string.
		isString : function (Value) {
			return typeof Value === "string" || Value instanceof String;
		},

		// isUndefined: Returns if a value is undefined.
		isUndefined : function (Value) {
			return typeof Value === "undefined";
		},

		// valuesAreEqual: Check two variables to see if they're identical.  This function does not support comparing symbols, functions, or custom types.
		//                 IgnoreObjectPairs is for internal use to prevent infinite loops of objects.
		valuesAreEqual : function (Var1, Var2, IgnoreObjectPairs) {
			if (typeof Var1 === typeof Var2) {
				switch (typeof Var1) {
					case "string":
					case "number":
					case "boolean":
						return Var1 === Var2;  // Returns whether variables are equal or not.
					case "undefined":
						return true;  // Variables are both undefined.
					case "object":
						if (UInv.isArray(Var1) && UInv.isArray(Var2)) {  // Return whether arrays are equal.
							return UInv.arraysAreEqual(Var1, Var2, IgnoreObjectPairs);  // OOO function call  (OOO = Out Of Order, meaning that function exists in the code below, instead of above.)
						} else if (UInv.isGenericObject(Var1) && UInv.isGenericObject(Var2)) {  // Return whether objects are equal.
							return UInv.objectsAreEqual(Var1, Var2, IgnoreObjectPairs);  // OOO function call
						} else if (UInv.isDate(Var1) && UInv.isDate(Var2)) {
							return (Var1 - Var2) == 0;  // Returns whether dates are equal.
						} else if ((Var1 === null) && (Var2 === null)) {
							return true;  // Objects are both null.
						}
						return false;  // Objects either don't match or are of an unsupported type.
					default:
						return false;  // Unsupported type.
				}
			} else {
				return false;  // Variables are not of the same type.
			}
		},

		// arraysAreEqual: Check two arrays to see if they're identical.  IgnoreObjectPairs is for internal use to prevent infinite loops of objects.
		arraysAreEqual : function (Array1, Array2, IgnoreObjectPairs) {
			if (UInv.isArray(Array1) && UInv.isArray(Array2)) {
				var i = 0;
				if (UInv.isUndefined(IgnoreObjectPairs)) {
					IgnoreObjectPairs = [];
				}
				if (IgnoreObjectPairs.length > 0) {
					for (i = 0; i < IgnoreObjectPairs.length; i++) {
						if (((IgnoreObjectPairs[i][0] === Array1) && (IgnoreObjectPairs[i][1] === Array2)) ||
							((IgnoreObjectPairs[i][0] === Array2) && (IgnoreObjectPairs[i][1] === Array1))) {
								return true;  // Ignores object pairs that have already been checked to prevent infinite loops.
						}
					}
				}
				IgnoreObjectPairs.push([Array1, Array2]);
				if (Array1.length !== Array2.length) {
					return false;  // Arrays are not the same length.
				}
				if (Array1.length > 0) {
					for (i = 0; i < Array1.length; i++) {
						if (!UInv.valuesAreEqual(Array1[i], Array2[i], IgnoreObjectPairs)) {
							return false;  // Values or types do not match.
						}
					}
				}
				return true;  // All values match.
			}
			return false;  // Both are not arrays.
		},

		// objectsAreEqual: Check two objects to see if they're identical.  IgnoreObjectPairs is for internal use to prevent infinite loops of objects.
		objectsAreEqual : function (Obj1, Obj2, IgnoreObjectPairs) {
			if (UInv.isObject(Obj1) && UInv.isObject(Obj2)) {
				var i = 0;
				if (UInv.isUndefined(IgnoreObjectPairs)) {
					IgnoreObjectPairs = [];
				}
				if (IgnoreObjectPairs.length > 0) {
					for (i = 0; i < IgnoreObjectPairs.length; i++) {
						if (((IgnoreObjectPairs[i][0] === Obj1) && (IgnoreObjectPairs[i][1] === Obj2)) ||
							((IgnoreObjectPairs[i][0] === Obj2) && (IgnoreObjectPairs[i][1] === Obj1))) {
								return true;  // Ignores object pairs that have already been checked to prevent infinite loops.
						}
					}
				}
				IgnoreObjectPairs.push([Obj1, Obj2]);
				if (UInv.isGenericObject(Obj1) && UInv.isGenericObject(Obj2)) {
					var Keys1 = Object.keys(Obj1).sort(), Keys2 = Object.keys(Obj2).sort();
					if (!UInv.arraysAreEqual(Keys1, Keys2)) {
						return false;  // Objects have a different number of keys or have different keys.
					}
					if (Keys1.length > 0) {
						var Key;
						for (i = 0; i < Keys1.length; i++) {
							Key = Keys1[i];
							if (!UInv.valuesAreEqual(Obj1[Key], Obj2[Key], IgnoreObjectPairs)) {
								return false;  // Values do not match.
							}
						}
					}
					return true;  // All values match.
				} else {
					return UInv.valuesAreEqual(Obj1, Obj2, IgnoreObjectPairs);  // Return whether objects match.
				}
			}
			return false;  // Both are not objects.
		},

		// arrayHasTag: Returns the number of times Tag is found in array, or undefined if there is an error.
		arrayHasTag : function (Arr, Tag) {
			if (!UInv.isUndefined(Tag) && UInv.isArray(Arr)) {
				return Arr.count(Tag);
			} else {
				return undefined;  // Error
			}
		},

		// arrayHasAllTags: Returns true if Array1 has an equal or greater number of all tags in TagArray, or undefined if there is an error.
		arrayHasAllTags : function (Arr, TagArray) {
			if (UInv.isArray(Arr) && UInv.isArray(TagArray)) {
				if (TagArray.length > 0) {
					if (Arr.length >= TagArray.length) {
						var i = 0;
						for (i = 0; i < TagArray.length; i++) {
							if (Arr.count(TagArray[i]) < TagArray.count(TagArray[i])) {
								return false;
							}
						}
					} else {
						return false;  // Array1 can't have enough tags to satisfy test.
					}
					return true;
				} else {
					return false;  // TagArray is empty.
				}
			} else {
				return undefined;  // Error
			}
		},

		// arrayHasAnyTag: Returns true if Array1 has at least one of the tags in TagArray, or undefined if there is an error.
		arrayHasAnyTag : function (Arr, TagArray) {
			if (UInv.isArray(Arr) && UInv.isArray(TagArray)) {
				if (TagArray.length > 0) {
					var i = 0;
					for (i = 0; i < TagArray.length; i++) {
						if (Arr.includes(TagArray[i])) {
							return true;
						}
					}
					return false;
				} else {
					return false;  // TagArray is empty
				}
			} else {
				return undefined;  // Error
			}
		},

		// isArrayOfArrays: Test an array to see if all the values are arrays.  Returns undefined on error.
		isArrayOfArrays : function (Arr) {
			if (UInv.isArray(Arr)) {
				var i = 0;
				if (Arr.length) {
					for (i = 0; i < Arr.length; i++) {
						if (!UInv.isArray(Arr[i])) {
							return false;  // Array is not all arrays
						}
					}
					return true;  // Array is all arrays
				}
				return false;  // Array is empty
			} else {
				return undefined;  // Error: Not an array
			}
		},

		// isArrayOfBooleans: Test an array to see if all the values are booleans.  Returns undefined on error.
		isArrayOfBooleans : function (Arr) {
			if (UInv.isArray(Arr)) {
				var i = 0;
				if (Arr.length) {
					for (i = 0; i < Arr.length; i++) {
						if (!UInv.isBoolean(Arr[i])) {
							return false;  // Array is not all booleans
						}
					}
					return true;  // Array is all booleans
				}
				return false;  // Array is empty
			} else {
				return undefined;  // Error: Not an array
			}
		},

		// isArrayOfGenericObjects: Test an array to see if all the values are generic objects.  Returns undefined on error.
		isArrayOfGenericObjects : function (Arr) {
			if (UInv.isArray(Arr)) {
				var i = 0;
				if (Arr.length) {
					for (i = 0; i < Arr.length; i++) {
						if (!UInv.isGenericObject(Arr[i])) {
							return false;  // Array is not all generic objects
						}
					}
					return true;  // Array is all generic objects
				}
				return false;  // Array is empty
			} else {
				return undefined;  // Error: Not an array
			}
		},

		// isArrayOfIntegers: Test an array to see if all the values are integers.  Returns undefined on error.
		isArrayOfIntegers : function (Arr) {
			if (UInv.isArray(Arr)) {
				var i = 0;
				if (Arr.length) {
					for (i = 0; i < Arr.length; i++) {
						if (!UInv.isInteger(Arr[i])) {
							return false;  // Array is not all integers
						}
					}
					return true;  // Array is all integers
				}
				return false;  // Array is empty
			} else {
				return undefined;  // Error: Not an array
			}
		},

		// isArrayOfNumbers: Test an array to see if all the values are numbers.  Returns undefined on error.
		isArrayOfNumbers : function (Arr) {
			if (UInv.isArray(Arr)) {
				var i = 0;
				if (Arr.length) {
					for (i = 0; i < Arr.length; i++) {
						if (!UInv.isNumber(Arr[i])) {
							return false;  // Array is not all numbers
						}
					}
					return true;  // Array is all numbers
				}
				return false;  // Array is empty
			} else {
				return undefined;  // Error: Not an array
			}
		},

		// isArrayOfObjects: Test an array to see if all the values are objects.  Returns undefined on error.
		isArrayOfObjects : function (Arr) {
			if (UInv.isArray(Arr)) {
				var i = 0;
				if (Arr.length) {
					for (i = 0; i < Arr.length; i++) {
						if (!UInv.isObject(Arr[i])) {
							return false;  // Array is not all objects
						}
					}
					return true;  // Array is all objects
				}
				return false;  // Array is empty
			} else {
				return undefined;  // Error: Not an array
			}
		},

		// isArrayOfStrings: Test an array to see if all the values are strings.  Returns undefined on error.
		isArrayOfStrings : function (Arr) {
			if (UInv.isArray(Arr)) {
				var i = 0;
				if (Arr.length) {
					for (i = 0; i < Arr.length; i++) {
						if (!UInv.isString(Arr[i])) {
							return false;  // Array is not all strings
						}
					}
					return true;  // Array is all strings
				}
				return false;  // Array is empty
			} else {
				return undefined;  // Error: Not an array
			}
		},

		// combineGenericObjects: Returns a new object that has the combined properties of Obj1 and Obj2, with Obj2's properties preferred when both objects have matching property names.
		//                        Returns undefined on error.
		combineGenericObjects : function (Obj1, Obj2) {
			if (UInv.isGenericObject(Obj1) && UInv.isGenericObject(Obj2)) {
				var Result = clone(Obj1), i, Keys = Object.keys(Obj2);
				for (i = 0; i < Keys.length; i++) {
					if (UInv.isObject(Obj2[Keys[i]])) {
						Result[Keys[i]] = clone(Obj2[Keys[i]]);
					} else {
						Result[Keys[i]] = Obj2[Keys[i]];
					}
				}
				return Result;  // Success
			} else {
				return undefined;  // Error: Not generic objects
			}
		},

		// getUniqueArray: Returns an array so that all elements of the original array are now unique, or undefined on error.
		getUniqueArray : function (Arr) {
			if (UInv.isArray(Arr)) {
				var hash = {};
				Arr.forEach( function (value) { hash[value + '::' + typeof value] = value; } );
				return Object.keys(hash).map( function (value) { return hash[value]; } );
			} else {
				return undefined;  // Error: Not an array
			}
		},

		// getArraySortedByOtherArray: Returns UnsortedArray sorted based on ArrayToSortBy and subsorted by UnsortedArray value.  This is a case insensitive sort.
		//                             If RemoveDuplicates is true, it also removes any elements where its pair is duplicated in both arrays.
		getArraySortedByOtherArray : function (UnsortedArray, ArrayToSortBy, RemoveDuplicates) {

			function GreaterThan(A, B) {
				if (UInv.isString(A)) {
					A = A.toLowerCase();
				}
				if (UInv.isString(B)) {
					B = B.toLowerCase();
				}
				return A > B;
			}

			if (UInv.isArray(UnsortedArray) && UInv.isArray(ArrayToSortBy)) {
				if (UnsortedArray.length === ArrayToSortBy.length) {
					var UA = clone(UnsortedArray), ATSB = clone(ArrayToSortBy);
					if (UA.length > 1) {
						var i = 0, j = 0, n = 0, temp, length = ATSB.length, done = true;
						for (i = 0; i < length / 2; i++) {  // improved cocktail shaker sort with subsorting by unsorted array
							done = true;
							for (j = i; j < length - i - 1; j++) {
								if (GreaterThan(ATSB[j], ATSB[j + 1]) || ((ATSB[j] === ATSB[j + 1]) && GreaterThan(UA[j], UA[j + 1]))) {
									temp = ATSB[j];
									ATSB[j] = ATSB[j + 1];
									ATSB[j + 1] = temp;
									temp = UA[j];
									UA[j] = UA[j + 1];
									UA[j + 1] = temp;
									done = false;
								}
								n = length - j - 1;
								if (GreaterThan(ATSB[n - 1], ATSB[n]) || ((ATSB[n - 1] === ATSB[n]) && GreaterThan(UA[n - 1], UA[n]))) {
									temp = ATSB[n];
									ATSB[n] = ATSB[n - 1];
									ATSB[n - 1] = temp;
									temp = UA[n];
									UA[n] = UA[n - 1];
									UA[n - 1] = temp;
									done = false;
								}
							}
							if (done) {
								break;
							}
						}
						if (RemoveDuplicates) {
							i = 0;
							while (i < ATSB.length - 1) {
								if ((ATSB[i] === ATSB[i+1]) && (UA[i] === UA[i+1])) {
									ATSB.deleteAt(i);
									UA.deleteAt(i);
								} else {
									++i;
								}
							}
						}
					}
					return UA;  // Success
				}
			}
			return undefined;  // Error - one or both of the first two parameters were not arrays
		},

		// getArrayReverseSortedByOtherArray: Returns UnsortedArray reverse sorted based on ArrayToSortBy and subsorted by UnsortedArray value.  This is a case insensitive sort.
		//                                    If RemoveDuplicates is true, it also removes any elements where its pair is duplicated in both arrays.
		getArrayReverseSortedByOtherArray : function (UnsortedArray, ArrayToSortBy, RemoveDuplicates) {

			function GreaterThan(A, B) {
				if (UInv.isString(A)) {
					A = A.toLowerCase();
				}
				if (UInv.isString(B)) {
					B = B.toLowerCase();
				}
				return A > B;
			}

			function LessThan(A, B) {
				if (UInv.isString(A)) {
					A = A.toLowerCase();
				}
				if (UInv.isString(B)) {
					B = B.toLowerCase();
				}
				return A < B;
			}

			if (UInv.isArray(UnsortedArray) && UInv.isArray(ArrayToSortBy)) {
				if (UnsortedArray.length === ArrayToSortBy.length) {
					var UA = clone(UnsortedArray), ATSB = clone(ArrayToSortBy);
					if (UA.length > 1) {
						var i = 0, j = 0, n = 0, temp, length = ATSB.length, done = true;
						for (i = 0; i < length / 2; i++) {  // improved cocktail shaker sort with subsorting by unsorted array
							done = true;
							for (j = i; j < length - i - 1; j++) {
								if (LessThan(ATSB[j], ATSB[j + 1]) || ((ATSB[j] === ATSB[j + 1]) && GreaterThan(UA[j], UA[j + 1]))) {
									temp = ATSB[j];
									ATSB[j] = ATSB[j + 1];
									ATSB[j + 1] = temp;
									temp = UA[j];
									UA[j] = UA[j + 1];
									UA[j + 1] = temp;
									done = false;
								}
								n = length - j - 1;
								if (LessThan(ATSB[n - 1], ATSB[n]) || ((ATSB[n - 1] === ATSB[n]) && GreaterThan(UA[n - 1], UA[n]))) {
									temp = ATSB[n];
									ATSB[n] = ATSB[n - 1];
									ATSB[n - 1] = temp;
									temp = UA[n];
									UA[n] = UA[n - 1];
									UA[n - 1] = temp;
									done = false;
								}
							}
							if (done) {
								break;
							}
						}
						if (RemoveDuplicates) {
							i = 0;
							while (i < ATSB.length - 1) {
								if ((ATSB[i] === ATSB[i+1]) && (UA[i] === UA[i+1])) {
									ATSB.deleteAt(i);
									UA.deleteAt(i);
								} else {
									++i;
								}
							}
						}
					}
					return UA;  // Success
				}
			}
			return undefined;  // Error - one or both of the first two parameters were not arrays
		},

		// arrayObjectIncludes: Searches an array for generic objects with a property of ObjProperty that == Value.
		//                      Returns true if it finds any matches, false when unable to find any matches, and undefined on error.
		arrayObjectIncludes : function (Arr, ObjProperty, Value) {
			if (UInv.isArray(Arr)) {
				if (Arr.length == 0) {
					return false;  // Success - empty array
				}
				if (UInv.isString(ObjProperty)) {
					if (arguments.length >= 3) {
						var i;
						for (i = 0; i < Arr.length; i++) {
							if (UInv.isGenericObject(Arr[i])) {
								if (UInv.isProperty(Arr[i], ObjProperty)) {
									if (Arr[i][ObjProperty] == Value) {
										return true;  // Success - found match
									}
								}
							}
						}
					} else {
						//UInvError('ObjProperty failed. Value parameter is missing.');  // Error
						return undefined;  // Error
					}
				} else {
					//UInvError('ObjProperty passed to arrayObjectIncludes is not string.');  // Error
					return undefined;  // Error
				}
			} else {
				//UInvError('First parameter passed to arrayObjectIncludes is not an array.');  // Error
				return undefined;  // Error
			}
			return false;  // Success - value not found
		},

		// integerToOrdinal: Converts an integer to an ordinal string (e.g. "first", "20th", etc...).
		//                   Options = "NoOrdinalText", "UseSuperscript", and/or "Capitalize"
		integerToOrdinal : function (Value, Options) {
			if (UInv.isInteger(Value)) {
				if (UInv.isString(Options)) {  // turn string into an array of strings
					Options = [ Options ];
				}
				if (!UInv.isArrayOfStrings(Options)) {  // turn invalid Options parameter values into an empty array
					Options = [];
				}
				var i;
				for (i = 0; i < Options.length; i++) {  // convert any options to lowercase
					Options[i] = Options[i].toLowerCase();
				}
				if ((!Options.includes("noordinaltext")) && (Value < 10) && (Value > 0)) {
					Value = UInv.OrdinalText[Value];  // convert number to ordinal text, (e.g. 2 -> second)
					if (Options.includes("capitalize")) {
						Value = Value.toUpperFirst();
					}
					return Value;
				} else {
					Value = Value.toLocaleString();  // add commas or local variant
					var Ending = Value.substring(Value.length - 2), Suffix;
					if (["11", "12", "13"].includes(Ending)) {  // handle exceptions
						Suffix = "th";
					} else {
						if (Ending.length > 1) {
							Ending = Ending.substring(1);
							Suffix = UInv.OrdinalSuffix[parseInt(Ending)];  // get correct suffix
						}
					}
					if (Options.includes("usesuperscript")) {
						Suffix = "<sup>" + Suffix + "</sup>";  // make suffix superscripted
					}
					return Value + Suffix;  // Success
				}
			}
			return Value;  // Does not change non-integers
		},

		// numberToAPString: Converts a number to a string that conforms to basic AP writing style guidelines.
		//                   For exceptions see: https://writingexplained.org/ap-style/ap-style-numbers
		numberToAPString : function (Value) {
			function TrimEnd(Val) {
				if (Val.slice(-3) == ".00") {
					Val = Val.slice(0, -3);
				} else if (Val.slice(-1) == "0") {
					Val = Val.slice(0, -1);
				}
				return Val;
			}

			if (UInv.isNumber(Value)) {
				if (Number.isInteger(Value) && (Value < 10) && (Value >= 0)) {
					return UInv.NumText[Value];  // convert number to number name
				} else {  // add "just over", "just under", "about", or "approximately"?  ***
					if (Value >= Math.pow(10, 15)) {  // 1 quadrillion
						return TrimEnd((Value / Math.pow(10, 15)).toFixed(2)) + " quadrillion";
					} else if (Value >= Math.pow(10, 12)) {  // 1 trillion
						return TrimEnd((Value / Math.pow(10, 12)).toFixed(2)) + " trillion";
					} else if (Value >= Math.pow(10, 9)) {  // 1 trillion
						return TrimEnd((Value / Math.pow(10, 9)).toFixed(2)) + " billion";
					} else if (Value >= Math.pow(10, 6)) {  // 1 trillion
						return TrimEnd((Value / Math.pow(10, 6)).toFixed(2)) + " million";
					} else {
						Value = (Math.round(Value * 100) / 100);  // Android workaround for not supporting toLocaleString's options parameter
						// return Value.toLocaleString( undefined, { maximumFractionDigits : 2 } );  // add commas or local variant
						return Value.toLocaleString();  // add commas or local variant
					}
				}
			}
			return Value;  // Does not change non-numbers
		},

		// getRandomHexString: Returns a random hexidecimal string of 6 characters.
		getRandomHexString : function () {
			var r = random(0, 255).toString(16), g = random(0, 255).toString(16), b = random(0, 255).toString(16);
			if (r.length === 1) {
				r = "0" + r;
			}
			if (g.length === 1) {
				g = "0" + g;
			}
			if (b.length === 1) {
				b = "0" + b;
			}
			return r + g + b;
		},

		// getObjectProperties: Returns all of the properties and values of an object as a string.  Non-objects get returned unchanged.
		getObjectProperties : function (Obj, Ext) {
			if (Ext === undefined) {
				Ext = "";
			} else {
				Ext += ".";
			}
			var Txt, i;
			if (UInv.isArray(Obj)) {
				Txt = "[ ";
				for (i = 0; i < Obj.length; i++) {
					if (UInv.isObject(Obj[i])) {
						Txt += UInv.getObjectProperties(Obj[i]);
					} else {
						if (UInv.isString(Obj[i])) {
							Txt += '"' + Obj[i] + '"';
						} else {
							Txt += Obj[i];
						}
						if (i < Obj.length - 1) {
							Txt += ", ";
						}
					}
				}
				if (Obj.length > 0) {
					Txt += " ]";
				} else {
					Txt += "]";
				}
				return Txt;
			} else if (UInv.isObject(Obj)) {
				var Keys = Object.keys(Obj).sort();  // Sorted to make the output more consistent across browsers
				Txt = "{ ";
				for (i = 0; i < Keys.length; i++) {
					if (UInv.isObject(Obj[Keys[i]])) {
						Txt += Ext + Keys[i] + " : " + UInv.getObjectProperties(Obj[Keys[i]], Ext + Keys[i]);
					} else {
						if (UInv.isString(Obj[Keys[i]])) {
							Txt += Ext + Keys[i] + ' = "' + Obj[Keys[i]] + '"';
						} else {
							Txt += Ext + Keys[i] + ' = ' + Obj[Keys[i]];
						}
					}
					if (i < Keys.length - 1) {
						Txt += ", ";
					}
				}
				if (Keys.length > 0) {
					Txt += " }";
				} else {
					Txt += "}";
				}
				return Txt;
			} else {
				return Obj;
			}
		},

		// docHasCSSElement: If document has CSS element "CSSElement", returns the element's CSSStyleDeclaration object, otherwise returns "false".
		docHasCSSElement : function (CSSElement) {
			var rules, i, j;
			for (i = 0; i < document.styleSheets.length; i++) {
				try {
					rules = document.styleSheets[i].rules;  // This can throw an error sometimes.
				} catch(e) {
					rules = undefined;  // Error thrown
				}
				if (rules === undefined) {  // If .rules doesn't exist, try .cssRules
					try {
						rules = document.styleSheets[i].cssRules;  // This can throw an error sometimes.
						if (rules === undefined) {
							rules = [];  // Neither worked, so no rules.
						}
					} catch(e) {
						rules = [];  // Error thrown, so no rules.
					}
				}
				for (j = 0; j < rules.length; j++) {
					if (rules[j].selectorText !== undefined) {
						if (typeof rules[j].selectorText == "string") {
							if (rules[j].selectorText == CSSElement) {  // See if CSS selector matches CSSElement string.
								return rules[j].style;  // Success - found matching CSS selector.
							}
						}
					}
				}
			}
			return false;  // Success - no matching CSS selector found.
		},

		// initializeImageCache: Sets up setup.UInvImageCache for image caching.
		initializeImageCache : function () {
			// Set up image cache.
			if (UInv.isUndefined(setup.UInvImageCache)) {
				setup.UInvImageCache = { loading: 0, complete: 0, loaded: 0, errors: 0, waiting: 0, total: 0, maxConcurrent: 5, maxCache: 100, images: [] };
			} else {
				if (UInv.isUndefined(setup.UInvImageCache.loading)) { setup.UInvImageCache.loading = 0; }
				if (UInv.isUndefined(setup.UInvImageCache.complete)) { setup.UInvImageCache.complete = 0; }
				if (UInv.isUndefined(setup.UInvImageCache.loaded)) { setup.UInvImageCache.loaded = 0; }
				if (UInv.isUndefined(setup.UInvImageCache.errors)) { setup.UInvImageCache.errors = 0; }
				if (UInv.isUndefined(setup.UInvImageCache.waiting)) { setup.UInvImageCache.waiting = 0; }
				if (UInv.isUndefined(setup.UInvImageCache.total)) { setup.UInvImageCache.total = 0; }
				if (UInv.isUndefined(setup.UInvImageCache.maxConcurrent)) { setup.UInvImageCache.maxConcurrent = 5; }
				if (UInv.isUndefined(setup.UInvImageCache.maxCache)) { setup.UInvImageCache.maxCache = 100; }
				if (UInv.isUndefined(setup.UInvImageCache.images)) { setup.UInvImageCache.images = []; }
			}
		},

		// continueLoadingCache: Starts loading any waiting images if maxConcurrent images aren't already loading.
		continueLoadingCache : function () {
			UInv.initializeImageCache();
			// Retry loading errors?  Only when everything else is already loaded?  ***
			if (setup.UInvImageCache.waiting > 0) {
				var Waiting = [], j;
				for (j = 0; j < setup.UInvImageCache.images.length; j++) {
					if (setup.UInvImageCache.images[j].status == "Waiting...") {
						Waiting.push(j);
					}
				}
				while (setup.UInvImageCache.loading < setup.UInvImageCache.maxConcurrent) {
					j = Waiting.shift();  // Grab the index of the oldest waiting image
					setup.UInvImageCache.loading++;
					setup.UInvImageCache.waiting--;
					setup.UInvImageCache.images[j].tries++;
					setup.UInvImageCache.images[j].status = "Loading...";
					setup.UInvImageCache.images[j].src = setup.UInvImageCache.images[j].URL;
				}
			}
		},

		// flushCachedImages: Allows you to manually unload previously cached images.
		flushCachedImages : function (Path, ImageName) {
			UInv.initializeImageCache();
			if (UInv.isString(Path)) {
				if (UInv.isString(ImageName)) {
					ImageName = [ImageName];
				}
				if (UInv.isArrayOfStrings(ImageName)) {
					if (UInv.isUndefined(setup.UInvImageCache)) {
						return true;  // Success - No image cache existed
					}
					var i, ndx;
					for (i = 0; i < ImageName.length; i++) {
						ndx = setup.UInvImageCache.map( function (obj) { return obj.URL; } ).indexOf(Path + ImageName[i]);
						if (ndx >=0) {
							setup.UInvImageCache.total--;
							$(setup.UInvImageCache.images[ndx]).off();  // remove event handlers
							setup.UInvImageCache.images[ndx].IgnoreEvents = true;  // this should be redundant due to the .off() above
							if (setup.UInvImageCache.images[ndx].status == "Waiting...") {
								setup.UInvImageCache.waiting--;
							} else if (setup.UInvImageCache[ndx].status == "Loading...") {
								setup.UInvImageCache.loading--;
								setup.UInvImageCache.images[ndx].src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEAAAAALAAAAAABAAEAAAI=;";  // transparent GIF to stop image loading
							} else if (setup.UInvImageCache[ndx].status == "Loaded") {
								setup.UInvImageCache.complete--;
								setup.UInvImageCache.loaded--;
							} else if (setup.UInvImageCache[ndx].status == "Error") {
								setup.UInvImageCache.complete--;
								setup.UInvImageCache.errors--;
							}
							setup.UInvImageCache.deleteAt(ndx);
						}
					}
					UInv.continueLoadingCache();  // trigger loading any waiting images up to maxConcurrent
					return true;  // Success
				} else {
					UInvError('ImageName passed to flushCachedImages is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('Path passed to flushCachedImages is not a string.');  // Error
				return undefined;
			}
		},

		// flushAllCachedImages: Clears out all cached images.  Also lets you set the maximum number of images to cache (defaults to 100) and the
		//                       maximum number of images do download concurrently (defaults to 5).  Returns true on success and undefined on error.
		flushAllCachedImages : function (MaxConcurrent, MaxCache) {
			UInv.initializeImageCache();
			if (UInv.isUndefined(MaxCache)) { MaxCache = UInv.DefaultMaxCache; }
			if (UInv.isUndefined(MaxConcurrent)) { MaxConcurrent = UInv.DefaultMaxConcurrent; }
			if (UInv.isString(MaxCache)) { MaxCache = parseInt(MaxCache); }
			if (UInv.isString(MaxConcurrent)) { MaxConcurrent = parseInt(MaxConcurrent); }
			if (UInv.isInteger(MaxCache)) {
				if (UInv.isInteger(MaxConcurrent)) {
					if (MaxCache < 10) { MaxCache = 10; }
					if (MaxConcurrent < 3) { MaxConcurrent = 3; }
					if (setup.UInvImageCache.images.length > 0) {
						var URLs = [], i;
						for (i = 0; i < setup.UInvImageCache.images.length; i++) {
							URLs.push(setup.UInvImageCache.images[i].URL);
						}
						UInv.flushCachedImages("", URLs);
					}
					setup.UInvImageCache = { loading: 0, complete: 0, loaded: 0, errors: 0, waiting: 0, total: 0, maxConcurrent: MaxConcurrent, maxCache: MaxCache, images: [] };
					return true;  // Success
				} else {
					UInvError('MaxConcurrent passed to flushAllCachedImages is not an integer.');  // Error
					return undefined;
				}
			} else {
				UInvError('MaxCache passed to flushAllCachedImages is not an integer.');  // Error
				return undefined;
			}
		},

		// getCachedImageObject: Returns a copy of the cached image object.  This way you can access properties like .naturalWidth and .naturalHeight on it.
		//                       Returns "null" if image not in cache, or undefined on error.
		getCachedImageObject : function (Path, ImageName) {
			UInv.initializeImageCache();
			if (UInv.isString(Path)) {
				if (UInv.isString(ImageName)) {
					var ndx = setup.UInvImageCache.images.map( function (obj) { return obj.URL; } ).indexOf(Path + ImageName);
					if (ndx >= 0) {
						return setup.UInvImageCache.images[ndx];  // Success
					} else {
						return null;  // Success - Image not found in cache
					}
				} else {
					UInvError('ImageName passed to getCachedImageObject is not a string.');  // Error
					return undefined;
				}
			} else {
				UInvError('Path passed to getCachedImageObject is not a string.');  // Error
				return undefined;
			}
		},

		// cacheImages: Allows you to preload images.  You can use the handler to receive notifications about load or error events.
		//             NOTE: The cache gets flushed whenever the game is reloaded or restarted.  Do NOT depend on files to exist in the cache.
		cacheImages : function (Path, ImageName, Handler) {

			function Loaded(event) {  // eslint-disable-line
				if (!this.IgnoreEvents) {
					this.status = "Loaded";
					setup.UInvImageCache.loading--;
					setup.UInvImageCache.complete++;
					setup.UInvImageCache.loaded++;
					event.URL = this.URL;
					event.path = this.path;
					event.filename = this.filename;
					event.tries = this.tries;
					event.src = this.src;
					if (UInv.isProperty(this, "imageGroup")) {
						event.imageGroup = this.imageGroup;
					}
					UInv.CallEventHandler("cacheImages", "Loaded", this);  // cacheImages Loaded event
					UInv.continueLoadingCache();  // trigger loading any waiting images up to maxConcurrent
				}
			}
			function Failure(event) {  // eslint-disable-line
				if (!this.IgnoreEvents) {
					this.status = "Error";
					setup.UInvImageCache.loading--;
					setup.UInvImageCache.complete++;
					setup.UInvImageCache.errors++;
					event.URL = this.URL;
					event.path = this.path;
					event.filename = this.filename;
					event.tries = this.tries;
					event.src = this.src;
					if (UInv.isProperty(this, "imageGroup")) {
						event.imageGroup = this.imageGroup;
					}
					var Ret = UInv.CallEventHandler("cacheImages", "Error", this);  // cacheImages Error event
					if (Ret.retryLoad !== true) {
						// Error images are moved towards the start of the image cache so they get flushed first.
						var x = setup.UInvImageCache.images.map( function (obj) { return obj.URL; } ).indexOf(this.URL);
						var img = setup.UInvImageCache.images.deleteAt(x)[0], n = 0;
						while ((n < setup.UInvImageCache.images.length) && (setup.UInvImageCache.images[n].status != "Error")) {
							n++;
						}
						setup.UInvImageCache.images.splice(setup.UInvImageCache.errors - 1, 0, img);
					} else {  // Retry loading this image
						setup.UInvImageCache.loading++;
						setup.UInvImageCache.complete--;
						setup.UInvImageCache.errors--;
						this.status = "Waiting...";
					}
					UInv.continueLoadingCache();  // trigger loading any waiting images up to maxConcurrent
				}
			}

			UInv.initializeImageCache();
			if (UInv.isString(Path)) {
				if (UInv.isString(ImageName)) {
					ImageName = [ImageName];
				}
				if (UInv.isArrayOfStrings(ImageName)) {
					if (UInv.isUndefined(setup.UInvImageCache)) {
						setup.UInvImageCache = { loading: 0, complete: 0, loaded: 0, errors: 0, waiting: 0, total: 0, maxConcurrent: UInv.DefaultMaxConcurrent, maxCache: UInv.DefaultMaxCache, images: [] };
					}
					var i = 0, j, done = false, image, ndx, uniqueID = "", HandlerIDs;
					if (UInv.isString(Handler) && (ImageName.length > 0)) {  // create imageGroup for event handlers
						uniqueID = "iGrp" + (++i);
						while (!done) {  // look for existing matching handlers
							HandlerIDs = UInv.GetMatchingEventHandlersArray("cacheImages", "Loaded", { imageGroup: uniqueID });
							if (HandlerIDs.length > 0) {
								for (j = 0; j < HandlerIDs.length; ++j) {
									//if (any HandlerIDs have a handler that == Handler) then use current uniqueID, otherwise uniqueID = "iGrp" + (++i); and try again
									if (UInv.GetEventHandlerByID("cacheImages", "Loaded", HandlerIDs[j]).handler == Handler) {
										done = true;
										break;  // Break out of for loop
									}
								}
								if (!done) {  // try again
									uniqueID = "iGrp" + (++i);
								}
							} else {  // uniqueID is unique currently, so keep it
								done = true;
							}
						}
						UInv.AddEventHandler("cacheImages", "Loaded", Handler, { imageGroup: uniqueID });
						UInv.AddEventHandler("cacheImages", "Error", Handler, { imageGroup: uniqueID });
					}
					for (i = 0; i < ImageName.length; i++) {
						ndx = setup.UInvImageCache.images.map( function (obj) { return obj.URL; } ).indexOf(Path + ImageName[i]);
						if (ndx >= 0) {
							if (["Loaded", "Error"].includes(setup.UInvImageCache.images[ndx].status)) {
								// shift image at ndx to the front of the "loaded" line (if there is one) so it doesn't get flushed for being old
								image = setup.UInvImageCache.images.deleteAt(ndx)[0];
								setup.UInvImageCache.images.splice(setup.UInvImageCache.total - setup.UInvImageCache.complete, 0, image);
								if (setup.UInvImageCache.images[ndx].status == "Error") {
									// retry loading failed image
									setup.UInvImageCache.images[ndx].status = "Loading...";
									setup.UInvImageCache.errors--;
									setup.UInvImageCache.complete--;
									setup.UInvImageCache.loading++;
									setup.UInvImageCache.images[ndx].IgnoreEvents = true;
									if (uniqueID !== "") {
										setup.UInvImageCache.images[ndx].imageGroup = uniqueID;
									}
									setup.UInvImageCache.images[ndx].src = "";
									delete setup.UInvImageCache.images[ndx].IgnoreEvents;
									setup.UInvImageCache.images[ndx].src = setup.UInvImageCache.URL;
								}
							}  // don't move "Waiting..." or "Loading..." images, they should already be at the "young" end of the line.
						} else {
							image = new Image();
							image.path = Path;
							image.filename = ImageName[i];
							image.URL = Path + ImageName[i];
							image.tries = 0;
							if (uniqueID !== "") {
								image.imageGroup = uniqueID;
							}
							setup.UInvImageCache.total++;
							$(image)
								.on("load loadstart onprogress progress loadend", Loaded)  // only "load" does something
								.on("error abort", Failure);
							if (setup.UInvImageCache.maxConcurrent > setup.UInvImageCache.loading) {  // load image
								setup.UInvImageCache.loading++;
								image.status = "Loading...";
								image.src = Path + ImageName[i];
								setup.UInvImageCache.images.push(image);
							} else {  // add image to queue
								setup.UInvImageCache.waiting++;
								image.status = "Waiting...";
								setup.UInvImageCache.images.push(image);
							}
						}
					}
					if (setup.UInvImageCache.images.length > setup.UInvImageCache.maxCache) {  // Flush oldest images if cache is "full"
						var OldURLs = setup.UInvImageCache.images.slice(0, setup.UInvImageCache.images.length - setup.UInvImageCache.maxCache).map( function (obj) { return obj.URL; } );
						UInv.flushCachedImages("", OldURLs);
					}
					return true;  // Success
				} else {
					UInvError('ImageName passed to cacheImages is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('Path passed to cacheImages is not a string.');  // Error
				return undefined;
			}
		},

		// Engine detection code:
		// Opera v8.0+
		isOpera : function () { return (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0; },
		// Firefox v1.0+
		isFirefox : function () { return typeof InstallTrigger !== "undefined"; },
		// Safari v3.0+ "[object HTMLElementConstructor]"
		isSafari : function () { return /constructor/i.test(window.HTMLElement) || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window.safari || (typeof safari !== "undefined" && safari.pushNotification)); },
		// Internet Explorer v6-11
		isIE : function () { return /*@cc_on!@*/false || !!document.documentMode; },
		// Edge v20+
		isEdge : function () { return !UInv.isIE() && !!window.StyleMedia; },
		// Chrome v1+
		isChrome : function () { return !!window.chrome && !!window.chrome.webstore; },
		// Blink engine detection
		isBlink : function () { return (UInv.isChrome() || UInv.isOpera()) && !!window.CSS; },
		// Android engine detection
		isAndroid : function () { return Browser.isMobile.Android; },
		// iOS engine detection
		isiOS : function () { return Browser.isMobile.iOS; },
		// BlackBerry engine detection
		isBlackBerry : function () { return Browser.isMobile.BlackBerry; },
		// Mobile engine detection
		isMobile : function () { return ( UInv.isAndroid() || UInv.isiOS() || UInv.isBlackBerry() || Browser.isMobile.Windows ); },
		// Twine engine detection
		isTwine : function () { return window.hasOwnProperty("storyFormat"); },


		// UInv Bag Functions:
		// ===================

		// GetDefaultBagObject: Returns the Bag object that matches BagType.  If PropertiesOnly is true, then returns default bag properties only.
		//                      Returns "null" for unknown bag types, or undefined on error.  Both "undefined" and "null" have "falsey" values.
		GetDefaultBagObject : function (BagType, PropertiesOnly) {
			if (UInv.isString(BagType)) {
				if ((BagType === "") || (BagType === "-")) {
					// Do not throw an error here.  This case is used to trigger an "undefined" return if the BagType === "" or "-".
					return null;  // Silent failure
				}
				var BName = BagType.toLowerCase(), BagProperties = UInv.BagData(BName, true);
				if (PropertiesOnly) {
					return BagProperties;  // Success
				}
				var BagItems = UInv.BagData(BName, false), Bag = {}, Item = {}, Key = "", i = 0;
				if (UInv.isUndefined(BagProperties) || UInv.isUndefined(BagItems)) {
					return null;  // Silent failure
				}
				if (Object.keys(BagProperties).length > 0) {
					Bag = { UInvProperties : BagProperties };
				}
				if (BagItems.length > 0) {
					var ItemName;
					for (i = 0; i < BagItems.length; i++) {
						if (UInv.isString(BagItems[i])) {  // Handle "String Method"
							ItemName = ValidateItemName(BagItems[i]);  // Make sure that the item name on the default bag object is valid
							if (!UInv.isUndefined(ItemName)) {
								Item = UInv.GetDefaultItemObject(ItemName);  // OOO function call
								if (Item) {
									Bag[ItemName] = Item;
								} else {
									UInvError('GetDefaultBagObject failed. Unknown item "' + ItemName + '" on bag of type "' + BagType + '".');  // Error
									return undefined;
								}
							} else {
								UInvError('GetDefaultBagObject failed. Invalid item name "' + BagItems[i] + '" on bag of type "' + BagType + '".');  // Error
								return undefined;
							}
						} else if (UInv.isGenericObject(BagItems[i])) {  // Handle "Quantity Method", "Type Method", and "Creation Method"
							Key = Object.keys(BagItems[i])[0];
							ItemName = ValidateItemName(Key);  // Make sure that the item name on the default bag object is valid
							if (!UInv.isUndefined(ItemName)) {
								Item = UInv.GetDefaultItemObject(ItemName);  // OOO function call
								if (!Item && !UInv.isGenericObject(BagItems[i][ItemName])) {
									UInvError('GetDefaultBagObject failed. Unknown item type "' + ItemName + '" on bag type "' + BagType + '"..');  // Error
									return undefined;
								} 
								if (Item && UInv.isInteger(BagItems[i][ItemName])) {  // Handle "Quantity Method"
									if (BagItems[i][ItemName] > 1) {
										Item.UInvQuantity = BagItems[i][ItemName];
									}
									Bag[ItemName] = Item;
								} else if (UInv.isGenericObject(BagItems[i][ItemName])) {  // Handle "Type Method" and "Creation Method"
									var ItemType = ItemName;
									if (UInv.isProperty(BagItems[i][ItemName], "UInvDefaultItemType")) {
										ItemType = BagItems[i][ItemName].UInvDefaultItemType;
									} else if (!Item) {
										ItemType = "-";
									}
									if (ItemType == "-") {  // Handle "Creation Method"
										Bag[ItemName] = BagItems[i][ItemName];
									} else {  // Handle "Type Method" and "Type+Creation Method"
										Bag[ItemName] = UInv.combineGenericObjects(UInv.GetDefaultItemObject(ItemType), BagItems[i][ItemName]);
									}
								} else {
									UInvError('GetDefaultBagObject failed. Value of item name "' + Key + '" on bag type "' + BagType + '" must be a "string" or "generic object".');  // Error
									return undefined;
								}
							} else {
								UInvError('GetDefaultBagObject failed. Invalid item name "' + Key + '" on bag of type "' + BagType + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('GetDefaultBagObject failed. Unexpected type "' + (typeof BagItems[i]) + '" for item on bag type "' + BagType + '".  Should be "string" or "generic object".');  // Error
							return undefined;
						}
					}
				}
				return Bag;  // Success
			} else {
				UInvError('BagType passed to GetDefaultBagObject is not a string.');  // Error
				return undefined;
			}
		},

		// GetCurrentBagName: Gets the current bag name if there is one, otherwise returns "".
		GetCurrentBagName : function () {
			if (UInv.isProperty(State.variables, "UInvCurrentBagName")) {
				return State.variables.UInvCurrentBagName;
			} else {
				return "";
			}
		},

		// GetBagsArray: Returns an array of all bag names.
		GetBagsArray : function () {
			return Object.keys(State.variables.UInvBags);  // Success
		},

		// GetBagCount: Returns the number of bags.
		GetBagCount : function () {
			return UInv.GetBagsArray().length;  // Success
		},

		// BagExists: Returns true if bag exists/all bags in array exist, otherwise returns false, or undefined on error.
		BagExists : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.isProperty(State.variables.UInvBags, BagName)) {
					State.variables.UInvCurrentBagName = BagName;  // set $UInvCurrentBagName
					return true;  // Success
				} else {
					return false;  // Success
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				var i = 0;
				for (i = 0; i < BagName.length; i++) {
					if (!UInv.BagExists(BagName[i])) {
						return false;  // Success - bag missing
					}
				}
				return true;  // Success - found all bags
			} else {
				UInvError('Name passed to BagExists is not a string or array of strings.');  // Error
				return undefined;
			}
		},

		// SetCurrentBagName: Sets the UInvCurrentBagName to BagName for use as the default BagName parameter in UInv functions.  Returns true on success or undefined on error.
		SetCurrentBagName : function (BagName) {
			if (UInv.isString(BagName)) {
				if (BagName === "") {
					if (UInv.isProperty(State.variables, "UInvCurrentBagName")) {
						delete State.variables.UInvCurrentBagName;
					}
				} else {
					if (!UInv.BagExists(BagName)) {  // $UInvCurrentBagName gets set here
						UInvError('SetCurrentBagName cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				}
				return true;  // Success
			} else {
				UInvError('Name passed to SetCurrentBagName is not a string.');  // Error
				return undefined;
			}
		},

		// SetBagUntouched: Sets bag(s) to untouched and returns true, or false if there is an error.
		SetBagUntouched : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					State.variables.UInvBags[BagName].UInvTouched = false;
					return true;  // Success
				} else {
					UInvError('SetBagUntouched cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.BagExists(BagName)) {
					var i;
					for (i = 0; i < BagName.length; i++) {
						State.variables.UInvBags[BagName].UInvTouched = false;
					}
					return true;  // Success
				} else {
					UInvError('SetBagUntouched failed. Invalid bag name in array.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to SetBagUntouched is not a string or array of strings.');  // Error
				return undefined;
			}
		},

		// CreateBag: Creates a bag named BagName if that bag doesn't exist already.  Returns true if it succeeded.
		CreateBag : function (BagName) {
			if (UInv.isString(BagName)) {
				if (["", "-"].includes(BagName)) {
					UInvError('CreateBag failed. Invalid bag name "' + BagName + '".');  // Error
					return undefined;
				}
				if (UInv.BagExists(BagName)) {
					UInvError('CreateBag cannot create bag "' + BagName + '". Bag already exists with that name.');  // Error
					return undefined;
				} else {
					State.variables.UInvBags[BagName] = {};
					if (UInv.GetDefaultBagObject(BagName, true)) {
						State.variables.UInvBags[BagName].UInvDefaultBagType = "-";
					}
					UInv.SetBagUntouched(BagName);
					UInv.SetCurrentBagName(BagName);
					return true;  // Success
				}
			} else {
				UInvError('BagName passed to CreateBag is not a string.');  // Error
				return undefined;
			}
		},

		// SetBagTouched: Sets bag(s) to touched and returns true, or false if there is an error.
		SetBagTouched : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var ev = {};
					ev.bagName = BagName;
					ev.lockCount = UInv.GetUpdateLocks();
					var Ret = UInv.CallEventHandler("bag", "Touched", ev);  // bag Touched event
					if (Ret.ignoreTouch !== true) {
						if (UInv.isProperty(State.variables.UInvBags[BagName], "UInvTouched")) {
							delete State.variables.UInvBags[BagName].UInvTouched;
						}
					}
					if (!UInv.UpdatesAreLocked()) {
						UInv.UpdateDisplay();
					}
					return true;  // Success
				} else {
					UInvError('SetBagTouched cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.BagExists(BagName)) {
					var i;
					UInv.IncrementUpdateLock();
					for (i = 0; i < BagName.length; i++) {
						UInv.SetBagTouched(BagName[i]);
					}
					UInv.DecrementUpdateLock();
					return true;  // Success
				} else {
					UInvError('SetBagTouched failed. Invalid bag name in array.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to SetBagTouched is not a string or array of strings.');  // Error
				return undefined;
			}
		},

		// EmptyBag: Deletes all items from bag.  Returns true if successful or undefined on error.
		EmptyBag : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName);  // OOO function call
					if (Items.length > 0) {
						var i = 0;
						UInv.IncrementUpdateLock();  // Prevent unnecessary updates.
						for (i = 0; i < Items.length; i++) {
							UInv.DeleteItem(BagName, Items[i]);  // OOO function call
						}
						UInv.SetBagTouched(BagName);
						UInv.DecrementUpdateLock();
					}
					UInv.SetCurrentBagName(BagName);
					return true;  // Success
				} else {
					UInvError('EmptyBag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to EmptyBag is not a string.');  // Error
				return undefined;
			}
		},

		// AddBag: Creates a bag named BagName if that bag doesn't exist already.  Returns true if it succeeded.
		//         Items will not be added if the current pocket depth >= the starting pocket depth + UInv.MaximumPocketDepth.
		AddBag : function (BagName, DefaultBagType, StartDepth, CurrentDepth) {
			if (UInv.isString(BagName)) {
				if ((BagName != "") && (BagName != "-")) {
					if (UInv.isUndefined(DefaultBagType) || UInv.isString(DefaultBagType)) {
						if (UInv.BagExists(BagName)) {
							UInvError('AddBag cannot create bag "' + BagName + '". Bag already exists.');  // Error
							return undefined;
						} else {
							var Bag = {}, Tmp, TooDeep = false;
							if (UInv.isUndefined(StartDepth)) {
								StartDepth = 0;
								CurrentDepth = 0;
							} else if (CurrentDepth - StartDepth >= UInv.MaximumPocketDepth) {
								TooDeep = true;  // This causes GetDefaultBagObject to only return the bag's properties, and not any items in it, to prevent infinite loops and exponential explosions
							}
							if (UInv.isUndefined(DefaultBagType)) {
								DefaultBagType = BagName;
							}
							Tmp = UInv.GetDefaultBagObject(DefaultBagType, TooDeep);
							if (!Tmp) {
								UInvError('AddBag failed. Unknown bag type "' + DefaultBagType + '".');  // Error
								return undefined;
							}
							if (TooDeep) {
								Bag.UInvProperties = Tmp;  // Don't add items because the pocket is too many levels deep; prevents infinite loops
							} else {
								Bag = Tmp;
							}
							if (DefaultBagType != BagName) {
								Bag.UInvDefaultBagType = DefaultBagType;
							}
							if (UInv.isProperty(Bag, "UInvProperties")) {
								if (UInv.isProperty(Bag.UInvProperties, "UInvVariableType")) {
									Bag.UInvDefaultBagType = DefaultBagType;  // bag is of a variable type, so its properties have to be kept as-is
								} else {
									delete Bag.UInvProperties;  // clear default properties
								}
							}
							State.variables.UInvBags[BagName] = Bag;
							var Items = UInv.GetItemsArray(BagName);  // OOO function call
							UInv.IncrementUpdateLock();
							if (Items.length > 0) {
								var Quantities = UInv.GetItemsAndQuantitiesObject(BagName), i, ItemType, ItemProperties;  // OOO function call
								for (i = 0; i < Items.length; i++) {
									ItemType = UInv.GetItemsDefaultType(BagName, Items[i]);  // OOO function call
									if (ItemType !== "-") {  // add item properly
										ItemProperties = clone(State.variables.UInvBags[BagName][Items[i]]);
										if (UInv.isProperty(ItemProperties, "UInvPocket")) {
											delete ItemProperties.UInvPocket;
										}
										RemoveItemObjectsDefaultProperties(ItemProperties, ItemType);  // store non-default properties
										delete State.variables.UInvBags[BagName][Items[i]];
										UInv.AddItem(BagName, ItemType, Quantities[Items[i]], Items[i], StartDepth, CurrentDepth);  // OOO function call
										UInv.SetItemPropertyValues(BagName, Items[i], ItemProperties);  // restore non-default properties  // OOO function call
									}
								}
							}
							UInv.SetBagUntouched(BagName);
							UInv.SetCurrentBagName(BagName);
							UInv.DecrementUpdateLock();
							return true;  // Success
						}
					} else {
						UInvError('DefaultBagType passed to AddBag is not a string.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName passed to AddBag cannot be "-" or "".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to AddBag is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagsDefaultType: Returns bag's default bag type if it has one, "-" if it doesn't, or undefined on error.
		GetBagsDefaultType : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.isProperty(State.variables.UInvBags[BagName], "UInvDefaultBagType")) {
						return State.variables.UInvBags[BagName].UInvDefaultBagType;
					} else {
						if (UInv.GetDefaultBagObject(BagName, true)) {
							return BagName;
						} else {
							return "-";
						}
					}
				} else {
					UInvError('GetBagsDefaultType failed. Cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetBagsDefaultType is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagCountByDefaultType: Returns the number of unique bag types, bags with no default bag type count as unique bag types.
		GetBagCountByDefaultType : function () {
			var Tot = 0, Typ, TypLst = [], i;
			var Bags = UInv.GetBagsArray();
			if (Bags.length > 0) {
				for (i = 0; i < Bags.length; i++) {
					Typ = UInv.GetBagsDefaultType(Bags[i]);
					if (Typ === "-") {
						++Tot;
					} else if (TypLst.indexOf(Typ) < 0) {
						TypLst.push(Typ);
						++Tot;
					}
				}
			}
			return Tot;
		},

		// CopyAllItemsToBag: Copies all items from source to destination.
		CopyAllItemsToBag : function (SourceBagName, DestinationBagName) {
			if (UInv.isString(SourceBagName) && UInv.isString(DestinationBagName)) {
				SourceBagName = FixBagName(SourceBagName);
				DestinationBagName = FixBagName(DestinationBagName);
				if (SourceBagName !== DestinationBagName) {
					if (UInv.BagExists(SourceBagName)) {
						if (UInv.BagExists(DestinationBagName)) {
							var i = 0, Ret, Result = [];
							var Items = UInv.GetItemsArray(SourceBagName);  // OOO function call
							if (Items.length > 0) {
								for (i = 0; i < Items.length; i++) {
									Ret = UInv.CopyItem(SourceBagName, DestinationBagName, Items[i]);  // OOO function call
									if (Ret === undefined) {
										Result = undefined;
									} else if (!UInv.isBoolean(Result)) {
										Result.push(Ret);
									}
								}
								UInv.SetBagTouched(DestinationBagName);
							}
							UInv.SetCurrentBagName(DestinationBagName);
							return Result;  // Success or Error  ***
						} else {
							UInvError('CopyAllItemsToBag cannot find bag "' + DestinationBagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('CopyAllItemsToBag cannot find bag "' + SourceBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('CopyAllItemsToBag failed. SourceBagName and DestinationBagName cannot be the same. Value = "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to CopyAllItemsToBag is not a string.');  // Error
				return undefined;
			}
		},

		// CopyBag: Creates a new bag named NewBagName if that bag doesn't exist already, and copies ExistingBagName into it.
		//          If the existing bag is a pocket, the copy won't be.  Returns true if it succeeded, or undefined on error.
		CopyBag : function (ExistingBagName, NewBagName) {
			if (UInv.isString(ExistingBagName) && UInv.isString(NewBagName)) {
				ExistingBagName = FixBagName(ExistingBagName);
				NewBagName = FixBagName(NewBagName);
				if (UInv.BagExists(ExistingBagName)) {
					if (!UInv.BagExists(NewBagName)) {
						State.variables.UInvBags[NewBagName] = clone(State.variables.UInvBags[ExistingBagName]);
						if (UInv.isProperty(State.variables.UInvBags[NewBagName], "UInvContainer")) {  // Bag copies should not be pockets.
							delete State.variables.UInvBags[NewBagName].UInvContainer;
						}
						var Type = UInv.GetBagsDefaultType(ExistingBagName);
						if (Type !== NewBagName) {
							State.variables.UInvBags[NewBagName].UInvDefaultBagType = Type;
						} else {
							delete State.variables.UInvBags[NewBagName].UInvDefaultBagType;
						}
						var Items = UInv.GetItemsArray(NewBagName);  // OOO function call
						if (Items.length > 0) {
							var i = 0;
							UInv.IncrementUpdateLock();  // Prevent unnecessary updates.
							for (i = 0; i < Items.length; i++) {
								delete State.variables.UInvBags[NewBagName][Items[i]];
							}
							UInv.CopyAllItemsToBag(ExistingBagName, NewBagName);
							UInv.DecrementUpdateLock();
						}
						UInv.SetBagUntouched(NewBagName);
						return true;  // Success
					} else {
						UInvError('CopyBag failed. Bag "' + NewBagName + '" already exists.');  // Error
						return undefined;
					}
				} else {
					UInvError('CopyBag failed. Cannot find bag "' + ExistingBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to CopyBag is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagPropertyArray: Return an array of all bag's property names.  Returns undefined on error.
		GetBagPropertyArray : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Type = UInv.GetBagsDefaultType(BagName);
					var Props = UInv.GetDefaultBagObject(Type, true);
					UInv.SetCurrentBagName(BagName);
					if (UInv.isProperty(State.variables.UInvBags[BagName], "UInvProperties")) {
						if ((Type === "-") || UInv.isProperty(State.variables.UInvBags[BagName].UInvProperties, "UInvVariableType")) {
							return Object.keys(State.variables.UInvBags[BagName].UInvProperties);  // Success
						} else {
							return Object.keys(State.variables.UInvBags[BagName].UInvProperties).concatUnique(Object.keys(Props));  // Success
						}
					} else if (Type === "-") {
						return [];  // Success
					} else {
						return Object.keys(Props);  // Success
					}
				} else {
					UInvError('GetBagPropertyArray cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetBagPropertyArray is not a string.');  // Error
				return undefined;
			}
		},

		// DeleteBag: Deletes bag entirely.  Return true if successful.
		DeleteBag : function (BagName) {
			var i;
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.EmptyBag(BagName);
					if (UInv.BagIsPocket(BagName)) {  // OOO function call
						var ContainerBagName, ContainerName, PocketName;
						while (UInv.BagIsPocket(BagName)) {  // Remove pocket from container(s)
							ContainerBagName = State.variables.UInvBags[BagName].UInvContainer[0].ContainerBagName;
							ContainerName = State.variables.UInvBags[BagName].UInvContainer[0].ContainerName;
							PocketName = State.variables.UInvBags[BagName].UInvContainer[0].PocketName;
							UInv.UnlinkPocketFromContainer(ContainerBagName, ContainerName, PocketName);  // OOO function
						}
					}
					if (UInv.isProperty(State.variables.UInvBags[BagName], "UInvProperties")) {
						var Props = Object.keys(State.variables.UInvBags[BagName].UInvProperties);
						if (Props.length > 0) {
							for (i = 0; i < Props.length; i++) {
								delete State.variables.UInvBags[BagName].UInvProperties[Props[i]];
							}
						}
						delete State.variables.UInvBags[BagName].UInvProperties;
					}
					if (UInv.isProperty(State.variables.UInvBags[BagName], "UInvTouched")) {
						delete State.variables.UInvBags[BagName].UInvTouched;
					}
					if (UInv.isProperty(State.variables.UInvBags[BagName], "UInvDefaultBagType")) {
						delete State.variables.UInvBags[BagName].UInvDefaultBagType;
					}
					delete State.variables.UInvBags[BagName];
					return true;  // Success
				} else {
					UInvError('DeleteBag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				BagName = UInv.getUniqueArray(BagName);
				if (UInv.BagExists(BagName)) {
					for (i = 0; i < BagName.length; i++) {
						UInv.DeleteBag(BagName[i]);
					}
					return true;  // Success
				} else {
					UInvError('Some bags passed to DeleteBag did not exist.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to DeleteBag is not a string.');  // Error
				return undefined;
			}
		},

		// RenameBag: Renames CurrentBagName to NewBagName if that bag doesn't exist already.  Returns true if it succeeded.
		RenameBag : function (CurrentBagName, NewBagName) {
			if (UInv.isString(CurrentBagName) && UInv.isString(NewBagName)) {
				CurrentBagName = FixBagName(CurrentBagName);
				NewBagName = FixBagName(NewBagName);
				if (UInv.BagExists(CurrentBagName)) {
					if (!UInv.BagExists(NewBagName)) {
						var i;
						if (UInv.BagIsPocket(CurrentBagName)) {  // Rename pocket in container(s) too  // OOO function call
							var ContainerBagName, ContainerName, PocketName;
							for (i = 0; i < State.variables.UInvBags[CurrentBagName].UInvContainer.length; i++) {
								ContainerBagName = State.variables.UInvBags[CurrentBagName].UInvContainer[i].ContainerBagName;
								ContainerName = State.variables.UInvBags[CurrentBagName].UInvContainer[i].ContainerName;
								PocketName = State.variables.UInvBags[CurrentBagName].UInvContainer[i].PocketName;
								State.variables.UInvBags[ContainerBagName][ContainerName].UInvPocket[PocketName] = NewBagName;
							}
						}
						State.variables.UInvBags[NewBagName] = State.variables.UInvBags[CurrentBagName];
						var Items = UInv.GetItemsArray(NewBagName), Pockets, j;  // OOO function call
						if (Items.length > 0) {
							for (i = 0; i < Items.length; i++) {  // Update pocket references on any containers
								if (UInv.ItemHasPocket(NewBagName, Items[i])) {  // OOO function call
									Pockets = UInv.GetItemPocketNameArray(CurrentBagName, Items[i]);  // OOO function call
									for (j = 0; j < Pockets.length; j++) {
										UInv.MovePocket(CurrentBagName, Items[i], Pockets[j], NewBagName, Items[i]);  // OOO function call
									}
								}
							}
						}
						var Type = UInv.GetBagsDefaultType(CurrentBagName);
						if (Type !== NewBagName) {
							State.variables.UInvBags[NewBagName].UInvDefaultBagType = Type;
						} else {
							delete State.variables.UInvBags[NewBagName].UInvDefaultBagType;
						}
						delete State.variables.UInvBags[CurrentBagName];
						return true;  // Success
					} else {
						UInvError('RenameBag failed. Bag "' + NewBagName + '" already exists.');  // Error
						return undefined;
					}
				} else {
					UInvError('RenameBag failed. Cannot find bag "' + CurrentBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to RenameBag is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasProperty: Returns true if bag's property exists, otherwise returns false.
		BagHasProperty : function (BagName, BagPropertyName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.isString(BagPropertyName)) {
						UInv.SetCurrentBagName(BagName);
						if (UInv.GetBagPropertyArray(BagName).includes(BagPropertyName)) {
							return true;  // Success
						} else {
							return false;  // Success
						}
					} else if (UInv.isArrayOfStrings(BagPropertyName)) {
						var i = 0, Props = UInv.GetBagPropertyArray(BagName);
						for (i = 0; i < BagPropertyName.length; i++) {
							if (!Props.includes(BagPropertyName[i])) {
								return false;  // Success
							}
						}
						return true;  // Success
					} else {
						UInvError('BagPropertyName passed to BagHasProperty is not a string or array of strings.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagHasProperty cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to BagHasProperty is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagPropertyValue: Return a bag's property value.  Returns undefined on error.
		GetBagPropertyValue : function (BagName, BagPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(BagPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasProperty(BagName, BagPropertyName)) {
						UInv.SetCurrentBagName(BagName);
						if (UInv.isProperty(State.variables.UInvBags[BagName], "UInvProperties")) {
							if (UInv.isProperty(State.variables.UInvBags[BagName].UInvProperties, BagPropertyName)) {
								return State.variables.UInvBags[BagName].UInvProperties[BagPropertyName];  // Success
							}
						}
						return UInv.GetDefaultBagObject(UInv.GetBagsDefaultType(BagName), true)[BagPropertyName];  // Success
					} else {
						UInvError('GetBagPropertyValue cannot find bag property "' + BagPropertyName + '" on bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetBagPropertyValue cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetBagPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// SetBagPropertyValue: Add or change a bag property and set it to Value.  Returns true if it succeeds, or undefined on error.
		SetBagPropertyValue : function (BagName, BagPropertyName, Value) {
			if (UInv.isString(BagPropertyName)) {
				if (arguments.length >= 3) {
					if (UInv.isString(BagName)) {
						BagName = FixBagName(BagName);
						if (UInv.BagExists(BagName)) {
							var BagType = UInv.GetBagsDefaultType(BagName), Props = [];
							if (BagPropertyName === "UInvVariableType") {
								if (!UInv.isProperty(State.variables.UInvBags[BagName], "UInvProperties")) {
									State.variables.UInvBags[BagName].UInvProperties = {};
								}
								if (UInv.isProperty(State.variables.UInvBags[BagName].UInvProperties, "UInvVariableType") || (BagType === "-")) {
									State.variables.UInvBags[BagName].UInvProperties.UInvVariableType = Value;
								} else {  // set bag's default properties
									State.variables.UInvBags[BagName].UInvProperties = Object.assign({}, UInv.GetDefaultBagObject(BagType, true), State.variables.UInvBags[BagName].UInvProperties);
									State.variables.UInvBags[BagName].UInvProperties.UInvVariableType = Value;
									if (BagType != BagName) {
										State.variables.UInvBags[BagName].UInvDefaultBagType = BagType;
									}
								}
							} else {
								if (!UInv.isProperty(State.variables.UInvBags[BagName], "UInvProperties")) {
									State.variables.UInvBags[BagName].UInvProperties = {};
								}
								State.variables.UInvBags[BagName].UInvProperties[BagPropertyName] = Value;
								if (BagType !== "-") {
									Props = UInv.GetDefaultBagObject(BagType, true);
									if (UInv.isProperty(Props, BagPropertyName) && !UInv.isProperty(Props, "UInvVariableType")) {
										if (Props[BagPropertyName] === State.variables.UInvBags[BagName].UInvProperties[BagPropertyName]) {
											delete State.variables.UInvBags[BagName].UInvProperties[BagPropertyName];
											if (Object.keys(State.variables.UInvBags[BagName].UInvProperties).length === 0) {
												delete State.variables.UInvBags[BagName].UInvProperties;
											}
										}
									}
								}
							}
							UInv.SetCurrentBagName(BagName);
							return true;  // Success
						} else {
							UInvError('SetBagPropertyValue cannot find bag "' + BagName + '".');  // Error
							return undefined;
						}
					} else if (UInv.isArrayOfStrings(BagName)) {
						if ((BagPropertyName !== "UInvVariableType") || UInv.isString(Value)) {
							if (UInv.BagExists(BagName)) {
								var i = 0, Result = true;
								for (i = 0; i < BagName.length; i++) {
									if (!UInv.SetBagPropertyValue(BagName[i], BagPropertyName, Value)) {
										Result = undefined;
									}
								}
								return Result;  // Success (or Error, shouldn't happen)
							} else {
								UInvError('SetBagPropertyValue failed. Invalid bag name in array.');  // Error
								return undefined;
							}
						} else {
							UInvError('SetBagPropertyValue failed. The UInvVariableType property can only be set to a string.');  // Error
							return undefined;
						}
					} else {
						UInvError('BagName passed to SetBagPropertyValue is not a string or an array of strings.');  // Error
						return undefined;
					}
				} else {
					UInvError('SetBagPropertyValue failed. Value parameter is missing.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to SetBagPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagPropertyObject: Returns object of all properties/values a bag has or undefined on error.
		GetBagPropertyObject : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Props = UInv.GetBagPropertyArray(BagName), Result = {}, i = 0;
					for (i = 0; i < Props.length; i++) {
						Result[Props[i]] = UInv.GetBagPropertyValue(BagName, Props[i]);
					}
					return Result;  // Success
				} else {
					UInvError('GetBagPropertyObject cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetBagPropertyObject is not a string.');  // Error
				return undefined;
			}
		},

		// SetBagsDefaultType: Changes bag's default type as long as no new properties would be added by doing so.  Returns true on success, false on failure, and undefined on error.
		SetBagsDefaultType : function (BagName, DefaultBagType) {
			if (UInv.isString(BagName) && UInv.isString(DefaultBagType)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if ((UInv.GetDefaultBagObject(DefaultBagType, true)) || (DefaultBagType === "-")) {
						UInv.SetCurrentBagName(BagName);
						var Props = UInv.GetBagPropertyObject(BagName), DefProps = {};
						if (DefaultBagType !== "-") {
							DefProps = UInv.GetDefaultBagObject(DefaultBagType, true);
							var Keys = Object.keys(DefProps), i = 0;
							if (!UInv.isProperty(DefProps, "UInvVariableType")) {
								for (i = 0; i < Keys.length; i++) {
									if (UInv.isProperty(Props, Keys[i])) {
										if (Props[Keys[i]] === DefProps[Keys[i]]) {
											delete Props[Keys[i]];  // delete default properties
										}
									} else {
										if (Keys[i] != "UInvVariableType") {
											return false;  // Success - Could not change default bag type because default property of that type does not exist on BagBame
										}
									}
								}
							}
						}
						if ((BagName !== DefaultBagType) || (UInv.isProperty(DefProps, "UInvVariableType"))) {
							State.variables.UInvBags[BagName].UInvDefaultBagType = DefaultBagType;
						}
						if ((BagName === DefaultBagType) && (UInv.isProperty(State.variables.UInvBags[BagName], "UInvDefaultBagType")) && (!UInv.isProperty(DefProps, "UInvVariableType"))) {
							delete State.variables.UInvBags[BagName].UInvDefaultBagType;
						}
						if (UInv.isProperty(State.variables.UInvBags[BagName], "UInvProperties")) {
							delete State.variables.UInvBags[BagName].UInvProperties;
						}
						State.variables.UInvBags[BagName].UInvProperties = Props;
						if (UInv.isProperty(DefProps, "UInvVariableType")) {
							State.variables.UInvBags[BagName].UInvProperties.UInvVariableType = DefProps.UInvVariableType;
						} else if (UInv.isProperty(State.variables.UInvBags[BagName].UInvProperties, "UInvVariableType")) {
							delete State.variables.UInvBags[BagName].UInvProperties.UInvVariableType;
						}
						if (Object.keys(State.variables.UInvBags[BagName].UInvProperties).length === 0) {
							delete State.variables.UInvBags[BagName].UInvProperties;
						}
						return true;  // Success
					} else {
						UInvError('SetBagsDefaultType failed. "' + DefaultBagType + '" is not a valid default bag type.');  // Error
						return undefined;
					}
				} else {
					UInvError('SetBagsDefaultType cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to SetBagsDefaultType is not a string.');  // Error
				return undefined;
			}
		},

		// BagPropertyCount: Returns the number of BagName's properties, or undefined if there is an error.
		BagPropertyCount : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					return UInv.GetBagPropertyArray(BagName).length;  // Success
				} else {
					UInvError('BagPropertyCount cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagPropertyCount is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagsArrayByProperty: Returns an array of BagNames that have property BagPropertyName.
		GetBagsArrayByProperty : function (BagPropertyName, BagNameArray) {
			if (UInv.isString(BagPropertyName)) {
				if (UInv.isUndefined(BagNameArray)) {
					BagNameArray = UInv.GetBagsArray();
				}
				if (UInv.isArrayOfStrings(BagNameArray)) {
					if (UInv.BagExists(BagNameArray)) {
						var i = 0, Result = [];
						for (i = 0; i < BagNameArray.length; i++) {
							if (UInv.BagHasProperty(BagNameArray[i], BagPropertyName)) {
								Result.push(BagNameArray[i]);
							}
						}
						return Result;  // Success
					} else {
						UInvError('GetBagsArrayByProperty failed. Invalid bag name within BagNameArray.');  // Error
						return undefined;
					}
				} else if ((UInv.isArray(BagNameArray)) && (BagNameArray.length === 0)) {
					return [];  // Success
				} else {
					UInvError('BagNameArray passed to GetBagsArrayByProperty is not an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to GetBagsArrayByProperty is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagByProperty: Returns a random BagName that has property BagPropertyName.
		GetBagByProperty : function (BagPropertyName) {
			if (UInv.isString(BagPropertyName)) {
					var Bags = UInv.GetBagsArrayByProperty(BagPropertyName);
					if (Bags.length > 0) {
						var Rnd = random(Bags.length - 1);
						UInv.SetCurrentBagName(Bags[Rnd]);
						return Bags[Rnd];  // Success
					} else {
						return "";  // Success
					}
			} else {
				UInvError('BagPropertyName passed to GetBagByProperty is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasAllProperties: Reurns whether all of the bag's properties are listed in BagPropertyNameArray, false if the bag has no properties, or undefined on error.
		BagHasAllProperties : function (BagName, BagPropertyNameArray) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.isArrayOfStrings(BagPropertyNameArray)) {
						UInv.SetCurrentBagName(BagName);
						var Props = UInv.GetBagPropertyArray(BagName);
						if (Props.length > 0) {
							var i;
							for (i = 0; i < BagPropertyNameArray.length; i++) {
								if (!Props.includes(BagPropertyNameArray[i])) {
									return false;  // Success
								}
							}
							return true;  // Success
						}
						return false;  // Success
					} else {
						UInvError('BagHasAllProperties failed. BagPropertyNameArray is not an array of strings.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagHasAllProperties cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to BagHasAllProperties is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagsArrayWithAllProperties: Returns an array of all bags which have all of the properties in BagPropertyNameArray
		//                                (per the BagHasAllProperties function), not including bags with no properties, or return undefined on error.
		GetBagsArrayWithAllProperties : function (BagPropertyNameArray) {
			if (UInv.isArrayOfStrings(BagPropertyNameArray)) {
				var Bags = UInv.GetBagsArray(), Return = [], i;
				for (i = 0; i < Bags.length; i++) {
					if (UInv.BagHasAllProperties(Bags[i], BagPropertyNameArray)) {
						Return.pushUnique(Bags[i]);
					}
				}
				return Return;  // Success
			} else {
				UInvError('GetBagsArrayWithAllProperties failed. BagPropertyNameArray is not an array of strings.');  // Error
				return undefined;
			}
		},

		// CopyBagProperty: Copies a bag property from one bag to another, overwriting the destination if that property is already there.
		CopyBagProperty : function (SourceBagName, DestinationBagName, BagPropertyName) {
			if (UInv.isString(SourceBagName) && UInv.isString(DestinationBagName)) {
				DestinationBagName = FixBagName(DestinationBagName);
				SourceBagName = FixBagName(SourceBagName);
				if (UInv.BagExists(SourceBagName)) {
					if (UInv.BagExists(DestinationBagName)) {
						if (UInv.isString(BagPropertyName)) {
							if (UInv.BagHasProperty(SourceBagName, BagPropertyName)) {
								return UInv.SetBagPropertyValue(DestinationBagName, BagPropertyName, UInv.GetBagPropertyValue(SourceBagName, BagPropertyName));
							} else {
								UInvError('CopyBagProperty failed. Bag "' + SourceBagName + '" does not have property "' + BagPropertyName + '".');  // Error
								return undefined;
							}
						} else if (UInv.isArrayOfStrings(BagPropertyName)) {
							if (UInv.BagHasAllProperties(SourceBagName, BagPropertyName)) {
								var Result = true, i = 0;
								for (i = 0; i < BagPropertyName.length; i++) {
									if (!UInv.CopyBagProperty(SourceBagName, DestinationBagName, BagPropertyName[i])) {
										Result = undefined;  // Error
									}
								}
								return Result;  // Success (or Error, though this shouldn't fail)
							} else {
								UInvError('CopyBagProperty failed. Bag "' + SourceBagName + '" does not have all properties in BagPropertyName parameter.');  // Error
								return undefined;
							}
						} else {
							UInvError('CopyBagProperty failed. BagPropertyName is not a string or an array of strings.');  // Error
							return undefined;
						}
					} else {
						UInvError('CopyBagProperty cannot find bag "' + DestinationBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('CopyBagProperty cannot find bag "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to CopyBagProperty is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagsArrayWherePropertyEquals: Returns an array of all BagNames where BagPropertyName's value === Value, returns [] if none found, or undefined on error.
		GetBagsArrayWherePropertyEquals : function (BagPropertyName, Value) {
			if (UInv.isString(BagPropertyName)) {
				if (arguments.length >= 2) {
					var Bags = UInv.GetBagsArrayByProperty(BagPropertyName), i = 0, Result = [];
					for (i = 0; i < Bags.length; i++) {
						if (UInv.valuesAreEqual(UInv.GetBagPropertyValue(Bags[i], BagPropertyName), Value)) {
							Result.push(Bags[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetBagsArrayWherePropertyEquals failed. Value parameter is missing.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to GetBagsArrayWherePropertyEquals is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagWherePropertyEquals: Returns a random BagName where BagPropertyName === Value, returns "" if not found, or undefined on error.  Sets that bag as the current bag.
		GetBagWherePropertyEquals : function (BagPropertyName, Value) {
			if (UInv.isString(BagPropertyName)) {
				if (arguments.length >= 2) {
					var Bags = UInv.GetBagsArrayWherePropertyEquals(BagPropertyName, Value);
					if (Bags.length > 0) {
						var Rnd = random(Bags.length - 1);
						UInv.SetCurrentBagName(Bags[Rnd]);
						return Bags[Rnd];  // Success
					} else {
						return "";  // Success - Not found
					}
				} else {
					UInvError('GetBagWherePropertyEquals failed. Value parameter is missing.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to GetBagWherePropertyEquals is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagsArrayWherePropertyGreaterThan: Returns an array of all BagNames where BagPropertyName > Value, returns [] if none found, or undefined on error.
		GetBagsArrayWherePropertyGreaterThan : function (BagPropertyName, Value) {
			if (UInv.isString(BagPropertyName)) {
				if (arguments.length >= 2) {
					var Bags = UInv.GetBagsArrayByProperty(BagPropertyName), i = 0, Result = [];
					for (i = 0; i < Bags.length; i++) {
						if (UInv.GetBagPropertyValue(Bags[i], BagPropertyName) > Value) {
							Result.push(Bags[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetBagsArrayWherePropertyGreaterThan failed. Value parameter is missing.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to GetBagsArrayWherePropertyGreaterThan is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagWherePropertyGreaterThan: Returns a random BagName where BagPropertyName > Value, returns "" if not found, or undefined on error.  Sets that bag as the current bag.
		GetBagWherePropertyGreaterThan : function (BagPropertyName, Value) {
			if (UInv.isString(BagPropertyName)) {
				if (arguments.length >= 2) {
					var Bags = UInv.GetBagsArrayWherePropertyGreaterThan(BagPropertyName, Value);
					if (Bags.length > 0) {
						var Rnd = random(Bags.length - 1);
						UInv.SetCurrentBagName(Bags[Rnd]);
						return Bags[Rnd];  // Success
					} else {
						return "";  // Success - Not found
					}
				} else {
					UInvError('GetBagWherePropertyGreaterThan failed. Value parameter is missing.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to GetBagWherePropertyGreaterThan is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagsArrayWherePropertyLessThan: Returns an array of all BagNames where BagPropertyName < Value, returns [] if none found, or undefined on error.
		GetBagsArrayWherePropertyLessThan : function (BagPropertyName, Value) {
			if (UInv.isString(BagPropertyName)) {
				if (arguments.length >= 2) {
					var Bags = UInv.GetBagsArrayByProperty(BagPropertyName), i = 0, Result = [];
					for (i = 0; i < Bags.length; i++) {
						if (UInv.GetBagPropertyValue(Bags[i], BagPropertyName) < Value) {
							Result.push(Bags[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetBagsArrayWherePropertyLessThan failed. Value parameter is missing.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to GetBagsArrayWherePropertyLessThan is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagWherePropertyLessThan: Returns a random BagName where BagPropertyName < Value, returns "" if not found, or undefined on error.  Sets that bag as the current bag.
		GetBagWherePropertyLessThan : function (BagPropertyName, Value) {
			if (UInv.isString(BagPropertyName)) {
				if (arguments.length >= 2) {
					var Bags = UInv.GetBagsArrayWherePropertyLessThan(BagPropertyName, Value);
					if (Bags.length > 0) {
						var Rnd = random(Bags.length - 1);
						UInv.SetCurrentBagName(Bags[Rnd]);
						return Bags[Rnd];  // Success
					} else {
						return "";  // Success - Not found
					}
				} else {
					UInvError('GetBagWherePropertyLessThan failed. Value parameter is missing.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to GetBagWherePropertyLessThan is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagWithHighestPropertyValue: Returns the BagName with the highest value on BagPropertyName (bags without BagPropertyName are ignored),
		//                                 randomly picks one of the highest if multiple bags are tied for highest, "" if none found, or undefined on error.
		GetBagWithHighestPropertyValue : function (BagPropertyName, BagNameArray) {
			if (UInv.isString(BagPropertyName)) {
				if (UInv.isUndefined(BagNameArray)) {
					BagNameArray = UInv.GetBagsArray();
				}
				if (UInv.isArrayOfStrings(BagNameArray)) {
					var Bags = UInv.GetBagsArrayByProperty(BagPropertyName, BagNameArray);
					// var HiVal = Bags.map(o => o[BagPropertyName]).reduce((a, b) => Math.max(a, b));
					// return Bags.filter(o => o[BagPropertyName] === HiVal).random();
					if (Bags.length > 0) {
						var HiBags = [ Bags[0] ], HiVal = UInv.GetBagPropertyValue(Bags[0], BagPropertyName);
						if (Bags.length > 1) {
							var i, Value = 0;
							for (i = 1; i < Bags.length; i++) {
								Value = UInv.GetBagPropertyValue(Bags[i], BagPropertyName);
								if (Value > HiVal) {
									HiVal = Value;
									HiBags = [ Bags[i] ];
								} else if (Value === HiVal) {
									HiBags.push(Bags[i]);
								}
							}
						}
						return HiBags[random(HiBags.length - 1)];  // Success
					} else {
						return "";  // Success - Not found
					}
				} else {
					UInvError('GetBagWithHighestPropertyValue failed. BagNameArray is not an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to GetBagWithHighestPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagWithLowestPropertyValue: Returns the BagName with the lowest value on BagPropertyName (bags without BagPropertyName are ignored),
		//                                randomly picks one of the lowest if multiple bags are tied for lowest, "" if none found, or undefined on error.
		GetBagWithLowestPropertyValue : function (BagPropertyName, BagNameArray) {
			if (UInv.isString(BagPropertyName)) {
				if (UInv.isUndefined(BagNameArray)) {
					BagNameArray = UInv.GetBagsArray();
				}
				if (UInv.isArrayOfStrings(BagNameArray)) {
					var Bags = UInv.GetBagsArrayByProperty(BagPropertyName, BagNameArray);
					if (Bags.length > 0) {
						var LoBags = [ Bags[0] ], LoVal = UInv.GetBagPropertyValue(Bags[0], BagPropertyName);
						if (Bags.length > 1) {
							var i, Value = 0;
							for (i = 1; i < Bags.length; i++) {
								Value = UInv.GetBagPropertyValue(Bags[i], BagPropertyName);
								if (Value < LoVal) {
									LoVal = Value;
									LoBags = [ Bags[i] ];
								} else if (Value === LoVal) {
									LoBags.push(Bags[i]);
								}
							}
						}
						return LoBags[random(LoBags.length - 1)];  // Success
					} else {
						return "";  // Success - Not found
					}
				} else {
					UInvError('GetBagWithLowestPropertyValue failed. Invalid type passed as BagNameArray property.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to GetBagWithLowestPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// AddToBagPropertyValue: Add an amount to a property's value (returns true), create that property if it doesn't exist (returns false), or return undefined if there is an error.
		AddToBagPropertyValue : function (BagName, BagPropertyName, Amount) {
			if (UInv.isString(BagName) && UInv.isString(BagPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					if (!UInv.isUndefined(Amount)) {
						Amount = tryIntParse(Amount);
						if (UInv.isNumber(Amount)) {
							if (UInv.BagHasProperty(BagName, BagPropertyName)) {
								if (UInv.isNumber(UInv.GetBagPropertyValue(BagName, BagPropertyName))) {
									UInv.SetBagPropertyValue(BagName, BagPropertyName, UInv.GetBagPropertyValue(BagName, BagPropertyName) + Amount);
									return true;  // Success
								} else {
									UInvError('AddToBagPropertyValue failed. Item\'s property value must be a number to add to it.');  // Error
									return undefined;
								}
							} else {
								UInv.SetBagPropertyValue(BagName, BagPropertyName, Amount);
								return false;  // Success
							}
						} else {
							UInvError('AddToBagPropertyValue failed. Amount must be a number.');  // Error
							return undefined;
						}
					} else {
						UInvError('AddToBagPropertyValue failed. Value not defined.');  // Error
						return undefined;
					}
				} else {
					UInvError('AddToBagPropertyValue cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to AddToBagPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// DeleteBagProperty: Deletes bag property BagPropertyName.  Returns true if successful, otherwise false.
		DeleteBagProperty : function (BagName, BagPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(BagPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					if (UInv.BagHasProperty(BagName, BagPropertyName)) {
						var Type = UInv.GetBagsDefaultType(BagName);
						if (Type !== "-") {
							var Props = UInv.GetDefaultBagObject(Type, true), Keys = Object.keys(Props), i;
							if ((UInv.isProperty(Props, BagPropertyName) && (!UInv.isProperty(Props, "UInvVariableType")))
								// if the property to be deleted is a default property, change default type and load other properties
								|| ((BagPropertyName === "UInvVariableType") && (UInv.isProperty(Props, "UInvVariableType")))) {
								// -or- if it was a variable type bag, change the default type to prevent pulling variable default properties
								UInv.SetBagsDefaultType(BagName, "-");
							} else if ((BagPropertyName === "UInvVariableType") && (!UInv.isProperty(Props, "UInvVariableType"))) {  // restore bag as a non-variable type bag
								for (i = 0; i < Keys.length; i++) {
									if (UInv.isProperty(State.variables.UInvBags[BagName].UInvProperties, Keys[i])) {
										if (UInv.valuesAreEqual(State.variables.UInvBags[BagName].UInvProperties[Keys[i]], Props[Keys[i]])) {
											delete State.variables.UInvBags[BagName].UInvProperties[Keys[i]];
										}
									}
								}
								if (UInv.isProperty(State.variables.UInvBags[BagName], "UInvDefaultBagType") && (State.variables.UInvBags[BagName].UInvDefaultBagType === BagName)) {
									delete State.variables.UInvBags[BagName].UInvDefaultBagType;  // no longer needed
								}
							}
						}
						delete State.variables.UInvBags[BagName].UInvProperties[BagPropertyName];
						if (Object.keys(State.variables.UInvBags[BagName].UInvProperties).length === 0) {
							delete State.variables.UInvBags[BagName].UInvProperties;
						}
					}
					return true;  // Success
				} else {
					UInvError('DeleteBagProperty cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to DeleteBagProperty is not a string.');  // Error
				return undefined;
			}
		},

		// MoveAllItemsToBag: Moves all items from source to destination.
		MoveAllItemsToBag : function (SourceBagName, DestinationBagName) {
			if (UInv.isString(DestinationBagName)) {
				DestinationBagName = FixBagName(DestinationBagName);
				if (UInv.isString(SourceBagName)) {
					SourceBagName = [ FixBagName(SourceBagName) ];
				}
				if (UInv.BagExists(DestinationBagName)) {
					if (UInv.BagExists(SourceBagName)) {
						var i, j, SrcItems;
						UInv.IncrementUpdateLock();
						for (i = 0; i < SourceBagName.length; i++) {
							if (SourceBagName[i] !== DestinationBagName) {
								SrcItems = UInv.GetItemsArray(SourceBagName[i]);
								for (j = 0; j < SrcItems.length; j++) {
									UInv.MoveItem(SourceBagName[i], DestinationBagName, SrcItems[j]);  // handle move failure due to pocket protection ***
								}
							}
						}
						UInv.DecrementUpdateLock();
						return true;  // Success
					} else {
						UInvError('MoveAllItemsToBag failed. Invalid bag name SourceBagName array.');  // Error
						return undefined;
					}
				} else {
					UInvError('MoveAllItemsToBag cannot find destination bag "' + DestinationBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('DestinationBagName passed to MoveAllItemsToBag is not a string.');  // Error
				return undefined;
			}
		},

		// MergeBags: Moves all items from source to destination and deletes source.
		MergeBags : function (SourceBagName, DestinationBagName) {
			if (UInv.isString(SourceBagName) && UInv.isString(DestinationBagName)) {
				SourceBagName = FixBagName(SourceBagName);
				DestinationBagName = FixBagName(DestinationBagName);
				if (SourceBagName !== DestinationBagName) {
					if (UInv.BagExists(SourceBagName)) {
						if (UInv.BagExists(DestinationBagName)) {
							var Result = true;
							Result = UInv.MoveAllItemsToBag(SourceBagName, DestinationBagName);
							if (Result) {
								UInv.DeleteBag(SourceBagName);
							}
							return Result;  // Success
						} else {
							UInvError('MergeBags cannot find bag "' + DestinationBagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('MergeBags cannot find bag "' + SourceBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('MergeBags failed. SourceBagName and DestinationBagName cannot be the same. Value = "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to MergeBags is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagsArrayWithItem: Returns an array of BagNames that have item (limited to items in BagArray bags if BagArray is passed to function), or undefined if there is an error.
		GetBagsArrayWithItem : function (ItemName, BagArray) {
			if (UInv.isString(ItemName)) {
				if (UInv.isUndefined(BagArray)) {
					BagArray = UInv.GetBagsArray();
				} else if (UInv.isArrayOfStrings(BagArray)) {
					if (!UInv.BagExists(BagArray)) {
						UInvError('GetBagsArrayWithItem failed. Invalid bag name in BagArray.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagArray passed to GetBagsArrayWithItem is not an array of strings.');  // Error
					return undefined;
				}
				var Result = [], i = 0;
				if (BagArray.length > 0) {
					for (i = 0; i < BagArray.length; i++) {
						if (UInv.BagHasItem(BagArray[i], ItemName)) {  // OOO function call
							Result.pushUnique(BagArray[i]);
						}
					}
				}
				return Result;  // Success
			} else {
				UInvError('ItemName passed to GetBagsArrayWithItem is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagObject: Returns the full bag object (including UInvDefaultBagType) or undefined on error.
		GetBagObject : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Result = {}, i = 0, Props = UInv.GetBagPropertyArray(BagName);
					UInv.SetCurrentBagName(BagName);
					Result = clone(State.variables.UInvBags[BagName]);
					Result.UInvDefaultBagType = UInv.GetBagsDefaultType(BagName);
					if (Props.length > 0) {
						if (!UInv.isProperty(Result, "UInvProperties")) {
							Result.UInvProperties = {};
						}
						for (i = 0; i < Props.length; i++) {
							Result.UInvProperties[Props[i]] = UInv.GetBagPropertyValue(BagName, Props[i]);
						}
					}
					Props = UInv.GetItemsArray(BagName);  // OOO function call
					if (Props.length > 0) {
						for (i = 0; i < Props.length; i++) {
							Result[Props[i]] = UInv.GetItemObject(BagName, Props[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetBagObject cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetBagObject is not a string.');  // Error
				return undefined;
			}
		},

		// WasTouched: Returns whether the number of items in the bag have changed since creation or since Untouched was last set, or undefined if there is an error.
		WasTouched : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					if (UInv.isProperty(State.variables.UInvBags[BagName], "UInvTouched")) {
						return State.variables.UInvBags[BagName].UInvTouched;  // Success
					} else {
						return true;  // Success
					}
				} else {
					UInvError('WasTouched cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to WasTouched is not a string.');  // Error
				return undefined;
			}
		},

		// GetUniqueBagName: Generates and returns an unused bag name ("bagXXHEXX").
		GetUniqueBagName : function () {
			var BagName = "bag" + UInv.getRandomHexString();
			while (UInv.BagExists(BagName)) {
				BagName = "bag" + UInv.getRandomHexString();
			}
			return BagName;
		},

		// BagMatchesDefault: Returns whether bag exactly matches its default version, or undefined on error.  Returns false if the bag does not have a default object.
		BagMatchesDefault : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Typ = UInv.GetBagsDefaultType(BagName);
					if ((Typ === "-") || UInv.isUndefined(Typ)) {
						return false;  // Success
					}
					var BagOb = UInv.GetBagObject(BagName);
					var TmpBag = UInv.GetUniqueBagName();
					UInv.AddBag(TmpBag, Typ);
					if (UInv.WasTouched(BagName)) {
						UInv.SetBagTouched(TmpBag);
					}
					var TmpBagOb = UInv.GetBagObject(TmpBag);
					var Result = UInv.objectsAreEqual(BagOb, TmpBagOb);
					UInv.DeleteBag(TmpBag);
					return Result;  // Success
				} else {
					UInvError('BagMatchesDefault cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to BagMatchesDefault is not a string.');  // Error
				return undefined;
			}
		},

		// GetTotalBagPropertyValue: Returns the total value of BagPropertyName across all bags, or across all bags in BagNameArray, or undefined on error.
		GetTotalBagPropertyValue : function (BagPropertyName, BagNameArray) {
			if (UInv.isString(BagPropertyName)) {
				if (UInv.isUndefined(BagNameArray)) {
					BagNameArray = UInv.GetBagsArray();
				}
				if (UInv.isString(BagNameArray)) {
					BagNameArray = [ BagNameArray ];
				}
				if (UInv.isArrayOfStrings(BagNameArray)) {
					if (UInv.BagExists(BagNameArray)) {
						var Total = 0, Val, i;
						if (BagNameArray.length > 0) {
							for (i = 0; i < BagNameArray.length; i++) {
								if (UInv.BagHasProperty(BagNameArray[i], BagPropertyName)) {
									Val = UInv.GetBagPropertyValue(BagNameArray[i], BagPropertyName);
									if (UInv.isNumber(Val)) {
										Total += Val;
									} else {
										UInvError('GetTotalBagPropertyValue failed.  Property "' + BagPropertyName + '" on bag "' + BagNameArray[i] + '" is not a number.');  // Error
										return undefined;
									}
								}
							}
						}
						return Total;  // Success
					} else {
						UInvError('GetTotalBagPropertyValue failed.  Bag in BagNameArray does not exist.');  // Error
						return undefined;
					}
				} else {
					UInvError('GetTotalBagPropertyValue failed.  If included, BagNameArray must be a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to GetTotalBagPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// MoveBagPropertyValueToBag: Moves an amount of a number from one bag's property to another bag's property, limited by the minimum and maximum values.
		//                            Deletes the bag or property (depending on DeletionType) if the property's value gets set to DeletionValue.  Returns the destination value or undefined on error.
		MoveBagPropertyValueToBag : function (SourceBagName, SourceBagPropertyName, DestinationBagName, DestinationBagPropertyName, Amount, MinimumValue, MaximumValue, DeletionValue, DeletionType) {
			if (UInv.isString(SourceBagName) && UInv.isString(SourceBagPropertyName) && UInv.isString(DestinationBagName)) {
				SourceBagName = FixBagName(SourceBagName);
				DestinationBagName = FixBagName(DestinationBagName);
				if (UInv.BagExists(SourceBagName)) {
					if (UInv.BagExists(DestinationBagName)) {
						if (UInv.BagHasProperty(SourceBagName, SourceBagPropertyName)) {
							if (UInv.isUndefined(DestinationBagPropertyName)) {
								DestinationBagPropertyName = SourceBagPropertyName;
							}
							if (!UInv.isUndefined(Amount)) {
								Amount = tryIntParse(Amount);
								if (UInv.isNumber(Amount)) {
									var SrcVal = UInv.GetBagPropertyValue(SourceBagName, SourceBagPropertyName);
									SrcVal = tryIntParse(SrcVal);
									if (UInv.isNumber(SrcVal)) {
										var DstVal = 0;
										if (UInv.BagHasProperty(DestinationBagName, DestinationBagPropertyName)) {
											DstVal = UInv.GetBagPropertyValue(DestinationBagName, DestinationBagPropertyName);
											DstVal = tryIntParse(DstVal);
										}
										if (UInv.isNumber(DstVal)) {
											var TmpAmt = Amount;
											if (!UInv.isUndefined(MinimumValue)) {
												MinimumValue = tryIntParse(MinimumValue);
												if (UInv.isUndefined(MinimumValue)) {
													UInvError('MoveBagPropertyValueToBag failed. If used, MinimumValue must be a number.');  // Error
													return undefined;
												}
												if (SrcVal - Amount < MinimumValue) {  // Can't reduce source below minimum
													Amount = SrcVal - MinimumValue;
												}
												if (DstVal + Amount < MinimumValue) {  // Can't reduce destination below minimum (for when Amount is negative)
													Amount = MinimumValue - DstVal;
												}
											}
											if (!UInv.isUndefined(MaximumValue)) {
												MaximumValue = tryIntParse(MaximumValue);
												if (UInv.isUndefined(MaximumValue)) {
													UInvError('MoveBagPropertyValueToBag failed. If used, MaximumValue must be a number.');  // Error
													return undefined;
												}
												if ((!UInv.isUndefined(MinimumValue)) && (MinimumValue > MaximumValue)) {
													UInvError('MoveBagPropertyValueToBag failed. When both are used, MaximumValue must be greater than MinimumValue.');  // Error
													return undefined;
												}
												if (SrcVal - Amount > MaximumValue) {  // Can't increase source above maximum (for when Amount is negative)
													Amount = SrcVal - MaximumValue;
												}
												if (DstVal + Amount > MaximumValue) {  // Can't increase destination above maximum
													Amount = MaximumValue - DstVal;
												}
											}
											if (((TmpAmt >= 0) && (Amount > TmpAmt)) || ((TmpAmt < 0) && (Amount < TmpAmt))) {
												UInvError('MoveBagPropertyValueToBag failed. Source (' + SrcVal + ') and/or Destination (' + DstVal + ') values are too far out of MinimumValue (' + MinimumValue + ') and/or MaximumValue (' + MaximumValue + ') range.');  // Error
												return undefined;
											}
											if (!UInv.isUndefined(DeletionValue)) {
												DeletionValue = tryIntParse(DeletionValue);
												if (UInv.isUndefined(DeletionValue)) {
													UInvError('MoveBagPropertyValueToBag failed. If used, DeletionValue must be a number.');  // Error
													return undefined;
												}
												if (SrcVal - Amount == DeletionValue) {
													if (UInv.isString(DeletionType)) {
														DeletionType = DeletionType.toLowerCase();
													} else {
														DeletionType = "property";
													}
													switch (DeletionType) {
														case "bag":  // delete bag
														case "object":  // delete bag or item
															UInv.DeleteBag(SourceBagName);
															break;
														case "item":  // delete item (do nothing in this case)
															UInv.SetBagPropertyValue(SourceBagName, SourceBagPropertyName, SrcVal - Amount);
															break;
														default:  // delete property
															UInv.DeleteBagProperty(SourceBagName, SourceBagPropertyName);
													}
												} else {
													UInv.SetBagPropertyValue(SourceBagName, SourceBagPropertyName, SrcVal - Amount);
												}
												if (DstVal + Amount == DeletionValue) {
													if (UInv.isString(DeletionType)) {
														DeletionType = DeletionType.toLowerCase();
													} else {
														DeletionType = "property";
													}
													switch (DeletionType) {
														case "bag":  // delete bag
														case "object":  // delete bag or item
															UInv.DeleteBag(DestinationBagName);
															break;
														case "item":  // delete item (do nothing in this case)
															UInv.SetBagPropertyValue(DestinationBagName, DestinationBagPropertyName, DstVal + Amount);
															break;
														default:  // delete property
															UInv.DeleteBagProperty(DestinationBagName, DestinationBagPropertyName);
													}
												} else {
													UInv.SetBagPropertyValue(DestinationBagName, DestinationBagPropertyName, DstVal + Amount);
												}
												UInv.SetCurrentBagName(DestinationBagName);
												return DstVal + Amount;  // Success
											}
											UInv.SetBagPropertyValue(SourceBagName, SourceBagPropertyName, SrcVal - Amount);
											UInv.SetBagPropertyValue(DestinationBagName, DestinationBagPropertyName, DstVal + Amount);
											UInv.SetCurrentBagName(DestinationBagName);
											return DstVal + Amount;  // Success
										} else {
											UInvError("MoveBagPropertyValueToBag failed. Destination bag's property value must be a number to add to or subtract from it.");  // Error
											return undefined;
										}
									} else {
										UInvError("MoveBagPropertyValueToBag failed. Source bag's property value must be a number to move an Amount of it.");  // Error
										return undefined;
									}
								} else {
									UInvError('MoveBagPropertyValueToBag failed. If used, Amount must be a number.');  // Error
									return undefined;
								}
							} else {
								var Val = UInv.GetBagPropertyValue(SourceBagName, SourceBagPropertyName);
								UInv.SetBagPropertyValue(DestinationBagName, DestinationBagPropertyName, Val);
								UInv.DeleteBagProperty(SourceBagName, SourceBagPropertyName);
								UInv.SetCurrentBagName(DestinationBagName);
								return Val;  // Success
							}
						} else {
							UInvError('MoveBagPropertyValueToBag failed. Source bag "' + SourceBagName + '" does not have property "' + SourceBagPropertyName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('MoveBagPropertyValueToBag cannot find destination bag "' + DestinationBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('MoveBagPropertyValueToBag cannot find source bag "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to MoveBagPropertyValueToBag is not a string.');  // Error
				return undefined;
			}
		},

		// MoveItemPropertyValueToBag: Moves an amount of a number from an item's property to a bag's property, limited by the minimum and maximum values.
		//                             Deletes the bag, item, or property (depending on DeletionType) if the property's value gets set to DeletionValue.  Returns the destination value or undefined on error.
		MoveItemPropertyValueToBag : function (SourceBagName, SourceItemName, SourceItemPropertyName, DestinationBagName, DestinationBagPropertyName, Amount, MinimumValue, MaximumValue, DeletionValue, DeletionType) {
			if (UInv.isString(SourceBagName) && UInv.isString(SourceItemName) && UInv.isString(SourceItemPropertyName) && UInv.isString(DestinationBagName)) {
				SourceBagName = FixBagName(SourceBagName);
				DestinationBagName = FixBagName(DestinationBagName);
				if (UInv.BagExists(SourceBagName)) {
					if (UInv.BagExists(DestinationBagName)) {
						SourceItemName = FixItemName(SourceItemName);
						if (UInv.BagHasItem(SourceBagName, SourceItemName)) {  // OOO function call
							if (UInv.isUndefined(DestinationBagPropertyName)) {
								DestinationBagPropertyName = SourceItemPropertyName;
							}
							if (UInv.ItemHasProperty(SourceBagName, SourceItemName, SourceItemPropertyName)) {  // OOO function call
								if (["UInvDefaultItemType", "UInvPocket"].includes(SourceItemPropertyName)) {
									UInvError('MoveItemPropertyValueToBag failed. SourceItemPropertyName cannot be "' + SourceItemPropertyName + '".');  // Error
									return undefined;
								}
								if (SourceItemPropertyName === "UInvQuantity") {
									if ((!UInv.isUndefined(Amount)) && (!UInv.isInteger(Amount))) {
										UInvError("MoveItemPropertyValueToBag failed. Amount must be an integer to move it from an item's UInvQuantity.");  // Error
										return undefined;
									}
									MinimumValue = 0;
									DeletionValue = 0;
									if (UInv.isString(DeletionType) && (DeletionType !== "object")) {
										DeletionType = "item";
									}
								}
								if (!UInv.isUndefined(Amount)) {
									Amount = tryIntParse(Amount);
									if (UInv.isNumber(Amount)) {
										var SrcVal = UInv.GetItemPropertyValue(SourceBagName, SourceItemName, SourceItemPropertyName);  // OOO function call
										SrcVal = tryIntParse(SrcVal);
										if (UInv.isNumber(SrcVal)) {
											var DstVal = 0;
											if (UInv.BagHasProperty(DestinationBagName, DestinationBagPropertyName)) {
												DstVal = UInv.GetBagPropertyValue(DestinationBagName, DestinationBagPropertyName);
												DstVal = tryIntParse(DstVal);
											}
											if (UInv.isNumber(DstVal)) {
												var TmpAmt = Amount;
												if (!UInv.isUndefined(MinimumValue)) {
													MinimumValue = tryIntParse(MinimumValue);
													if (UInv.isUndefined(MinimumValue)) {
														UInvError('MoveItemPropertyValueToBag failed. If used, MinimumValue must be a number.');  // Error
														return undefined;
													}
													if (SrcVal - Amount < MinimumValue) {  // Can't reduce source below minimum
														Amount = SrcVal - MinimumValue;
													}
													if (DstVal + Amount < MinimumValue) {  // Can't reduce destination below minimum (for when Amount is negative)
														Amount = MinimumValue - DstVal;
													}
												}
												if (!UInv.isUndefined(MaximumValue)) {
													MaximumValue = tryIntParse(MaximumValue);
													if (UInv.isUndefined(MaximumValue)) {
														UInvError('MoveItemPropertyValueToBag failed. If used, MaximumValue must be a number.');  // Error
														return undefined;
													}
													if ((!UInv.isUndefined(MinimumValue)) && (MinimumValue > MaximumValue)) {
														UInvError('MoveItemPropertyValueToBag failed. When both are used, MaximumValue must be greater than MinimumValue.');  // Error
														return undefined;
													}
													if (SrcVal - Amount > MaximumValue) {  // Can't increase source above maximum (for when Amount is negative)
														Amount = SrcVal - MaximumValue;
													}
													if (DstVal + Amount > MaximumValue) {  // Can't increase destination above maximum
														Amount = MaximumValue - DstVal;
													}
												}
												if (((TmpAmt >= 0) && (Amount > TmpAmt)) || ((TmpAmt < 0) && (Amount < TmpAmt))) {
													UInvError('MoveItemPropertyValueToBag failed. Source (' + SrcVal + ') and/or Destination (' + DstVal + ') values are too far out of MinimumValue (' + MinimumValue + ') and/or MaximumValue (' + MaximumValue + ') range.');  // Error
													return undefined;
												}
												if (!UInv.isUndefined(DeletionValue)) {
													DeletionValue = tryIntParse(DeletionValue);
													if (UInv.isUndefined(DeletionValue)) {
														UInvError('MoveItemPropertyValueToBag failed. If used, DeletionValue must be a number.');  // Error
														return undefined;
													}
													if (SrcVal - Amount == DeletionValue) {
														if (UInv.isString(DeletionType)) {
															DeletionType = DeletionType.toLowerCase();
														} else {
															DeletionType = "property";
														}
														switch (DeletionType) {
															case "item":  // delete item
															case "object":  // delete bag or item
																UInv.DeleteItem(SourceBagName, SourceItemName);  // OOO function call
																break;
															case "bag":  // delete bag (do nothing in this case)
																UInv.SetItemPropertyValue(SourceBagName, SourceItemName, SourceItemPropertyName, SrcVal - Amount);  // OOO function call
																break;
															default:  // delete property
																UInv.DeleteItemProperty(SourceBagName, SourceItemName, SourceItemPropertyName);  // OOO function call
														}
													} else {
														UInv.SetItemPropertyValue(SourceBagName, SourceItemName, SourceItemPropertyName, SrcVal - Amount);  // OOO function call
													}
													if (DstVal + Amount == DeletionValue) {
														if (UInv.isString(DeletionType)) {
															DeletionType = DeletionType.toLowerCase();
														} else {
															DeletionType = "property";
														}
														switch (DeletionType) {
															case "bag":  // delete bag
															case "object":  // delete bag or item
																UInv.DeleteBag(DestinationBagName);
																break;
															case "item":  // delete item (do nothing in this case)
																UInv.SetBagPropertyValue(DestinationBagName, DestinationBagPropertyName, DstVal + Amount);
																break;
															default:  // delete property
																UInv.DeleteBagProperty(DestinationBagName, DestinationBagPropertyName);
														}
													} else {
														UInv.SetBagPropertyValue(DestinationBagName, DestinationBagPropertyName, DstVal + Amount);
													}
													UInv.SetCurrentBagName(DestinationBagName);
													return DstVal + Amount;  // Success
												}
												UInv.SetItemPropertyValue(SourceBagName, SourceItemName, SourceItemPropertyName, SrcVal - Amount);  // OOO function call
												UInv.SetBagPropertyValue(DestinationBagName, DestinationBagPropertyName, DstVal + Amount);
												UInv.SetCurrentBagName(DestinationBagName);
												return DstVal + Amount;  // Success
											} else {
												UInvError("MoveItemPropertyValueToBag failed. Destination bag's property value must be a number to add to or subtract from it.");  // Error
												return undefined;
											}
										} else {
											UInvError("MoveItemPropertyValueToBag failed. Source item's property value must be a number to move an Amount of it.");  // Error
											return undefined;
										}
									} else {
										UInvError('MoveItemPropertyValueToBag failed. If used, Amount must be a number.');  // Error
										return undefined;
									}
								} else {
									if (["UInvDefaultItemType", "UInvPocket"].includes(SourceItemPropertyName)) {
										UInvError('MoveItemPropertyValueToBag failed. SourceItemPropertyName cannot be "' + SourceItemPropertyName + '".');  // Error
										return undefined;
									}
									if (SourceItemPropertyName === "UInvQuantity") {
										UInvError('MoveItemPropertyValueToBag failed. SourceItemPropertyName cannot be "UInvQuantity" unless Amount is set to an Integer.');  // Error
										return undefined;
									}
									var Val = UInv.GetItemPropertyValue(SourceBagName, SourceItemName, SourceItemPropertyName);  // OOO function call
									UInv.SetBagPropertyValue(DestinationBagName, DestinationBagPropertyName, Val);
									UInv.DeleteItemProperty(SourceBagName, SourceItemName, SourceItemPropertyName);  // OOO function call
									UInv.SetCurrentBagName(DestinationBagName);
									return Val;  // Success
								}
							} else {
								UInvError('MoveItemPropertyValueToBag failed. Item "' + SourceItemName + '" in bag "' + SourceBagName + '" does not have property "' + SourceItemPropertyName + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('MoveItemPropertyValueToBag failed. Source bag "' + SourceBagName + '" does not contain item "' + SourceItemName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('MoveItemPropertyValueToBag cannot find destination bag "' + DestinationBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('MoveItemPropertyValueToBag cannot find source bag "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to MoveItemPropertyValueToBag is not a string.');  // Error
				return undefined;
			}
		},

		// GetRawBagObject: Returns the raw bag object.  FOR INTERNAL/TESTING USE ONLY.
		GetRawBagObject : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					return State.variables.UInvBags[BagName];  // Success
				} else {
					UInvError('GetRawBagObject cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetRawBagObject is not a string.');  // Error
				return undefined;
			}
		},


		// UInv Pocket/Container Functions:
		// ================================

		// GetPocketBagContainerArray: Returns the array of all items that directly contain this pocket, or [] if none do, or undefined on error.
		//                             The array will be in the format of: [ { ContainerBagName : "name", ContainerName : "name", PocketName : "name" }, ... ]
		GetPocketBagContainerArray : function (PocketBagName) {
			if (UInv.isString(PocketBagName)) {
				PocketBagName = FixBagName(PocketBagName);
				if (UInv.BagExists(PocketBagName)) {
					UInv.SetCurrentBagName(PocketBagName);
					if (UInv.isProperty(State.variables.UInvBags[PocketBagName], "UInvContainer")) {
						var Val = State.variables.UInvBags[PocketBagName].UInvContainer;
						if (UInv.isArrayOfGenericObjects(Val)) {
							if (Val.length > 0) {
								return Val;  // Success
							} else {
								return [];  // Success
							}
						} else {
							return [];  // Success
						}
					} else {
						return [];  // Success
					}
				} else {
					UInvError('GetPocketBagContainerArray cannot find bag "' + PocketBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetPocketBagContainerArray is not a string.');  // Error
				return undefined;
			}
		},

		// BagIsPocket: Returns how many items the bag is a pocket for, or 0 if none, or undefined on error.
		BagIsPocket : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					return UInv.GetPocketBagContainerArray(BagName).length;
				} else {
					UInvError('BagIsPocket cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagIsPocket is not a string.');  // Error
				return undefined;
			}
		},

		// ItemHasPocket: Returns how many pockets the item has, or 0 if none, or undefined on error.  If PocketName is passed, returns whether the item has a pocket with that name.
		ItemHasPocket : function (BagName, ItemName, PocketName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {  // OOO function call
						UInv.SetCurrentBagName(BagName);
						UInv.SetCurrentItemName(ItemName);  // OOO function call
						if (UInv.ItemHasProperty(BagName, ItemName, "UInvPocket")) {  // OOO function call
							var Val = UInv.GetItemPropertyValue(BagName, ItemName, "UInvPocket");  // OOO function call
							var Keys = Object.keys(Val);
							if (UInv.isUndefined(PocketName)) {
								return Keys.length;  // Success
							} else {
								return Keys.includes(PocketName);  // Success
							}
						} else {
							if (UInv.isUndefined(PocketName)) {
								return 0;  // Success - no pockets
							} else {
								return false;  // Success - no pockets
							}
						}
					} else {
						UInvError('ItemHasPocket cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ItemHasPocket cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to ItemHasPocket is not a string.');  // Error
				return undefined;
			}
		},

		// GetPocketDepth: Returns 0 if it's a bag, 1 if it's a pocket, 2 if it's a pocket within a pocket, etc... or undefined on error.
		GetPocketDepth : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					if (UInv.BagIsPocket(BagName)) {
						var Bags = UInv.GetPocketBagContainerArray(BagName), BagDepth = 0, i, n;
						for (i = 0; i < Bags.length; i++) {
							n = UInv.GetPocketDepth(Bags[i].ContainerBagName);
							if (UInv.isUndefined(n)) {
								UInvError('Corrupt data. GetPocketDepth cannot find bag "' + Bags[i].ContainerBagName + '", which is listed as the ContainerBagName for the bag "' + BagName + '".');  // Error
								return undefined;  // NOTE: This error should NOT be able to happen if all UInv functions are working properly and the $UInvBags data isn't being changed by the user directly.
							} else if (n > BagDepth) {
								BagDepth = n;
							}
						}
						return ++BagDepth;  // Success
					} else {
						return 0;  // Success - bag is not a pocket
					}
				} else {
					UInvError('GetPocketDepth cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetPocketDepth is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemPocketNameArray: Gets an array of pocket names which the item has as pockets, returns [] if it has none, or undefined on error.
		GetItemPocketNameArray : function (BagName, ItemName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {  // OOO function call
						UInv.SetCurrentBagName(BagName);
						UInv.SetCurrentItemName(ItemName);  // OOO function call
						if (UInv.ItemHasPocket(BagName, ItemName)) {
							var Val = UInv.GetItemPropertyValue(BagName, ItemName, "UInvPocket");  // OOO function call
							var Keys = Object.keys(Val);
							if (Keys.length > 0) {
								return Keys;  // Success
							} else {
								delete State.variables.UInvBags[BagName][ItemName].UInvPocket;  // delete empty pocket object
								return [];  // Success
							}
						} else {
							return [];  // Success
						}
					} else {
						UInvError('GetItemPocketNameArray cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemPocketNameArray cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemPocketNameArray is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemPocketObject: Gets an object containing the PocketName-PocketBagName key-value pairs on the item, returns {} if it has none, or undefined on error.
		GetItemPocketObject : function (BagName, ItemName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {  // OOO function call
						UInv.SetCurrentBagName(BagName);
						UInv.SetCurrentItemName(ItemName);  // OOO function call
						if (UInv.ItemHasPocket(BagName, ItemName)) {
							var Val = UInv.GetItemPropertyValue(BagName, ItemName, "UInvPocket");  // OOO function call
							var Keys = Object.keys(Val);
							if (Keys.length > 0) {
								return clone(Val);  // Success
							} else {
								delete State.variables.UInvBags[BagName][ItemName].UInvPocket;  // delete empty pocket object
								return {};  // Success
							}
						} else {
							return {};  // Success
						}
					} else {
						UInvError('GetItemPocketObject cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemPocketObject cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemPocketObject is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemPocketBagArray: Gets an array of bag names which the item has as pockets, returns [] if it has none, or undefined on error.
		GetItemPocketBagArray : function (BagName, ItemName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {  // OOO function call
						UInv.SetCurrentBagName(BagName);
						UInv.SetCurrentItemName(ItemName);  // OOO function call
						if (UInv.ItemHasProperty(BagName, ItemName, "UInvPocket")) {  // OOO function call
							var Val = UInv.GetItemPropertyValue(BagName, ItemName, "UInvPocket");  // OOO function call
							var Keys = Object.keys(Val);
							if (Keys.length > 0) {
								var Bags = [], i;
								for (i = 0; i < Keys.length; i++) {
									Bags.push(Val[Keys[i]]);
								}
								return Bags;  // Success
							} else {
								delete State.variables.UInvBags[BagName][ItemName].UInvPocket;  // delete empty pocket object
								return [];  // Success
							}
						} else {
							return [];  // Success
						}
					} else {
						UInvError('GetItemPocketBagArray cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemPocketBagArray cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemPocketBagArray is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasSpecificItem: Returns whether MainBagName (or any pockets on items within MainBagName) contain ItemBagName+ItemName, or undefined on error.
		BagHasSpecificItem : function (MainBagName, ItemBagName, ItemName) {
			if (UInv.isString(MainBagName) && UInv.isString(ItemBagName) && UInv.isString(ItemName)) {
				ItemBagName = FixBagName(ItemBagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(MainBagName)) {
					if (UInv.BagExists(ItemBagName)) {
						if (UInv.BagHasItem(ItemBagName, ItemName)) {  // OOO function call
							UInv.SetCurrentBagName(ItemBagName);
							UInv.SetCurrentItemName(ItemName);  // OOO function call
							if ((MainBagName == ItemBagName) && (UInv.BagHasItem(ItemBagName, ItemName))) {  // OOO function call
								return true;  // Success - found item
							} else {
								var Items = UInv.GetItemsArray(MainBagName);  // OOO function call
								var PocketBags, i, j;
								for (i = 0; i < Items.length; i++) {
									PocketBags = UInv.GetItemPocketBagArray(MainBagName, Items[i]);
									if (PocketBags.length > 0) {
										for (j = 0; j < PocketBags.length; j++) {
											if (UInv.BagHasSpecificItem(PocketBags[j], ItemBagName, ItemName)) {
												return true;  // Success - found item
											}
										}
									}
								}
								return false;  // Success - item not found
							}
						} else {
							UInvError('BagHasSpecificItem cannot find item "' + ItemName + '" in bag "' + ItemBagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('BagHasSpecificItem cannot find bag "' + ItemBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('BagHasSpecificItem cannot find bag "' + MainBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagHasSpecificItem is not a string.');  // Error
				return undefined;
			}
		},

		// AddPocket: Adds a pocket to an existing item.  If the items are stacked, one of the items will get renamed and have a pocket added.  Returns the item's name on success, or undefined on error.
		AddPocket : function (BagName, ItemName, PocketName, DefaultBagType, StartDepth, CurrentDepth) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(PocketName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {  // OOO function call
						if (!UInv.ItemHasPocket(BagName, ItemName, PocketName)) {
							if (UInv.isUndefined(StartDepth)) {
								StartDepth = UInv.GetPocketDepth(BagName);
							}
							if (UInv.isUndefined(CurrentDepth)) {
								CurrentDepth = StartDepth;
							}
							if (UInv.isString(DefaultBagType)) {
								if (!UInv.GetDefaultBagObject(DefaultBagType, true)) {
									UInvError('AddPocket failed. Unknown bag type "' + DefaultBagType + '".');  // Error
									return undefined;
								}
							} else {
								if (!UInv.GetDefaultBagObject(PocketName, true)) {
									UInvError('AddPocket failed. Unknown bag type "' + PocketName + '".');  // Error
									return undefined;
								}
								DefaultBagType = PocketName;
							}
							UInv.IncrementUpdateLock();
							if (UInv.BagHasItem(BagName, ItemName) > 1) {  // If there's more than one, pull an item out of the stack to add a pocket to it  // OOO function call
								var NewItemName = UInv.GetUniqueItemName();  // OOO function call
								UInv.RenameItem(BagName, ItemName, NewItemName, 1);  // OOO function call
								UInv.SetBagTouched(BagName);
								ItemName = NewItemName;
							}
							var PocketBagName = PocketName;
							if (UInv.BagExists(PocketBagName)) {
								PocketBagName = UInv.GetUniqueBagName();
							}
							UInv.AddBag(PocketBagName, DefaultBagType, StartDepth, CurrentDepth + 1);
							// Connect pocket to item and vice versa
							State.variables.UInvBags[PocketBagName].UInvContainer = [ { ContainerBagName : BagName, ContainerName : ItemName, PocketName : PocketName } ];
							if (!UInv.ItemHasPocket(BagName, ItemName)) {
								State.variables.UInvBags[BagName][ItemName].UInvPocket = {};
							}
							State.variables.UInvBags[BagName][ItemName].UInvPocket[PocketName] = PocketBagName;
							UInv.DecrementUpdateLock();
							UInv.SetCurrentBagName(PocketBagName);
							return PocketBagName;
						} else {
							UInvError('AddPocket failed. Pocket "' + PocketName + '" already exists on item.');  // Error
							return undefined;
						}
					} else {
						UInvError('AddPocket cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('AddPocket cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to AddPocket is not a string.');  // Error
				return undefined;
			}
		},

		// CreatePocket: Creates a generic pocket on an existing item.  If the items are stacked, one of the items will get renamed and have a pocket added.
		//               Returns the item's name on success, or undefined on error.
		CreatePocket : function (BagName, ItemName, PocketName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(PocketName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (!UInv.ItemHasPocket(BagName, ItemName, PocketName)) {
						if (UInv.BagHasItem(BagName, ItemName) > 1) {  // Pull an item out of the stack to add a pocket to it  // OOO function call
							UInv.IncrementUpdateLock();
							var NewItemName = UInv.GetUniqueItemName();  // OOO function call
							UInv.RenameItem(BagName, ItemName, NewItemName, 1);  // OOO function call
							UInv.SetBagTouched(BagName);
							ItemName = NewItemName;
						}
						if (UInv.BagHasItem(BagName, ItemName) == 1) {  // OOO function call
							var PocketBagName = PocketName;
							if (UInv.BagExists(PocketName)) {
								PocketBagName = UInv.GetUniqueBagName();
							}
							UInv.CreateBag(PocketBagName);  // Create new bag as a pocket
							// Connect pocket to item and vice versa
							State.variables.UInvBags[PocketBagName].UInvContainer = [ { ContainerBagName : BagName, ContainerName : ItemName, PocketName : PocketName } ];
							if (!UInv.ItemHasPocket(BagName, ItemName)) {
								State.variables.UInvBags[BagName][ItemName].UInvPocket = {};
							}
							State.variables.UInvBags[BagName][ItemName].UInvPocket[PocketName] = PocketBagName;
							UInv.DecrementUpdateLock();
							UInv.SetCurrentBagName(PocketBagName);
							return PocketBagName;
						} else {
							UInvError('CreatePocket cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('CreatePocket failed. Pocket "' + PocketName + '" already exists on item.');  // Error
						return undefined;
					}
				} else {
					UInvError('CreatePocket cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to CreatePocket is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemPocketBagName: Returns the bag name which matches the item's pocket name, or a random pocket bag name if PocketName isn't passed.  Returns false if pocket not found or undefined on error.
		GetItemPocketBagName : function (BagName, ItemName, PocketName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {  // OOO function call
						UInv.SetCurrentBagName(BagName);
						UInv.SetCurrentItemName(ItemName);  // OOO function call
						if (UInv.ItemHasPocket(BagName, ItemName)) {
							if (UInv.isString(PocketName)) {
								if (UInv.isProperty(State.variables.UInvBags[BagName][ItemName].UInvPocket, PocketName)) {
									return State.variables.UInvBags[BagName][ItemName].UInvPocket[PocketName];  // Success - Return requested pocket bag name
								} else {
									return false;  // Success - Pocket not found
								}
							} else {
								var PocketBagName = UInv.GetItemPocketBagArray(BagName, ItemName);
								return PocketBagName.random();  // Success - Return random pocket bag name
							}
						} else {
							return false;  // Success - No pockets on item
						}
					} else {
						UInvError('GetItemPocketBagName cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemPocketBagName cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemPocketBagName is not a string.');  // Error
				return undefined;
			}
		},

		// GetPocketBagsPocketName: Returns the first PocketName which matches a pocket/bag (PocketBagName) on a particular item, or false if no match is found, or undefined on error.
		GetPocketBagsPocketName : function (BagName, ItemName, PocketBagName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {  // OOO function call
						UInv.SetCurrentBagName(BagName);
						UInv.SetCurrentItemName(ItemName);  // OOO function call
						if (UInv.ItemHasPocket(BagName, ItemName)) {
							var PocketNames = UInv.GetItemPocketNameArray(BagName, ItemName), i;
							for (i = 0; i < PocketNames.length; i++) {
								if (State.variables.UInvBags[BagName][ItemName].UInvPocket[PocketNames[i]] == PocketBagName) {
									return PocketNames[i];  // Success
								}
							}
							return false;  // Success - Pocket not found
						} else {
							return false;  // Success - No pockets on item
						}
					} else {
						UInvError('GetPocketBagsPocketName cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetPocketBagsPocketName cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetPocketBagsPocketName is not a string.');  // Error
				return undefined;
			}
		},

		// DeletePocket: Deletes the bag associated with the item's pocket name.  Returns true on success and undefined on error.
		DeletePocket : function (BagName, ItemName, PocketName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(PocketName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {  // OOO function call
						var PocketBagName = UInv.GetItemPocketBagName(BagName, ItemName, PocketName);
						if (PocketBagName) {
							UInv.SetCurrentBagName(BagName);
							UInv.SetCurrentItemName(ItemName);  // OOO function call
							return UInv.DeleteBag(PocketBagName);  // Success
						} else {
							UInvError('DeletePocket failed. PocketName "' + PocketName + '" does not exist on container.');  // Error
							return undefined;
						}
					} else {
						UInvError('DeletePocket cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('DeletePocket cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to DeletePocket is not a string.');  // Error
				return undefined;
			}
		},

		// GetAllBagPockets: Returns an array of all pockets' and sub-pockets's BagNames, plus BagName (unless NoSourceBag == true), or undefined on error.
		//                   All BagNames returned in the array will be unique within that array.
		GetAllBagPockets : function (BagName, NoSourceBag) {
			var Bags = [ BagName ], Pockets, i, j;
			if ((!UInv.isUndefined(NoSourceBag)) && (NoSourceBag == true)) {
				Bags = [];
			}
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName);  // Get a list of all items in bag  // OOO function call
					for (i = 0; i < Items.length; i++) {
						Pockets = UInv.GetItemPocketBagArray(BagName, Items[i]);  // Get all pockets on each item
						if (Pockets.length > 0) {
							Pockets = UInv.GetAllBagPockets(Pockets);  // Get all pockets within those pockets
							for (j = 0; j < Pockets.length; j++) {
								Bags.pushUnique(Pockets[j]);  // Add them all to the list if they aren't already there
							}
						}
					}
					UInv.SetCurrentBagName(BagName);
					return Bags;  // Success
				} else {
					UInvError('GetAllBagPockets cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.BagExists(BagName)) {  // Check array of all bags
					for (i = 0; i < BagName.length; i++) {
						Pockets = UInv.GetAllBagPockets(BagName[i]);  // Get all pockets within those pockets
						for (j = 0; j < Pockets.length; j++) {
							Bags.pushUnique(Pockets[j]);  // Add them all to the list if they aren't already there
						}
					}
					UInv.SetCurrentBagName(BagName[0]);
					return Bags;  // Success
				} else {
					UInvError('GetAllBagPockets failed. Invalid bag name in array.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetAllBagPockets is not a string or an array of strings.');  // Error
				return undefined;
			}
		},

		// GetAllContainerPockets: Returns an array of all pockets' and sub-pockets's BagNames, or undefined on error.  (All BagNames returned in the array will be unique within that array.)
		GetAllContainerPockets : function (ContainerBagName, ContainerName) {
			if (UInv.isString(ContainerBagName) && UInv.isString(ContainerName)) {
				ContainerBagName = FixBagName(ContainerBagName);
				ContainerName = FixItemName(ContainerName);
				if (UInv.BagExists(ContainerBagName)) {
					if (UInv.BagHasItem(ContainerBagName, ContainerName)) {  // OOO function call
						if (UInv.ItemHasPocket(ContainerBagName, ContainerName)) {
							var PocketBags = UInv.GetItemPocketBagArray(ContainerBagName, ContainerName), CurPockets, AllPockets = [], i, j;
							for (i = 0; i < PocketBags.length; i++) {
								CurPockets = UInv.GetAllBagPockets(PocketBags[i]);
								for (j = 0; j < CurPockets.length; j++) {
									AllPockets.pushUnique(CurPockets[j]);
								}
							}
							return AllPockets;  // Success
						} else {
							return [];  // Success - no pockets
						}
					} else {
						UInvError('GetAllContainerPockets cannot find item "' + ContainerName + '" in bag "' + ContainerBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetAllContainerPockets cannot find bag "' + ContainerBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetAllContainerPockets is not a string.');  // Error
				return undefined;
			}
		},

		// ContainerHasItem: Returns the total number of items named ItemName in all of container's pockets (does not include the container itself in that count), or undefined on error.
		ContainerHasItem : function (ContainerBagName, ContainerName, ItemName) {
			if (UInv.isString(ContainerBagName) && UInv.isString(ContainerName)) {
				ContainerBagName = FixBagName(ContainerBagName);
				ContainerName = FixItemName(ContainerName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(ContainerBagName)) {
					if (UInv.BagHasItem(ContainerBagName, ContainerName)) {  // OOO function call
						if (UInv.ItemHasPocket(ContainerBagName, ContainerName)) {
							var PocketBags = UInv.GetAllContainerPockets(ContainerBagName, ContainerName), i, n = 0;
							for (i = 0; i < PocketBags.length; i++) {
								n += UInv.BagHasItem(PocketBags[i], ItemName);  // OOO function call
							}
							return n;  // Success
						} else {
							return 0;  // Success - no pockets
						}
					} else {
						UInvError('ContainerHasItem cannot find item "' + ContainerName + '" in bag "' + ContainerBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ContainerHasItem cannot find bag "' + ContainerBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to ContainerHasItem is not a string.');  // Error
				return undefined;
			}
		},

		// ContainerHasPocketBag: Returns whether BagName exists anywhere within the container, or undefined on error.
		ContainerHasPocketBag : function (ContainerBagName, ContainerName, BagName) {
			if (UInv.isString(ContainerBagName) && UInv.isString(ContainerName)) {
				ContainerBagName = FixBagName(ContainerBagName);
				ContainerName = FixItemName(ContainerName);
				BagName = FixBagName(BagName);
				if (UInv.BagExists(ContainerBagName)) {
					if (UInv.BagHasItem(ContainerBagName, ContainerName)) {  // OOO function call
						if (UInv.ItemHasPocket(ContainerBagName, ContainerName)) {
							if (UInv.BagExists(BagName)) {
								var PocketBags = UInv.GetItemPocketBagArray(ContainerBagName, ContainerName), CurPockets, i;
								if (PocketBags.includes(BagName)) {
									return true;  // Success
								}
								for (i = 0; i < PocketBags.length; i++) {
									CurPockets = UInv.GetAllBagPockets(PocketBags[i]);
									if (CurPockets.includes(BagName)) {
										return true;  // Success
									}
								}
								return false;  // Success - bag not found in or on container
							} else {
								return false;  // Success - bag doesn't exist
							}
						} else {
							return false;  // Success - no pockets
						}
					} else {
						UInvError('ContainerHasPocketBag cannot find item "' + ContainerName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ContainerHasPocketBag cannot find bag "' + ContainerBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to ContainerHasPocketBag is not a string.');  // Error
				return undefined;
			}
		},

		// AddExistingBagAsPocket: Adds an existing bag as pocket to an existing item.  If the items are stacked, one of the items will get renamed and has a pocket added.
		//                         Returns the item's name on success (in case it had to be changed when unstacking occurred), or undefined on error.
		AddExistingBagAsPocket : function (BagName, ItemName, PocketName, PocketBagName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(PocketName) && UInv.isString(PocketBagName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				PocketBagName = FixBagName(PocketBagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {  // OOO function call
						if (UInv.BagExists(PocketBagName)) {
							if (!UInv.BagHasSpecificItem(PocketBagName, BagName, ItemName)) {
								if (!UInv.ItemHasPocket(BagName, ItemName, PocketName)) {
									UInv.IncrementUpdateLock();
									if (UInv.BagHasItem(BagName, ItemName) > 1) {  // Pull an item out of the stack to add a pocket to it  // OOO function call
										var NewItemName = UInv.GetUniqueItemName();  // OOO function call
										UInv.RenameItem(BagName, ItemName, NewItemName, 1);  // OOO function call
										UInv.SetBagTouched(BagName);
										ItemName = NewItemName;
									}
									// Connect pocket to item and vice versa
									State.variables.UInvBags[PocketBagName].UInvContainer = [ { ContainerBagName : BagName, ContainerName : ItemName, PocketName : PocketName } ];
									if (!UInv.ItemHasPocket(BagName, ItemName)) {
										State.variables.UInvBags[BagName][ItemName].UInvPocket = {};
									}
									State.variables.UInvBags[BagName][ItemName].UInvPocket[PocketName] = PocketBagName;
									UInv.DecrementUpdateLock();
									UInv.SetCurrentBagName(PocketBagName);
									return ItemName;
								} else {
									UInvError('AddExistingBagAsPocket failed. Pocket "' + PocketName + '" already exists on item.');  // Error
									return undefined;
								}
							} else {
								UInvError('AddExistingBagAsPocket failed. Container cannot contain itself.');  // Error
								return undefined;
							}
						} else {
							UInvError('AddExistingBagAsPocket cannot find bag "' + PocketBagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('AddExistingBagAsPocket cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('AddExistingBagAsPocket cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to AddExistingBagAsPocket is not a string.');  // Error
				return undefined;
			}
		},

		// GetContainerIndex: Returns index of container in a bag's UInvContainer array which has the pocket name of PocketName, -1 if not found, or undefined on error.
		GetContainerIndex : function (BagName, PocketName) {
			if (UInv.isString(BagName) && UInv.isString(PocketName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Containers = UInv.GetPocketBagContainerArray(BagName);
					if (Containers.length > 0) {
						var i;
						for (i = 0; i < Containers.length; i++) {
							if (Containers[i].PocketName == PocketName) {
								return i;  // Success
							}
						}
					}
					return -1;  // Success - PocketName not found
				} else {
					UInvError('GetContainerIndex cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetContainerIndex is not a string.');  // Error
				return undefined;
			}
		},

		// UnlinkPocketFromContainer: Unlinks a pocket from its container item (and vice versa).  Returns true on success, or undefined on error.
		UnlinkPocketFromContainer : function (ContainerBagName, ContainerName, PocketName) {
			if (UInv.isString(ContainerBagName) && UInv.isString(ContainerName)) {
				ContainerBagName = FixBagName(ContainerBagName);
				ContainerName = FixItemName(ContainerName);
				if (UInv.BagExists(ContainerBagName)) {
					if (UInv.BagHasItem(ContainerBagName, ContainerName)) {  // OOO function call
						if (UInv.isString(PocketName)) {  // Unlink specific pocket from container
							var PocketBagName = UInv.GetItemPocketBagName(ContainerBagName, ContainerName, PocketName);
							if (PocketBagName) {
								delete State.variables.UInvBags[ContainerBagName][ContainerName].UInvPocket[PocketName];  // Unlink pocket from container
								if (Object.keys(State.variables.UInvBags[ContainerBagName][ContainerName].UInvPocket).length == 0) {
									delete State.variables.UInvBags[ContainerBagName][ContainerName].UInvPocket;
								}
								var PocketIndex = UInv.GetContainerIndex(PocketBagName, PocketName);
								if (PocketIndex >= 0) {  // Unlink container from pocket
									State.variables.UInvBags[PocketBagName].UInvContainer.deleteAt(PocketIndex);
									if (State.variables.UInvBags[PocketBagName].UInvContainer.length == 0) {
										delete State.variables.UInvBags[PocketBagName].UInvContainer;
									}
								}
								UInv.SetCurrentBagName(ContainerBagName);
								UInv.SetCurrentItemName(ContainerName);  // OOO function call
								return true;  // Success
							} else {
								UInvError('UnlinkPocketFromContainer failed. PocketName "' + PocketName + '" does not exist on container.');  // Error
								return undefined;
							}
						} else {  // Unlink ALL pockets from container
							var Pockets = UInv.GetItemPocketBagArray(ContainerBagName, ContainerName);
							if (Pockets.length > 0) {
								var i;
								for (i = 0; i < Pockets.length; i++) {
									UInv.UnlinkPocketFromContainer(ContainerBagName, ContainerName, Pockets[i]);
								}
							}
							return true;  // Success
						}
					} else {
						UInvError('UnlinkPocketFromContainer cannot find item "' + ContainerName + '" in bag "' + ContainerBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('UnlinkPocketFromContainer cannot find bag "' + ContainerBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to UnlinkPocketFromContainer is not a string.');  // Error
				return undefined;
			}
		},

		// UnlinkPocketBagFromContainer: Unlinks a pocket from its container item (and vice versa).  Returns true on success, or undefined on error.
		UnlinkPocketBagFromContainer : function (ContainerBagName, ContainerName, PocketBagName) {
			if (UInv.isString(ContainerBagName) && UInv.isString(ContainerName) && UInv.isString(PocketBagName)) {
				ContainerBagName = FixBagName(ContainerBagName);
				ContainerName = FixItemName(ContainerName);
				if (UInv.BagExists(ContainerBagName)) {
					if (UInv.BagHasItem(ContainerBagName, ContainerName)) {  // OOO function call
						if (UInv.BagExists(PocketBagName)) {
							var PocketName = UInv.GetPocketBagsPocketName(ContainerBagName, ContainerName, PocketBagName);
							if (UInv.isString(PocketName)) {
								return UInv.UnlinkPocketFromContainer(ContainerBagName, ContainerName, PocketName);  // Success
							} else {
								UInvError('UnlinkPocketBagFromContainer failed. "' + PocketBagName + '" is not a pocket of "' + ContainerName + '" in bag "' + ContainerBagName + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('UnlinkPocketBagFromContainer cannot find bag "' + PocketBagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('UnlinkPocketBagFromContainer cannot find item "' + ContainerName + '" in bag "' + ContainerBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('UnlinkPocketBagFromContainer cannot find bag "' + ContainerBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to UnlinkPocketBagFromContainer is not a string.');  // Error
				return undefined;
			}
		},

		// MovePocket: Move a pocket from one container to another.  If the destination item is stacked, one of the items will get renamed and have a pocket added.
		//             Returns the item's name on success (in case it had to be changed when unstacking occurred), or undefined on error.
		MovePocket : function (SourceBagName, SourceItemName, SourcePocketName, DestinationBagName, DestinationItemName, DestinationPocketName) {
			if (UInv.isString(SourceBagName) && UInv.isString(SourceItemName) && UInv.isString(SourcePocketName) && UInv.isString(DestinationBagName)) {
				SourceBagName = FixBagName(SourceBagName);
				SourceItemName = FixItemName(SourceItemName);
				DestinationBagName = FixBagName(DestinationBagName);
				DestinationItemName = FixItemName(DestinationItemName);
				if (UInv.BagExists(SourceBagName)) {
					if (UInv.BagHasItem(SourceBagName, SourceItemName)) {  // OOO function call
						if (UInv.BagExists(DestinationBagName)) {
							if (UInv.BagHasItem(DestinationBagName, DestinationItemName)) {  // OOO function call
								if (UInv.ItemHasPocket(SourceBagName, SourceItemName, SourcePocketName)) {
									if (!UInv.isString(DestinationPocketName)) {
										DestinationPocketName = SourcePocketName;
									}
									if (!UInv.ItemHasPocket(DestinationBagName, DestinationItemName, DestinationPocketName)
										|| (State.variables.UInvBags[SourceBagName] === State.variables.UInvBags[DestinationBagName])) {
										// Allow exception for RenameBag() where both will reference the same object
										var PocketBagName = UInv.GetItemPocketBagName(SourceBagName, SourceItemName, SourcePocketName);
										if (UInv.BagHasSpecificItem(PocketBagName, DestinationBagName, DestinationItemName)) {
											UInvError('MovePocket failed. Source pocket cannot contain destination item.');  // Error
											return undefined;
										}
										if (UInv.UnlinkPocketFromContainer(SourceBagName, SourceItemName, SourcePocketName)) {
											return UInv.AddExistingBagAsPocket(DestinationBagName, DestinationItemName, DestinationPocketName, PocketBagName);  // Success
										}
										UInvError('MovePocket failed. Unable to unlink pocket "' + SourcePocketName + '" from item "' + SourceItemName + '" in bag "' + SourceBagName + '".');  // Error
										return undefined;  // Error - This shouldn't happen
									} else {
										UInvError('MovePocket failed. Pocket "' + DestinationPocketName + '" already exists on destination item.');  // Error
										return undefined;
									}
								} else {
									UInvError('MovePocket failed. Pocket "' + SourceItemName + '" cannot be found.');  // Error
									return undefined;
								}
							} else {
								UInvError('MovePocket cannot find item "' + DestinationItemName + '" in bag "' + DestinationBagName + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('MovePocket cannot find bag "' + DestinationBagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('MovePocket cannot find item "' + SourceItemName + '" in bag "' + SourceBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('MovePocket cannot find bag "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to MovePocket is not a string.');  // Error
				return undefined;
			}
		},

		// MoveItemFromPocket: Move an item into a pocket.  If the Quantity parameter isn't set, then move all of that item.
		MoveItemFromPocket : function (ContainerBagName, ContainerItemName, PocketName, ItemName, DestinationBagName, Quantity) {
			if (UInv.isString(ContainerBagName) && UInv.isString(ContainerItemName) && UInv.isString(PocketName) && UInv.isString(ItemName) && UInv.isString(DestinationBagName)) {
				ContainerBagName = FixBagName(ContainerBagName);
				ContainerItemName = FixItemName(ContainerItemName);
				ItemName = FixItemName(ItemName);
				DestinationBagName = FixBagName(DestinationBagName);
				if (UInv.BagExists(ContainerBagName)) {
					if (UInv.BagHasItem(ContainerBagName, ContainerItemName)) {  // OOO function call
						if (UInv.ItemHasPocket(ContainerBagName, ContainerItemName, PocketName)) {
							var PocketBagName = UInv.GetItemPocketBagName(ContainerBagName, ContainerItemName, PocketName);
							var Count = UInv.BagHasItem(PocketBagName, ItemName);  // OOO function call
							if (Count) {
								if (UInv.BagExists(DestinationBagName)) {
									if (UInv.ContainerHasPocketBag(PocketBagName, ItemName, DestinationBagName)) {
										UInvError('MoveItemFromPocket failed. Source item cannot be moved inside of itself.');  // Error
										return undefined;
									}
									Quantity = tryIntParse(Quantity);
									if (UInv.isNumber(Quantity)) {
										Quantity = Math.round(Quantity);
										if (Quantity < 1) {
											Quantity = 1;
										}
										if (Quantity > Count) {
											Quantity = Count;
										}
									} else {
										Quantity = Count;
									}
									return UInv.MoveItem(PocketBagName, DestinationBagName, ItemName, Quantity);
								} else {
									UInvError('MoveItemFromPocket cannot find bag "' + DestinationBagName + '".');  // Error
									return undefined;
								}
							} else {
								UInvError('MoveItemFromPocket cannot find item "' + ItemName + '" in pocket "' + PocketName + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('MoveItemFromPocket failed. Pocket "' + PocketName + '" cannot be found.');  // Error
							return undefined;
						}
					} else {
						UInvError('MoveItemFromPocket cannot find item "' + ContainerItemName + '" in bag "' + ContainerBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('MoveItemFromPocket cannot find bag "' + ContainerBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to MoveItemFromPocket is not a string.');  // Error
				return undefined;
			}
		},

		// MoveItemToPocket: Move an item into a pocket.  If the Quantity parameter isn't set, then move all of that item.
		MoveItemToPocket : function (SourceBagName, SourceItemName, DestinationBagName, DestinationItemName, DestinationPocketName, Quantity) {
			if (UInv.isString(SourceBagName) && UInv.isString(SourceItemName) && UInv.isString(DestinationBagName) && UInv.isString(DestinationItemName) && UInv.isString(DestinationPocketName)) {
				SourceBagName = FixBagName(SourceBagName);
				SourceItemName = FixItemName(SourceItemName);
				DestinationBagName = FixBagName(DestinationBagName);
				DestinationItemName = FixItemName(DestinationItemName);
				if (UInv.BagExists(SourceBagName)) {
					var Count = UInv.BagHasItem(SourceBagName, SourceItemName);  // OOO function call
					if (Count) {
						if (UInv.BagExists(DestinationBagName)) {
							if (UInv.BagHasItem(DestinationBagName, DestinationItemName)) {  // OOO function call
								if (UInv.ItemHasPocket(DestinationBagName, DestinationItemName, DestinationPocketName)) {
									var DestinationPocketBagName = UInv.GetItemPocketBagName(DestinationBagName, DestinationItemName, DestinationPocketName);
									if (UInv.ContainerHasPocketBag(SourceBagName, SourceItemName, DestinationPocketBagName)) {
										UInvError('MoveItemToPocket failed. Source item cannot be moved inside of itself.');  // Error
										return undefined;
									}
									Quantity = tryIntParse(Quantity);
									if (UInv.isNumber(Quantity)) {
										Quantity = Math.round(Quantity);
										if (Quantity < 1) {
											Quantity = 1;
										}
										if (Quantity > Count) {
											Quantity = Count;
										}
									} else {
										Quantity = Count;
									}
									var DestinationPocketBag = UInv.GetItemPocketBagName(DestinationBagName, DestinationItemName, DestinationPocketName);
									return UInv.MoveItem(SourceBagName, DestinationPocketBag, SourceItemName, Quantity);
								} else {
									UInvError('MoveItemToPocket failed. Pocket "' + DestinationPocketName + '" cannot be found.');  // Error
									return undefined;
								}
							} else {
								UInvError('MoveItemToPocket cannot find item "' + DestinationItemName + '" in bag "' + DestinationBagName + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('MoveItemToPocket cannot find bag "' + DestinationBagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('MoveItemToPocket cannot find item "' + SourceItemName + '" in bag "' + SourceBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('MoveItemToPocket cannot find bag "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to MoveItemToPocket is not a string.');  // Error
				return undefined;
			}
		},


		// UInv Item Functions:
		// ====================

		// GetDefaultItemObject: Returns an Item object that matches ItemType.
		// Returns "null" for unknown bag types, or undefined on error.  Both "undefined" and "null" have "falsey" values.
		GetDefaultItemObject : function (ItemType) {
			if (UInv.isString(ItemType)) {
				if ((ItemType === "") || (ItemType === "-")) {
					// Do not throw an error here.  This case is used to trigger a "null" return if the ItemType === "" or "-".
					return null;  // Silent failure
				}
				var IName = ItemType.toLowerCase();
				if (!["", "-", "uinvtouched", "uinvproperties", "uinvdefaultbagtype", "uinvcontainer"].includes(IName)) {
					var Item = UInv.ItemData(IName);
					if (UInv.isUndefined(Item)) {
						return null;  // Silent failure
					}
					if (UInv.isProperty(Item, "UInvQuantity")) {  // Item should not have a UInvQuantity property.
						delete Item.UInvQuantity;
					}
					if (UInv.isProperty(Item, "UInvDefaultItemType")) {  // Item should not have a UInvDefaultItemType property.
						delete Item.UInvDefaultItemType;
					}
					return Item;  // Success
				} else {
					UInvError('GetDefaultItemObject failed. ItemType cannot be "' + ItemType + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('ItemType passed to GetDefaultItemObject is not a string.');  // Error
				return undefined;
			}
		},

		// GetCurrentItemName: Gets the current item name if there is a valid one, otherwise returns "".
		GetCurrentItemName : function () {
			if (UInv.isProperty(State.variables, "UInvCurrentItemName")) {
				var Value = State.variables.UInvCurrentItemName;
				if (UInv.isString(Value) && !UInv.ReservedBagProperties_LC.includes(Value.toLowerCase())) {
					return Value;  // Success
				}
				delete State.variables.UInvCurrentItemName;  // delete invalid value
			}
			return "";  // Success
		},

		// SetCurrentItemName: Sets the UInvCurrentItemName to ItemName for use as the default ItemName parameter in UInv functions.  Returns true on success or undefined on error.
		SetCurrentItemName : function (ItemName) {
			if (UInv.isString(ItemName)) {
				if (ItemName === "") {
					if (UInv.isProperty(State.variables, "UInvCurrentItemName")) {
						delete State.variables.UInvCurrentItemName;
					}
				} else {
					if (!UInv.ReservedBagProperties_LC.includes(ItemName.toLowerCase())) {
						State.variables.UInvCurrentItemName = ItemName;
					} else {
						UInvError('SetCurrentItemName failed.  "' + ItemName + '" is a reserved name which cannot be used as an item name.');  // Error
						return undefined;
					}
				}
				return true;  // Success
			} else {
				UInvError('ItemName passed to SetCurrentItemName is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasItem: Returns the number of ItemName items in BagName, or undefined if there is an error.
		BagHasItem : function (BagName, ItemName) {
			if (UInv.isString(ItemName)) {
				if (UInv.isString(BagName)) {
					BagName = FixBagName(BagName);
					ItemName = FixItemName(ItemName);
					if (UInv.BagExists(BagName)) {
						UInv.SetCurrentBagName(BagName);
						if (UInv.isProperty(State.variables.UInvBags[BagName], ItemName)) {
							UInv.SetCurrentItemName(ItemName);
							if (UInv.isProperty(State.variables.UInvBags[BagName][ItemName], "UInvQuantity")) {
								return State.variables.UInvBags[BagName][ItemName].UInvQuantity;  // Success
							} else {
								return 1;  // Success - Default value of UInvQuantity = 1
							}
						} else {
							return 0;  // Not found
						}
					} else {
						UInvError('BagHasItem cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else if (UInv.isArrayOfStrings(BagName)) {
					if (UInv.BagExists(BagName)) {
						var i = 0, Result = true;
						for (i = 0; i < BagName.length; i++) {
							Result = UInv.BagHasItem(BagName[i], ItemName);
						}
						return Result;  // Success
					} else {
						UInvError('BagHasItem failed. Invalid bag name in BagName array.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName passed to BagHasItem is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('ItemName passed to BagHasItem is not a string.');  // Error
				return undefined;
			}
		},

		// ItemExists: Returns true if ItemName is in GetDefaultItem or any bags, otherwise returns false, or undefined on error.
		ItemExists : function (ItemName) {
			if (UInv.isString(ItemName)) {
				if (UInv.GetDefaultItemObject(ItemName)) {
					return true;  // Success
				}
				var Bags = UInv.GetBagsArray(), i = 0;
				if (Bags.length > 0) {
					for (i = 0; i < Bags.length; i++) {
						if (UInv.BagHasItem(Bags[i], ItemName)) {
							return true;  // Success
						}
					}
				}
				return false;  // Success - not found
			} else {
				UInvError('ItemName passed to ItemExists is not a string.');  // Error
				return undefined;
			}
		},

		// GetUniqueItemName: Generates and returns an unused item name ("itemXXHEXX").
		GetUniqueItemName : function () {
			var ItemName = "item" + UInv.getRandomHexString();
			while (UInv.ItemExists(ItemName)) {
				ItemName = "item" + UInv.getRandomHexString();
			}
			return ItemName;
		},

		// GetItemsDefaultType: Returns item's default item type if it has one, "-" if it doesn't, or undefined on error.
		GetItemsDefaultType : function (BagName, ItemName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						var ItemType = ItemName;
						if (UInv.isProperty(State.variables.UInvBags[BagName][ItemName], "UInvDefaultItemType")) {
							ItemType = State.variables.UInvBags[BagName][ItemName].UInvDefaultItemType;
						} else if (!UInv.GetDefaultItemObject(ItemType)) {
							ItemType = "-";
						}
						return ItemType;
					} else {
						UInvError('GetItemsDefaultType cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemsDefaultType cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsDefaultType is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArray: Returns an array of item names in BagName (not including UInvTouched, UInvProperties, UInvDefaultBagType, or UInvContainer), or undefined if there is an error.
		GetItemsArray : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = Object.keys(State.variables.UInvBags[BagName]), i;
					for (i = 0; i < UInv.ReservedBagProperties.length; i++) {
						Items.delete(UInv.ReservedBagProperties[i]);
					}
					UInv.SetCurrentBagName(BagName);
					return Items;  // Success
				} else {
					UInvError('GetItemsArray cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetItemsArray is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemObject: Returns an item object from BagName that matches ItemName, or undefined if there is an error.  UInvQuantity will try to be the first property on the object.
		GetItemObject : function (BagName, ItemName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						var ItemObj = UInv.GetDefaultItemObject(UInv.GetItemsDefaultType(BagName, ItemName));
						if (ItemObj && (!UInv.isProperty(ItemObj, "UInvVariableType")) && (!UInv.isProperty(State.variables.UInvBags[BagName][ItemName], "UInvVariableType"))) {
							if (UInv.isProperty(ItemObj, "UInvPocket")) {  // Don't include default pockets
								delete ItemObj.UInvPocket;
							}
							var TempObj = clone(State.variables.UInvBags[BagName][ItemName]);
							if (UInv.isProperty(TempObj, "UInvQuantity")) {
								delete TempObj.UInvQuantity;
							}
							ItemObj = Object.assign({ "UInvQuantity" : UInv.BagHasItem(BagName, ItemName) }, ItemObj, TempObj);
						} else {
							ItemObj = clone(State.variables.UInvBags[BagName][ItemName]);
							if (UInv.isProperty(ItemObj, "UInvQuantity")) {
								delete ItemObj.UInvQuantity;
							}
							ItemObj = Object.assign({ "UInvQuantity" : UInv.BagHasItem(BagName, ItemName) }, ItemObj);
						}
						UInv.SetCurrentBagName(BagName);
						UInv.SetCurrentItemName(ItemName);
						return ItemObj;  // Success
					} else {
						UInvError('GetItemObject cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemObject cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemObject is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemPropertiesArray: Returns an array of ItemName's item property names from BagName, or undefined if there is an error.  UInvQuantity will be item 0 in array.
		GetItemPropertiesArray : function (BagName, ItemName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						var ItemList = UInv.GetItemObject(BagName, ItemName), Result = [];
						UInv.SetCurrentItemName(ItemName);
						UInv.SetCurrentBagName(BagName);
						if (ItemList === undefined) {
							return undefined;  // Error
						} else {
							Result.push("UInvQuantity");
							if (UInv.isProperty(ItemList, "UInvQuantity")) {
								delete ItemList.UInvQuantity;
							}
							Result = Result.concat(Object.keys(ItemList));
							return Result;  // Success
						}
					} else {
						UInvError('GetItemPropertiesArray cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemPropertiesArray cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemPropertiesArray is not a string.');  // Error
				return undefined;
			}
		},

		// ItemHasProperty: Returns whether ItemName in BagName has ItemPropertyName, or undefined if there is an error.
		ItemHasProperty : function (BagName, ItemName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						UInv.SetCurrentItemName(ItemName);
						UInv.SetCurrentBagName(BagName);
						return UInv.GetItemPropertiesArray(BagName, ItemName).includes(ItemPropertyName);  // Success
						// You can't check State.variables.UInvBags[BagName][ItemName][ItemPropertyName] because that will not be defined for items using a DefaultItem's default property value.
					} else {
						UInvError('ItemHasProperty cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ItemHasProperty cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to ItemHasProperty is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayByProperty: Returns an array of all ItemNames in a bag that have property ItemPropertyName.
		GetItemsArrayByProperty : function (BagName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName), Result = [], i;
					UInv.SetCurrentBagName(BagName);
					for (i = 0; i < Items.length; i++) {
						if (UInv.ItemHasProperty(BagName, Items[i], ItemPropertyName)) {
							Result.push(Items[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetItemsArrayByProperty cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayByProperty is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemPropertyValue: Returns the value of ItemPropertyName if it exists, otherwise return undefined on error.
		GetItemPropertyValue : function (BagName, ItemName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						UInv.SetCurrentItemName(ItemName);
						UInv.SetCurrentBagName(BagName);
						if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
							return UInv.GetItemObject(BagName, ItemName)[ItemPropertyName];  // Success
						} else {
							UInvError('GetItemPropertyValue cannot find property "' + ItemPropertyName + '" in item "' + ItemName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('GetItemPropertyValue cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemPropertyValue cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayWherePropertyEquals: Returns an array of all items in a bag where ItemPropertyName === Value.
		GetItemsArrayWherePropertyEquals : function (BagName, ItemPropertyName, Value) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				if (arguments.length >= 3) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						var Items = UInv.GetItemsArrayByProperty(BagName, ItemPropertyName), Result = [], i = 0;
						UInv.SetCurrentBagName(BagName);
						for (i = 0; i < Items.length; i++) {
							if (UInv.valuesAreEqual(UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName), Value)) {
								Result.push(Items[i]);
							}
						}
						return Result;  // Success
					} else {
						UInvError('GetItemsArrayWherePropertyEquals cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemsArrayWherePropertyEquals failed. Value parameter is missing.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayWherePropertyEquals is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasAllItems: Returns t/f based on whether the bag has all of the items in the bag, or undefined if there is an error.
		BagHasAllItems : function (BagName, ItemArray) {
			var i = 0;
			if (UInv.isString(BagName)) {
				if (UInv.isArrayOfStrings(ItemArray)) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						UInv.SetCurrentBagName(BagName);
						for (i = 0; i < ItemArray.length; i++) {
							if (!UInv.BagHasItem(BagName, ItemArray[0])) {
								return false;  // Success - could not find an item
							}
						}
						return true;  //Success - all items found
					} else {
						UInvError('BagHasAllItems cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ItemArray passed to BagHasAllItems is not an array of strings.');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.BagExists(BagName)) {
					var Result = true;
					for (i = 0; i < BagName.length; i++) {
						Result = UInv.BagHasAllItems(BagName[i], ItemArray);
					}
					return Result;  // Success
				} else {
					UInvError('BagHasAllItems failed. Invalid bag name in BagName array.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to BagHasAllItems is not a string or array of strings.');  // Error
				return undefined;
			}
		},

		// SetItemsDefaultType: Changes an item's default item type.  Returns true on success.
		SetItemsDefaultType : function (BagName, ItemName, DefaultItemType) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(DefaultItemType)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						var DefObj = UInv.GetDefaultItemObject(DefaultItemType);
						if (DefObj || (DefaultItemType === "-")) {
							UInv.SetCurrentItemName(ItemName);
							UInv.SetCurrentBagName(BagName);
							var Item = UInv.GetItemObject(BagName, ItemName);
							if (DefaultItemType !== "-") {
								RemoveItemObjectsDefaultProperties(Item, DefaultItemType);
							}
							var VarType = UInv.isProperty(DefObj, "UInvVariableType");
							if (VarType) {
								Item.UInvVariableType = DefObj.UInvVariableType;
							}
							if ((ItemName !== DefaultItemType) || VarType) {
								Item.UInvDefaultItemType = DefaultItemType;
							}
							if ((ItemName === DefaultItemType) && (UInv.isProperty(Item, "UInvDefaultItemType")) && !VarType) {
								delete Item.UInvDefaultItemType;
							}
							delete State.variables.UInvBags[BagName][ItemName];
							State.variables.UInvBags[BagName][ItemName] = Item;
							return true;  // Success
						} else {
							UInvError('SetItemsDefaultType failed. "' + DefaultItemType + '" is not a valid default item type.');  // Error
							return undefined;
						}
					} else {
						UInvError('SetItemsDefaultType cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('SetItemsDefaultType cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to SetItemsDefaultType is not a string.');  // Error
				return undefined;
			}
		},

		// SetItemPropertyValue: Set the value of a property on an object (returns true), add that property if it doesn't exist (returns false), or return undefined if there is an error.
		//                       Removes property if the value matches the value of the GetDefaultItemObject version of this item.  Does not touch bag unless UInvQuantity changed.
		SetItemPropertyValue : function (BagName, ItemName, ItemPropertyName, Value) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						UInv.SetCurrentBagName(BagName);
						UInv.SetCurrentItemName(ItemName);
						if (arguments.length >= 4) {
							if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
								var ItemType = UInv.GetItemsDefaultType(BagName, ItemName);
								switch (ItemPropertyName) {
								case "UInvQuantity":
									if (UInv.isNumber(Value)) {
										if ((Value > 0) && (Value === Math.round(Value))) {
											if (UInv.BagHasItem(BagName, ItemName) !== Value) {
												if (Value === 1) {
													delete State.variables.UInvBags[BagName][ItemName].UInvQuantity;  // Defaults to 1
												} else {
													if (UInv.ItemHasPocket(BagName, ItemName)) {
														UInvError('SetItemPropertyValue failed on item item "' + ItemName + '" in bag "' + BagName + '". UInvQuantity cannot be above one for items with pockets.');  // Error
														return undefined;
													} else {
														State.variables.UInvBags[BagName][ItemName].UInvQuantity = Value;
													}
												}
												UInv.SetBagTouched(BagName);
											}
											return true;  // Success
										} else {
											UInvError('SetItemPropertyValue failed. UInvQuantity must be a positive integer.');  // Error
											return undefined;
										}
									} else {
										UInvError('SetItemPropertyValue failed. UInvQuantity must be a positive integer.');  // Error
									}
									return undefined;
								case "UInvDefaultItemType":
									if ((!UInv.GetDefaultItemObject(Value)) && (Value !== "-")) {
										UInvError('SetItemPropertyValue failed. When setting the UInvDefaultItemType property, the Value parameter must be a valid default item type.');  // Error
										return undefined;
									}
									return UInv.SetItemsDefaultType(BagName, ItemName, Value);
								case "UInvVariableType":
									if (UInv.isProperty(State.variables.UInvBags[BagName][ItemName], "UInvVariableType") || (ItemType === "-")) {
										State.variables.UInvBags[BagName][ItemName].UInvVariableType = Value;
									} else {  // set item's default properties
										State.variables.UInvBags[BagName][ItemName] = Object.assign({}, UInv.GetDefaultItemObject(ItemType), State.variables.UInvBags[BagName][ItemName]);
										State.variables.UInvBags[BagName].UInvDefaultItemType = ItemType;
										State.variables.UInvBags[BagName][ItemName].UInvVariableType = Value;
									}
									return true;  // Success
								case "UInvPocket":
									UInvError('SetItemPropertyValue failed. Pockets should not be manipulated directly. Use Pocket/Container functions instead.');  // Error
									return undefined;
								default:
									var Item = UInv.GetDefaultItemObject(ItemType);
									if (Item) {
										if ((UInv.isProperty(Item, ItemPropertyName)) && (!UInv.isProperty(Item, "UInvVariableType"))) {
											if (UInv.valuesAreEqual(Value, Item[ItemPropertyName])) {  // Matches default value of GetDefaultItemObject version
												if (UInv.isProperty(State.variables.UInvBags[BagName][ItemName], ItemPropertyName)) {
													delete State.variables.UInvBags[BagName][ItemName][ItemPropertyName];
												}
												return true;  // Success
											}
										}
									}
									State.variables.UInvBags[BagName][ItemName][ItemPropertyName] = Value;
									return true;  // Success
								}
							} else {
								State.variables.UInvBags[BagName][ItemName][ItemPropertyName] = Value;
								return false;  // Success
							}
						} else {
							UInvError('SetItemPropertyValue failed. Value parameter is missing.');  // Error
							return undefined;
						}
					} else {
						UInvError('SetItemPropertyValue cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('SetItemPropertyValue cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to SetItemPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// SetItemQuantity: Sets an item's quantity, returns true if successful.  Quantity must be a positive integer.
		SetItemQuantity : function (BagName, ItemName, Quantity) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						Quantity = tryIntParse(Quantity);
						if (UInv.isNumber(Quantity)) {
							if ((Quantity === Math.round(Quantity)) && (Quantity > 0)) {
								if (UInv.BagHasItem(BagName, ItemName) !== Quantity) {
									if ((UInv.ItemHasPocket(BagName, ItemName)) && (Quantity > 1)) {
										UInvError('SetItemQuantity failed on item item "' + ItemName + '" in bag "' + BagName + '". Quantity cannot be above one for items with pockets.');  // Error
										return undefined;
									}
									UInv.SetItemPropertyValue(BagName, ItemName, "UInvQuantity", Quantity);
									UInv.SetBagTouched(BagName);
								}
								return true;  // Success
							} else {
								UInvError('Quantity passed to SetItemQuantity must be a positive integer.');  // Error
								return undefined;
							}
						} else {
							UInvError('Quantity passed to SetItemQuantity is not a number.');  // Error
							return undefined;
						}
					} else {
						UInvError('SetItemQuantity cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('SetItemQuantity cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to SetItemQuantity is not a string.');  // Error
				return undefined;
			}
		},

		// DeleteItem: Deletes Quantity items from bag, returns true if successful.  Quantity is an integer, defaults to deleting all items, has a floor of 0, and a max of the item's UInvQuantity.
		//             Does not throw an error if ItemName doesn't exist, since that item is basically already deleted.
		DeleteItem : function (BagName, ItemName, Quantity) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var i = 0;
					if (UInv.isString(ItemName)) {
						ItemName = FixItemName(ItemName);
						if (!UInv.ReservedBagProperties.includes(ItemName)) {
							if (UInv.BagHasItem(BagName, ItemName)) {
								UInv.SetCurrentBagName(BagName);
								var Amt = UInv.BagHasItem(BagName, ItemName);
								if (Amt > 0) {
									Quantity = tryIntParse(Quantity);
									if (UInv.isNumber(Quantity)) {
										Quantity = Math.round(Quantity);
										if (Quantity < 0) {
											Quantity = 0;
										}
										if (Quantity > Amt) {
											Quantity = Amt;
										}
									} else {
										Quantity = Amt;
									}
									if (Quantity > 0) {
										if (Quantity === Amt) {
											var PocketNames = UInv.GetItemPocketNameArray(BagName, ItemName), PocketBag;
											if (PocketNames.length > 0) {  // Unlink all pockets.
												for (i = 0; i < PocketNames.length; i++) {
													PocketBag = UInv.GetItemPocketBagName(BagName, ItemName, PocketNames[i]);
													UInv.UnlinkPocketFromContainer(BagName, ItemName, PocketNames[i]);
													if (!UInv.BagIsPocket(PocketBag)) {  // If the pocket bag isn't a pocket anymore, delete it and all of the items inside it.
														UInv.DeleteBag(PocketBag);
													}
												}
											}
											delete State.variables.UInvBags[BagName][ItemName];  // Delete item.
											UInv.SetBagTouched(BagName);
										} else {
											UInv.SetItemQuantity(BagName, ItemName, UInv.BagHasItem(BagName, ItemName) - Quantity);
											UInv.SetBagTouched(BagName);
											UInv.SetCurrentItemName(ItemName);
										}
									} else {
										UInv.SetCurrentItemName(ItemName);
									}
									return true;  // Success
								} else {
									return true;  // Success - item already didn't exist
								}
							} else {
								UInvError('Item "' + ItemName + '" passed to DeleteItem do not exist in bag "' + BagName + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('DeleteItem failed. ItemName cannot be "' + ItemName + '".');  // Error
							return undefined;
						}
					} else if (UInv.isArrayOfStrings(ItemName)) {
						if (UInv.BagHasAllItems(BagName, ItemName)) {
							var Result = true;
							if (ItemName.length > 0) {
								for (i = 0; i < ItemName.length; i++) {
									if (!UInv.DeleteItem(BagName, ItemName[i], Quantity)) {
										Result = undefined;
									}
								}
							}
							return Result;  // Success (or Error, shouldn't happen)
						} else {
							UInvError('Some items names passed to DeleteItem do not exist in bag "' + BagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('DeleteItem failed. ItemName is not a string or an array of strings.');  // Error
						return undefined;
					}
				} else {
					UInvError('DeleteItem cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to DeleteItem is not a string.');  // Error
				return undefined;
			}
		},

		// AddToItemPropertyValue: Add an amount to a property's value (returns true), create that property if it doesn't exist (returns false), or return undefined if there is an error.
		//                         Does not touch bag unless UInvQuantity changed.  Deletes item if UInvQuantity would become <= 0.
		AddToItemPropertyValue : function (BagName, ItemName, ItemPropertyName, Amount) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (!UInv.ReservedBagProperties.includes(ItemName)) {
					if (UInv.BagExists(BagName)) {
						if (UInv.BagHasItem(BagName, ItemName)) {
							if (ItemPropertyName === "UInvDefaultItemType") {
								UInvError('AddToItemPropertyValue cannot be used to modify the value of UInvDefaultItemType. Use SetItemsDefaultType instead.');  // Error
								return undefined;
							}
							if (!UInv.isUndefined(Amount)) {
								Amount = tryIntParse(Amount);
								if (UInv.isNumber(Amount)) {
									if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
										var Value = UInv.GetItemPropertyValue(BagName, ItemName, ItemPropertyName);
										Value = tryIntParse(Value);
										if (UInv.isNumber(Value)) {
											if (ItemPropertyName === "UInvQuantity") {
												if (Amount === Math.round(Amount)) {
													if (Value + Amount > 0) {
														if ((UInv.ItemHasPocket(BagName, ItemName)) && (Value + Amount > 1)) {
															UInvError('AddToItemPropertyValue failed on item item "' + ItemName + '" in bag "' + BagName + '". Quantity cannot be set above one for items with pockets.');  // Error
															return undefined;
														}
														UInv.SetItemQuantity(BagName, ItemName, Value + Amount);
													} else {
														UInv.DeleteItem(BagName, ItemName);
													}
													UInv.SetCurrentItemName(ItemName);
													UInv.SetCurrentBagName(BagName);
													UInv.SetBagTouched(BagName);
													return true;  // Success
												} else {
													UInvError('AddToItemPropertyValue failed. Value added to UInvQuantity must be an integer.');  // Error
													return undefined;
												}
											} else {
												UInv.SetItemPropertyValue(BagName, ItemName, ItemPropertyName, Value + Amount);
												UInv.SetCurrentItemName(ItemName);
												UInv.SetCurrentBagName(BagName);
												return true;  // Success
											}
										} else {
											UInvError('AddToItemPropertyValue failed. ItemPropertyName "' + ItemPropertyName + '" is not a number.');  // Error
											return undefined;
										}
									} else {
										UInv.SetItemPropertyValue(BagName, ItemName, ItemPropertyName, Amount);
										UInv.SetCurrentItemName(ItemName);
										UInv.SetCurrentBagName(BagName);
										return false;  // Success
									}
								} else {
									UInvError('AddToItemPropertyValue failed. Amount is not a number.');  // Error
									return undefined;
								}
							} else {
								UInvError('AddToItemPropertyValue failed. Amount not defined.');  // Error
								return undefined;
							}
						} else {
							UInvError('AddToItemPropertyValue cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('AddToItemPropertyValue cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('AddToItemPropertyValue failed. ItemName cannot be "' + ItemName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to AddToItemPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// ItemsMatch: Returns whether all properties exist and match, except UInvQuantity, UInvDefaultItemType, and UInvCell.  Or returns undefined on error.
		ItemsMatch : function (BagName1, ItemName1, BagName2, ItemName2, PropertyExceptionArray) {
			if (UInv.isString(BagName1) && UInv.isString(ItemName1) && UInv.isString(BagName2) && UInv.isString(ItemName2)) {
				BagName2 = FixBagName(BagName2);
				ItemName2 = FixItemName(ItemName2);
				BagName1 = FixBagName(BagName1);
				ItemName1 = FixItemName(ItemName1);
				if (UInv.BagExists(BagName1)) {
					if (UInv.BagExists(BagName2)) {
						if (UInv.BagHasItem(BagName1, ItemName1)) {
							if (UInv.BagHasItem(BagName2, ItemName2)) {
								var Props1 = [], Props2 = [], i, Value1, Value2;
								UInv.SetCurrentItemName(ItemName1);
								UInv.SetCurrentBagName(BagName1);
								Props1 = UInv.GetItemPropertiesArray(BagName1, ItemName1);
								Props2 = UInv.GetItemPropertiesArray(BagName2, ItemName2);
								Props1.delete("UInvQuantity", "UInvDefaultItemType", "UInvCell");
								Props2.delete("UInvQuantity", "UInvDefaultItemType", "UInvCell");
								if (UInv.isString(PropertyExceptionArray)) {
									PropertyExceptionArray = [ PropertyExceptionArray ];
								}
								if (!UInv.isUndefined(PropertyExceptionArray)) {
									if (UInv.isArrayOfStrings(PropertyExceptionArray)) {
										for (i = 0; i < PropertyExceptionArray.length; i++) {
											Props1.delete(PropertyExceptionArray[i]);
											Props2.delete(PropertyExceptionArray[i]);
										}
									} else {
										UInvError('ItemsMatch failed.  When included, the PropertyExceptionArray must be a string or an array of strings.');  // Error
										return undefined;
									}
								}
								Props1 = Props1.sort();
								Props2 = Props2.sort();
								if (UInv.arraysAreEqual(Props1, Props2)) {
									for (i = 0; i < Props1.length; i++) {
										Value1 = UInv.GetItemPropertyValue(BagName1, ItemName1, Props1[i]);
										Value2 = UInv.GetItemPropertyValue(BagName2, ItemName2, Props1[i]);
										if (!UInv.valuesAreEqual(Value1, Value2)) {
											return false;  // Success
										}
									}
									return true;  // Success - all items match
								} else {
									return false;  // Success
								}
							} else {
								UInvError('ItemsMatch cannot find item "' + ItemName2 + '" in bag "' + BagName2 + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('ItemsMatch cannot find item "' + ItemName1 + '" in bag "' + BagName1 + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('ItemsMatch cannot find bag "' + BagName2 + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ItemsMatch cannot find bag "' + BagName1 + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to ItemsMatch is not a string.');  // Error
				return undefined;
			}
		},

		// GetMatchingItemsArray: Returns an array of all items in SearchBag that match ItemName (per the ItemsMatch function), not including excluded property names, or undefined on error.
		GetMatchingItemsArray : function (BagName, ItemName, SearchBag, PropertyExceptionArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						if (UInv.BagExists(SearchBag)) {
							if (UInv.isString(PropertyExceptionArray)) {
								PropertyExceptionArray = [ PropertyExceptionArray ];
							}
							if (!UInv.isUndefined(PropertyExceptionArray)) {
								if (!UInv.isArrayOfStrings(PropertyExceptionArray)) {
									UInvError('GetMatchingItemsArray failed.  When included, the PropertyExceptionArray must be a string or an array of strings.');  // Error
									return undefined;
								}
							}
							var Items = UInv.GetItemsArray(SearchBag), Result = [], i;
							UInv.SetCurrentItemName(ItemName);
							UInv.SetCurrentBagName(BagName);
							for (i = 0; i < Items.length; i++) {
								if (UInv.isUndefined(PropertyExceptionArray)) {
									if (UInv.ItemsMatch(BagName, ItemName, SearchBag, Items[i])) {
										Result.push(Items[i]);
									}
								} else {
									if (UInv.ItemsMatch(BagName, ItemName, SearchBag, Items[i], PropertyExceptionArray)) {
										Result.push(Items[i]);
									}
								}
							}
							return Result;  // Success
						} else {
							UInvError('GetMatchingItemsArray cannot find bag "' + SearchBag + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('GetMatchingItemsArray cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetMatchingItemsArray cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetMatchingItemsArray is not a string.');  // Error
				return undefined;
			}
		},

		// CopyItem: Copy item from source to destination, changing the UInvQuantity if that parameter is used.  Uses UInvMergeItemMethod to determine what happens on item collision.
		CopyItem : function (SourceBagName, DestinationBagName, ItemName, Quantity, NewItemName) {
			if (UInv.isString(SourceBagName) && UInv.isString(DestinationBagName) && UInv.isString(ItemName)) {
				SourceBagName = FixBagName(SourceBagName);
				DestinationBagName = FixBagName(DestinationBagName);
				ItemName = FixItemName(ItemName);
				if (!UInv.ReservedBagProperties.includes(ItemName)) {
					if (UInv.BagExists(SourceBagName)) {
						if (UInv.BagExists(DestinationBagName)) {
							if (UInv.BagHasItem(SourceBagName, ItemName)) {
								if ((!UInv.isUndefined(NewItemName)) || (SourceBagName !== DestinationBagName)) {
									if (UInv.isUndefined(NewItemName)) {
										NewItemName = ItemName;
									}
									if (UInv.isString(NewItemName)) {
										Quantity = tryIntParse(Quantity);
										if (UInv.isNumber(Quantity)) {
											Quantity = Math.round(Quantity);
											if (Quantity < 1) {
												Quantity = 1;
											}
										} else {
											Quantity = UInv.BagHasItem(SourceBagName, ItemName);
										}
										var Item = UInv.GetItemObject(SourceBagName, ItemName), ItemType = UInv.GetItemsDefaultType(SourceBagName, ItemName), i;
										Item.UInvQuantity = Quantity;
										if (UInv.isProperty(Item, "UInvCell")) {  // Don't copy UInvCell property
											delete Item.UInvCell;
										}
										if (UInv.ItemHasPocket(SourceBagName, ItemName)) {
											var PocketBagName, Keys = Object.keys(Item.UInvPocket);
											for (i = 0; i < Keys.length; i++) {  // Copy pockets
												PocketBagName = UInv.GetUniqueBagName();
												UInv.CopyBag(Item.UInvPocket[Keys[i]], PocketBagName);
												Item.UInvPocket[Keys[i]] = PocketBagName;
												// Bag PocketBagName will be pointing to a container that doesn't exist yet.  ContainerName is updated in "case UInv.MERGE_RENAME_SOURCE_ITEMNAME:" if needed.
												State.variables.UInvBags[PocketBagName].UInvContainer = [ { ContainerBagName : DestinationBagName, ContainerName : NewItemName, PocketName : Keys[i] } ];
											}
											Item.UInvQuantity = 1;  // Items with pockets don't stack  ***  Make more?
										}
										if (UInv.isProperty(Item, "UInvVariableType")) {
											// Search items in DestinationBagName that are of the same type to see if any are equal, and if any are, then just increment the first one's quantity.
											var ItemList = UInv.GetItemsArrayWherePropertyEquals(DestinationBagName, "UInvDefaultItemType", ItemType);
											if (ItemList.length > 0) {
												for (i = 0; i < ItemList.length; i++) {
													if (UInv.ItemsMatch(SourceBagName, ItemName, DestinationBagName, ItemList[i])) {  // Allow merge if objects match (not including UInvQuantity and UInvCell).
														UInv.AddToItemPropertyValue(DestinationBagName, ItemList[i], "UInvQuantity", Quantity);
														UInv.SetCurrentItemName(ItemList[i]);
														UInv.SetCurrentBagName(DestinationBagName);
														UInv.SetBagTouched(DestinationBagName);
														return ItemList[i];  // Success
													}
												}
											}
										}
										if (UInv.BagHasItem(DestinationBagName, NewItemName)) {
											var Result = NewItemName, SrcKeys = {}, MergeMethod = State.variables.UInvMergeItemMethod;
											if (UInv.ItemHasPocket(SourceBagName, ItemName)) {
												MergeMethod = UInv.MERGE_RENAME_SOURCE_ITEMNAME;
											} else {
												if (UInv.ItemsMatch(SourceBagName, ItemName, DestinationBagName, NewItemName)) {  // Allow merge if objects match (not including UInvQuantity and UInvCell).
													UInv.AddToItemPropertyValue(DestinationBagName, NewItemName, "UInvQuantity", Quantity);
													UInv.SetCurrentItemName(NewItemName);
													UInv.SetCurrentBagName(DestinationBagName);
													UInv.SetBagTouched(DestinationBagName);
													return Result;  // Success
												}
											}
											if (UInv.isProperty(Item, "UInvVariableType")) {
												// Variable items use UInv.MERGE_RENAME_SOURCE_ITEMNAME instead of the current merge method.
												MergeMethod = UInv.MERGE_RENAME_SOURCE_ITEMNAME;
											}
											switch (MergeMethod) {
												case UInv.MERGE_USE_ONLY_SOURCE_PROPERTIES:  // Delete the destination's properties, replace with the source's properties and values, and increment the quantity.
													Item.UInvQuantity += UInv.BagHasItem(DestinationBagName, NewItemName);
													if (!UInv.isProperty(Item, "UInvVariableType")) {
														if (ItemType !== NewItemName) {
															if ((ItemType === "-") && (!UInv.GetDefaultItemObject(NewItemName))) {
																if (UInv.isProperty(Item, "UInvDefaultItemType")) {
																	delete Item.UInvDefaultItemType;
																}
															} else {
																Item.UInvDefaultItemType = ItemType;
															}
														} else if (UInv.isProperty(Item, "UInvDefaultItemType")) {
															delete Item.UInvDefaultItemType;
														}
													}
													UInv.DeleteItem(DestinationBagName, NewItemName);  // remove destination item
													RemoveItemObjectsDefaultProperties(Item, ItemType);
													State.variables.UInvBags[DestinationBagName][NewItemName] = Item;  // overwrite destination item
													UInv.SetCurrentItemName(NewItemName);
													UInv.SetCurrentBagName(DestinationBagName);
													UInv.SetBagTouched(DestinationBagName);
													break;  // Success
												case UInv.MERGE_PREFER_DESTINATION_PROPERTIES:  // Keep the properties, values, and type in the destination, add any properties and values the source had but the destination didn't, and increment the quantity.
													UInv.AddToItemPropertyValue(DestinationBagName, NewItemName, "UInvQuantity", Quantity);
													if (UInv.isProperty(Item, "UInvDefaultItemType")) {
														delete Item.UInvDefaultItemType;
													}
													SrcKeys = Object.keys(Item);
													if (SrcKeys.length > 0) {
														for (i = 0; i < SrcKeys.length; i++) {
															if (UInv.ItemHasProperty(DestinationBagName, NewItemName, SrcKeys[i])) {
																delete Item[SrcKeys[i]];  // Delete properties from source item that are already on destination item.
															}
														}
													}
													if (Object.keys(Item).length > 0) {  // Add remaining keys to destination item
														Object.assign(State.variables.UInvBags[DestinationBagName][NewItemName], Item);
													}
													UInv.SetCurrentItemName(NewItemName);
													UInv.SetCurrentBagName(DestinationBagName);
													UInv.SetBagTouched(DestinationBagName);
													break;  // Success
												case UInv.MERGE_PREFER_SOURCE_PROPERTIES:  // Keep the properties and values in the source, add any properties and values the destination had but source the didn't, and increment the quantity.
													Item.UInvQuantity += UInv.BagHasItem(DestinationBagName, NewItemName);
													if (!UInv.isProperty(Item, "UInvVariableType")) {
														if (ItemType !== NewItemName) {
															if ((ItemType === "-") && (!UInv.GetDefaultItemObject(NewItemName))) {
																if (UInv.isProperty(Item, "UInvDefaultItemType")) {
																	delete Item.UInvDefaultItemType;
																}
															} else {
																Item.UInvDefaultItemType = ItemType;
															}
														} else if (UInv.isProperty(Item, "UInvDefaultItemType")) {
															delete Item.UInvDefaultItemType;
														}
													}
													// Delete properties from destination item that are already on source item.  This needs to be done due to default properties.
													SrcKeys = Object.keys(Item);
													for (i = 0; i < SrcKeys.length; i++) {
														if (UInv.ItemHasProperty(DestinationBagName, NewItemName, SrcKeys[i])) {
															if (UInv.isProperty(State.variables.UInvBags[DestinationBagName][NewItemName], SrcKeys[i])) {
																delete State.variables.UInvBags[DestinationBagName][NewItemName][SrcKeys[i]];
															}
														}
													}
													RemoveItemObjectsDefaultProperties(Item, ItemType);
													if (Object.keys(Item).length > 0) {
														Object.assign(State.variables.UInvBags[DestinationBagName][NewItemName], Item);  // Add keys to destination item, overwriting existing properties
													}
													UInv.SetCurrentItemName(NewItemName);
													UInv.SetCurrentBagName(DestinationBagName);
													UInv.SetBagTouched(DestinationBagName);
													break;  // Success
												case UInv.MERGE_RENAME_SOURCE_ITEMNAME:  // Rename the source's unique identifier so that it's stored separately in the destination bag.
													if (UInv.isProperty(Item, "UInvPocket")) {
														NewItemName = [];  // Don't look for matches of items that have pockets.
													} else {
														NewItemName = UInv.GetMatchingItemsArray(SourceBagName, ItemName, DestinationBagName);  // Look for matches in destination bag
														while ((NewItemName.length > 0) && (UInv.ItemHasPocket(DestinationBagName, NewItemName[0]))) {  // Make sure matches don't have pockets.
															NewItemName.shift();
														}
													}
													if (NewItemName.length == 0) {  // If there are no matches, rename item
														NewItemName = UInv.GetUniqueItemName();
														Item.UInvDefaultItemType = ItemType;
														RemoveItemObjectsDefaultProperties(Item, ItemType);
														if (Item.UInvQuantity === 1) {
															delete Item.UInvQuantity;
														}
														State.variables.UInvBags[DestinationBagName][NewItemName] = Item;  // Copy item SourceBagName/ItemName as DestinationBagName/NewItemName
													} else {  // Increase quantity of matching item
														NewItemName = NewItemName[0];
														UInv.AddToItemPropertyValue(DestinationBagName, NewItemName, "UInvQuantity", Item.UInvQuantity);  // Increase quantity of existing matching items
													}
													FixContainerReferences(SourceBagName, ItemName, DestinationBagName, NewItemName);  // Update pockets' references to match the container's new item name
													UInv.SetCurrentItemName(NewItemName);
													UInv.SetCurrentBagName(DestinationBagName);
													UInv.SetBagTouched(DestinationBagName);
													Result = NewItemName;
													break;  // Success
												case UInv.MERGE_FAIL_WITH_ERROR:  // Fail with an error.
													UInvError('CopyItem failed. Item "' + NewItemName + '" already exists in destination bag "' + DestinationBagName + '".');  // Error
													Result = undefined;
													break;
												default:  //UInv.MERGE_USE_ONLY_DESTINATION_PROPERTIES - Ignore source properties, just increment destination quantity. (default)
													UInv.AddToItemPropertyValue(DestinationBagName, NewItemName, "UInvQuantity", Quantity);
													UInv.SetCurrentItemName(NewItemName);
													UInv.SetCurrentBagName(DestinationBagName);
													UInv.SetBagTouched(DestinationBagName);
													// Success
											}
											return Result;  // Success or Error
										} else {  // Destination slot is empty, so copy item there.
											if (ItemType !== "-") {
												RemoveItemObjectsDefaultProperties(Item, ItemType);
											}
											if (!UInv.isProperty(Item, "UInvVariableType")) {
												if (NewItemName !== ItemType) {
													if ((ItemType === "-") && (!UInv.GetDefaultItemObject(NewItemName))) {
														if (UInv.isProperty(Item, "UInvDefaultItemType")) {
															delete Item.UInvDefaultItemType;
														}
													} else {
														Item.UInvDefaultItemType = ItemType;
													}
												}
												if ((NewItemName === ItemType) && (UInv.isProperty(Item, "UInvDefaultItemType"))) {
													delete Item.UInvDefaultItemType;
												}
											}
											if (Item.UInvQuantity === 1) {
												delete Item.UInvQuantity;
											}
											State.variables.UInvBags[DestinationBagName][NewItemName] = Item;
											UInv.SetCurrentItemName(NewItemName);
											UInv.SetCurrentBagName(DestinationBagName);
											UInv.SetBagTouched(DestinationBagName);
											return NewItemName;  // Success
										}
									} else {
										UInvError('NewItemName passed to CopyItem is not a string.');  // Error
										return undefined;
									}
								} else {
									UInvError('CopyItem failed. SourceBagName cannot equal DestinationBagName if NewItemName is not set.');  // Error
									return undefined;
								}
							} else {
								UInvError('CopyItem cannot find item "' + ItemName + '" in bag "' + SourceBagName + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('CopyItem cannot find destination bag "' + DestinationBagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('CopyItem cannot find source bag "' + SourceBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('CopyItem failed. ItemName cannot be "' + ItemName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to CopyItem is not a string.');  // Error
				return undefined;
			}
		},

		// MoveItem: Move item from source to destination, changing UInvQuantity if that parameter is used.  Use UInvMergeItemMethod to determine what happens on item collision.
		MoveItem : function (SourceBagName, DestinationBagName, ItemName, Quantity, NewItemName) {
			if (UInv.isString(SourceBagName) && UInv.isString(DestinationBagName) && UInv.isString(ItemName)) {
				SourceBagName = FixBagName(SourceBagName);
				DestinationBagName = FixBagName(DestinationBagName);
				ItemName = FixItemName(ItemName);
				if (!UInv.ReservedBagProperties.includes(ItemName)) {
					if (UInv.BagExists(SourceBagName)) {
						if (UInv.BagExists(DestinationBagName)) {
							if (UInv.BagHasItem(SourceBagName, ItemName)) {
								if (SourceBagName !== DestinationBagName) {
									if (UInv.ItemHasPocket(SourceBagName, ItemName)) {
										if (UInv.ContainerHasPocketBag(SourceBagName, ItemName, DestinationBagName)) {
											UInvError('MoveItem failed. Item cannot be moved inside of itself.');  // Error
											return undefined;
										}
									}
									var Count = UInv.BagHasItem(SourceBagName, ItemName);
									Quantity = tryIntParse(Quantity);
									if (UInv.isNumber(Quantity)) {
										Quantity = Math.round(Quantity);
										if (Quantity < 1) {
											Quantity = 1;
										}
										if (Quantity > Count) {
											Quantity = Count;
										}
									} else {
										Quantity = Count;
									}
									if (UInv.isUndefined(NewItemName)) {
										NewItemName = ItemName;
									} else if (UInv.isString(NewItemName)) {
										if (UInv.ReservedBagProperties.includes(NewItemName)) {
											UInvError('MoveItem failed. NewItemName cannot be "' + NewItemName + '".');  // Error
											return undefined;
										}
									} else {
										UInvError('NewItemName passed to MoveItem is not a string.');  // Error
										return undefined;
									}
									UInv.IncrementUpdateLock();
									var Result;
									if (UInv.ItemHasPocket(SourceBagName, ItemName)) {  // Move pocketed item
										if (UInv.BagHasItem(DestinationBagName, NewItemName)) {  // Rename the item if there's already an item of that name in the destination bag
											NewItemName = UInv.GetUniqueItemName();
										}
										Result = NewItemName;
										var DefaultType = UInv.GetItemsDefaultType(SourceBagName, ItemName);
										State.variables.UInvBags[DestinationBagName][NewItemName] = State.variables.UInvBags[SourceBagName][ItemName];
										delete State.variables.UInvBags[SourceBagName][ItemName];
										if (NewItemName == DefaultType) {  // Make sure UInvDefaultItemType is set appropriately
											if (UInv.isProperty(State.variables.UInvBags[DestinationBagName][NewItemName], "UInvDefaultItemType")) {
												delete State.variables.UInvBags[DestinationBagName][NewItemName].UInvDefaultItemType;
											}
										} else if (DefaultType != "-") {
											State.variables.UInvBags[DestinationBagName][NewItemName].UInvDefaultItemType = DefaultType;
										} else if (UInv.GetDefaultItemObject(DefaultType)) {
											State.variables.UInvBags[DestinationBagName][NewItemName].UInvDefaultItemType = DefaultType;
										} else if (UInv.isProperty(State.variables.UInvBags[DestinationBagName][NewItemName], "UInvDefaultItemType")) {
											delete State.variables.UInvBags[DestinationBagName][NewItemName].UInvDefaultItemType;
										}
										var Pockets = Object.keys(State.variables.UInvBags[DestinationBagName][NewItemName].UInvPocket), PocketBag, Container, i, j;
										for (i = 0; i < Pockets.length; i++) {  // Update all pockets to refer to the new container location and name
											PocketBag = State.variables.UInvBags[DestinationBagName][NewItemName].UInvPocket[Pockets[i]];
											Container = State.variables.UInvBags[PocketBag].UInvContainer;
											for (j = 0; j < Container.length; j++) {
												if ((Container[j].ContainerBagName == SourceBagName) && (Container[j].ContainerName == ItemName) && (Container[j].PocketName == Pockets[i])) {
													Container[j].ContainerBagName = DestinationBagName;
													Container[j].ContainerName = NewItemName;
												}
											}
										}
										UInv.SetBagTouched(DestinationBagName);
									} else {
										Result = UInv.CopyItem(SourceBagName, DestinationBagName, ItemName, Quantity, NewItemName);  // Deals with possible item collisions
										if (Quantity >= UInv.BagHasItem(SourceBagName, ItemName)) {
											UInv.DeleteItem(SourceBagName, ItemName);
										} else {
											UInv.AddToItemPropertyValue(SourceBagName, ItemName, "UInvQuantity", -Quantity);
										}
									}
									UInv.DecrementUpdateLock();
									UInv.SetCurrentItemName(NewItemName);
									UInv.SetCurrentBagName(DestinationBagName);
									return Result;  // Success or Error  ***
								} else {
									UInvError('MoveItem failed. SourceBagName cannot equal DestinationBagName.');  // Error
									return undefined;
								}
							} else {
								UInvError('MoveItem cannot find item "' + ItemName + '" in bag "' + SourceBagName + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('MoveItem cannot find destination bag "' + DestinationBagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('MoveItem cannot find source bag "' + SourceBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('MoveItem failed. ItemName cannot be "' + ItemName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to MoveItem is not a string.');  // Error
				return undefined;
			}
		},

		// RenameItem: Renames an item.  Optional Quantity parameter if you want to rename partial stacks, defaults to all items.
		RenameItem : function (BagName, CurrentItemName, NewItemName, Quantity) {
			if (UInv.isString(BagName) && UInv.isString(CurrentItemName) && UInv.isString(NewItemName)) {
				BagName = FixBagName(BagName);
				CurrentItemName = FixItemName(CurrentItemName);
				NewItemName = FixItemName(NewItemName);
				if ((!UInv.ReservedBagProperties.includes(CurrentItemName)) && (!UInv.ReservedBagProperties.includes(NewItemName))) {
					if (UInv.BagExists(BagName)) {
						if (UInv.BagHasItem(BagName, CurrentItemName)) {
							if (CurrentItemName === NewItemName) {
								return true;  // Success - item already has that name
							} else if (UInv.BagHasItem(BagName, NewItemName) && (State.variables.UInvMergeItemMethod === UInv.MERGE_FAIL_WITH_ERROR)) {
								UInvError('RenameItem failed. Item name "' + NewItemName + '" already exists in bag "' + BagName + '".');  // Error
								return undefined;
							} else {
								Quantity = tryIntParse(Quantity);
								if (UInv.isNumber(Quantity)) {
									Quantity = Math.round(Quantity);
									if (Quantity < 1) {
										Quantity = 1;
									}
									if (Quantity > UInv.BagHasItem(BagName, CurrentItemName)) {
										Quantity = UInv.BagHasItem(BagName, CurrentItemName);
									}
								} else {
									Quantity = UInv.BagHasItem(BagName, CurrentItemName);
								}
								var Result;
								if (UInv.ItemHasPocket(BagName, CurrentItemName)) {  // Rename pocketed item
									var DefaultType = UInv.GetItemsDefaultType(BagName, CurrentItemName);
									State.variables.UInvBags[BagName][NewItemName] = State.variables.UInvBags[BagName][CurrentItemName];
									delete State.variables.UInvBags[BagName][CurrentItemName];
									if (NewItemName == DefaultType) {  // Make sure UInvDefaultItemType is set appropriately
										if (UInv.isProperty(State.variables.UInvBags[BagName][NewItemName], "UInvDefaultItemType")) {
											delete State.variables.UInvBags[BagName][NewItemName].UInvDefaultItemType;
										}
									} else if (DefaultType != "-") {
										State.variables.UInvBags[BagName][NewItemName].UInvDefaultItemType = DefaultType;
									} else if (UInv.GetDefaultItemObject(DefaultType)) {
										State.variables.UInvBags[BagName][NewItemName].UInvDefaultItemType = DefaultType;
									} else if (UInv.isProperty(State.variables.UInvBags[BagName][NewItemName], "UInvDefaultItemType")) {
										delete State.variables.UInvBags[BagName][NewItemName].UInvDefaultItemType;
									}
									var Pockets = Object.keys(State.variables.UInvBags[BagName][NewItemName].UInvPocket), PocketBag, Container, i, j;
									for (i = 0; i < Pockets.length; i++) {  // Update all pockets to refer to the new container name
										PocketBag = State.variables.UInvBags[BagName][NewItemName].UInvPocket[Pockets[i]];
										Container = State.variables.UInvBags[PocketBag].UInvContainer;
										for (j = 0; j < Container.length; j++) {
											if ((Container[j].ContainerBagName == BagName) && (Container[j].ContainerName == CurrentItemName) && (Container[j].PocketName == Pockets[i])) {
												Container[j].ContainerName = NewItemName;
											}
										}
									}
									Result = NewItemName;
								} else {
									Result = UInv.CopyItem(BagName, BagName, CurrentItemName, Quantity, NewItemName);
									if (Result) {
										UInv.AddToItemPropertyValue(BagName, CurrentItemName, "UInvQuantity", -Quantity);
										UInv.SetCurrentItemName(Result);
										UInv.SetCurrentBagName(BagName);
									}
								}
								return Result;  // Success
							}
						} else {
							UInvError('RenameItem cannot find item "' + CurrentItemName + '" in bag "' + BagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('RenameItem cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('RenameItem failed. Item names cannot be "UInvTouched", "UInvProperties", "UInvDefaultBagType", or "UInvContainer".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to RenameItem is not a string.');  // Error
				return undefined;
			}
		},

		// GetDefaultItemPropertyValue: Returns the default value for item's property, null if property or item isn't found, or undefined if there is an error.
		GetDefaultItemPropertyValue : function (DefaultItemName, ItemPropertyName) {
			if (UInv.isString(DefaultItemName) && UInv.isString(ItemPropertyName)) {
				var DefItem = UInv.GetDefaultItemObject(DefaultItemName);
				if (DefItem) {
					if (UInv.isProperty(DefItem, ItemPropertyName)) {
						return DefItem[ItemPropertyName];  // Success
					} else {
						return null;  // Success - item not found
					}
				} else {
					return null;  // Success - item not found
				}
			} else {
				UInvError('Name passed to GetDefaultItemPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsAndQuantitiesObject: Returns an object of items and quantities in a bag in the format { item1: quantity1, item2: quantity2, etc... }, or undefined on error.
		GetItemsAndQuantitiesObject : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName), Result = {}, i = 0;
					for (i = 0; i < Items.length; i++) {
						Result[Items[i]] = UInv.BagHasItem(BagName, Items[i]);
					}
					return Result;  // Success
				} else {
					UInvError('GetItemsAndQuantitiesObject cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetItemsAndQuantitiesObject is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemCount: Returns the number of unique items in a bag (not including UInvTouched, UInvProperties, UInvDefaultBagType, or UInvContainer).
		GetItemCount : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					return UInv.GetItemsArray(BagName).length;  // Success
				} else {
					UInvError('GetItemCount cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.BagExists(BagName)) {
					var i = 0, Items = [];
					for (i = 0; i < BagName.length; i++) {
						Items = Items.concatUnique(UInv.GetItemsArray(BagName[i]));
					}
					return Items.length;  // Success
				} else {
					UInvError('GetItemCount failed. Invalid bag name in array.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetItemCount is not a string or an array of strings.');  // Error
				return undefined;
			}
		},

		// GetItemCountFull: Returns the total number of items in a bag, adding up the UInvQuantity value of each item (not including UInvTouched, UInvProperties, and UInvDefaultBagType).
		GetItemCountFull : function (BagName) {
			var Tot = 0, i = 0;
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName);
					if (Items.length > 0) {
						for (i = 0; i < Items.length; i++) {
							Tot += UInv.BagHasItem(BagName, Items[i]);
						}
					}
					return Tot;  // Success
				} else {
					UInvError('GetItemCountFull cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.BagExists(BagName)) {
					for (i = 0; i < BagName.length; i++) {
						Tot += UInv.GetItemCountFull(BagName[i]);
					}
					return Tot;  // Success
				} else {
					UInvError('GetItemCountFull failed. Invalid bag name in array.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetItemCountFull is not a string or an array of strings.');  // Error
				return undefined;
			}
		},

		// GetItemCountByDefaultType: Returns the number of unique item types in each bag (ignores Quantity), items with a default item type of "-" are each counted as separate unique item types.
		//                            Returns undefined on error.
		GetItemCountByDefaultType : function (BagName, IgnoreTypes) {
			var Tot = 0, i = 0;
			if (UInv.isString(BagName)) {
				if (UInv.isUndefined(IgnoreTypes)) {
					IgnoreTypes = [];
				}
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), Typ;
					if (Items.length > 0) {
						if (!UInv.isArray(IgnoreTypes)) {
							IgnoreTypes = [];
						}
						for (i = 0; i < Items.length; i++) {
							Typ = UInv.GetItemsDefaultType(BagName, Items[i]);
							if (Typ === "-") {
								++Tot;
							} else if (IgnoreTypes.indexOf(Typ) < 0) {
								IgnoreTypes.push(Typ);
								++Tot;
							}
						}
					}
					return Tot;  // Success
				} else {
					UInvError('GetItemCountByDefaultType cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.BagExists(BagName)) {
					var Ign = [];
					for (i = 0; i < BagName.length; i++) {
						Tot += UInv.GetItemCountByDefaultType(BagName[i], Ign);
					}
					return Tot;  // Success
				} else {
					UInvError('GetItemCountByDefaultType failed. Invalid bag name in array.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetItemCountByDefaultType is not a string or an array of strings.');  // Error
				return undefined;
			}
		},

		// GetItemCountFullByDefaultType: Returns the total number of items in bag(s) (Quantity included) of that DefaultItemType.  Returns undefined on error.
		GetItemCountFullByDefaultType : function (BagName, DefaultItemType) {
			if (UInv.isString(DefaultItemType)) {
				var Tot = 0, i = 0;
				if (UInv.isString(BagName)) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						UInv.SetCurrentBagName(BagName);
						var Items = UInv.GetItemsArray(BagName);
						if (Items.length > 0) {
							for (i = 0; i < Items.length; i++) {
								if (UInv.GetItemsDefaultType(BagName, Items[i]) === DefaultItemType) {
									Tot += UInv.BagHasItem(BagName, Items[i]);
								}
							}
						}
						return Tot;  // Success
					} else {
						UInvError('GetItemCountFullByDefaultType cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else if (UInv.isArrayOfStrings(BagName)) {
					if (UInv.BagExists(BagName)) {
						for (i = 0; i < BagName.length; i++) {
							Tot += UInv.GetItemCountFullByDefaultType(BagName[i], DefaultItemType);
						}
						return Tot;  // Success
					} else {
						UInvError('GetItemCountFullByDefaultType failed. Invalid bag name in array.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName passed to GetItemCountFullByDefaultType is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('DefaultItemType passed to GetItemCountFullByDefaultType is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayByType: Returns an array of all ItemNames in a bag that are of type ItemType.
		GetItemsArrayByType : function (BagName, ItemType) {
			if (UInv.isString(BagName) && UInv.isString(ItemType)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName), Result = [], i;
					UInv.SetCurrentBagName(BagName);
					for (i = 0; i < Items.length; i++) {
						if (UInv.GetItemPropertyValue(BagName, Items[i], "UInvDefaultItemType") == ItemType) {
							Result.push(Items[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetItemsArrayByType cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayByType is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemCountWherePropertyEquals: Gets the numer of items in a bag which have a particular property value.
		GetItemCountWherePropertyEquals : function (BagName, ItemPropertyName, Value) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (arguments.length >= 3) {
						UInv.SetCurrentBagName(BagName);
						return UInv.GetItemsArrayWherePropertyEquals(BagName, ItemPropertyName, Value).length;  // Success
					} else {
						UInvError('GetItemCountWherePropertyEquals failed. Value parameter is missing.');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemCountWherePropertyEquals cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.BagExists(BagName)) {
					if (arguments.length >= 3) {
						var i = 0, Items = [];
						for (i = 0; i < BagName.length; i++) {
							Items = Items.concatUnique(UInv.GetItemsArray(BagName[i]));
						}
						return Items.length;  // Success
					} else {
						UInvError('GetItemCountWherePropertyEquals failed. Value parameter is missing.');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemCountWherePropertyEquals failed. Invalid bag name in array.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetItemCountWherePropertyEquals is not a string or an array of strings.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayWherePropertyGreaterThan: Returns an array of all items in a bag where ItemPropertyName > Value.
		GetItemsArrayWherePropertyGreaterThan : function (BagName, ItemPropertyName, Value) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				if (arguments.length >= 3) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						var Items = UInv.GetItemsArrayByProperty(BagName, ItemPropertyName), Result = [], i = 0;
						UInv.SetCurrentBagName(BagName);
						for (i = 0; i < Items.length; i++) {
							if (UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName) > Value) {
								Result.push(Items[i]);
							}
						}
						return Result;  // Success
					} else {
						UInvError('GetItemsArrayWherePropertyGreaterThan cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemsArrayWherePropertyGreaterThan failed. Value parameter is missing.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayWherePropertyGreaterThan is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemCountWherePropertyGreaterThan: Gets the numer of items in a bag which have a particular property value greater than Value.
		GetItemCountWherePropertyGreaterThan : function (BagName, ItemPropertyName, Value) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (arguments.length >= 3) {
						UInv.SetCurrentBagName(BagName);
						return UInv.GetItemsArrayWherePropertyGreaterThan(BagName, ItemPropertyName, Value).length;  // Success
					} else {
						UInvError('GetItemCountWherePropertyGreaterThan failed. Value parameter is missing.');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemCountWherePropertyGreaterThan cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.BagExists(BagName)) {
					if (arguments.length >= 3) {
						var i = 0, Items = [];
						for (i = 0; i < BagName.length; i++) {
							Items = Items.concatUnique(UInv.GetItemsArray(BagName[i]));
						}
						return Items.length;  // Success
					} else {
						UInvError('GetItemCountWherePropertyGreaterThan failed. Value parameter is missing.');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemCountWherePropertyGreaterThan failed. Invalid bag name in array.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetItemCountWherePropertyGreaterThan is not a string or an array of strings.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayWherePropertyLessThan: Returns an array of all items in a bag where ItemPropertyName > Value.
		GetItemsArrayWherePropertyLessThan : function (BagName, ItemPropertyName, Value) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				if (arguments.length >= 3) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						var Items = UInv.GetItemsArrayByProperty(BagName, ItemPropertyName), Result = [], i = 0;
						UInv.SetCurrentBagName(BagName);
						for (i = 0; i < Items.length; i++) {
							if (UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName) < Value) {
								Result.push(Items[i]);
							}
						}
						return Result;  // Success
					} else {
						UInvError('GetItemsArrayWherePropertyLessThan cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemsArrayWherePropertyLessThan failed. Value parameter is missing.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayWherePropertyLessThan is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemCountWherePropertyLessThan: Gets the numer of items in a bag which have a particular property value less than Value.
		GetItemCountWherePropertyLessThan : function (BagName, ItemPropertyName, Value) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (arguments.length >= 3) {
						UInv.SetCurrentBagName(BagName);
						return UInv.GetItemsArrayWherePropertyLessThan(BagName, ItemPropertyName, Value).length;  // Success
					} else {
						UInvError('GetItemCountWherePropertyLessThan failed. Value parameter is missing.');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemCountWherePropertyLessThan cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.BagExists(BagName)) {
					if (arguments.length >= 3) {
						var i = 0, Items = [];
						for (i = 0; i < BagName.length; i++) {
							Items = Items.concatUnique(UInv.GetItemsArray(BagName[i]));
						}
						return Items.length;  // Success
					} else {
						UInvError('GetItemCountWherePropertyLessThan failed. Value parameter is missing.');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemCountWherePropertyLessThan failed. Invalid bag name in array.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetItemCountWherePropertyLessThan is not a string or an array of strings.');  // Error
				return undefined;
			}
		},

		// GetUniqueItemPropertyValuesArray: Returns an array of unique (string, number, and boolean) values for all items with ItemPropertyName in all bags in BagName/Array, or undefined on error.
		//                                   (use GetUniqueItemTagsArray instead for properties which have array values)
		GetUniqueItemPropertyValuesArray : function (BagName, ItemPropertyName) {
			var i = 0, Items = [];
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Result = [], Value;
					Items = UInv.GetItemsArray(BagName);
					if (Items.length > 0) {
						for (i = 0; i < Items.length; i++) {
							if (UInv.ItemHasProperty(BagName, Items[i], ItemPropertyName)) {
								Value = UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName);
								if (UInv.isString(Value) || UInv.isNumber(Value) || UInv.isBoolean(Value)) {
									Result.push(Value);
								}
							}
						}
					}
					return [].concatUnique(Result);  // Success
				} else {
					UInvError('GetUniqueItemPropertyValuesArray cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.BagExists(BagName)) {
					for (i = 0; i < BagName.length; i++) {
						Items = Items.concatUnique(UInv.GetUniqueItemPropertyValuesArray(BagName[i], ItemPropertyName));
					}
					return Items;  // Success
				} else {
					UInvError('GetUniqueItemPropertyValuesArray failed. Invalid bag name in array.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetUniqueItemPropertyValuesArray is not a string or an array of strings.');  // Error
				return undefined;
			}
		},

		// BagHasAnyItem: Returns t/f based on whether the bag has any of the items in the bag, or undefined if there is an error.
		BagHasAnyItem : function (BagName, ItemArray) {
			var i = 0;
			if (UInv.isString(BagName)) {
				if (UInv.isArrayOfStrings(ItemArray)) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						UInv.SetCurrentBagName(BagName);
						for (i = 0; i < ItemArray.length; i++) {
							if (UInv.BagHasItem(BagName, ItemArray[0])) {
								return true;  // Success - found an item in the bag
							}
						}
						return false;  //Success - no items found
					} else {
						UInvError('BagHasAnyItem cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ItemArray passed to BagHasAnyItem is not an array of strings.');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.BagExists(BagName)) {
					var Result = true;
					for (i = 0; i < BagName.length; i++) {
						Result = UInv.BagHasAnyItem(BagName[i], ItemArray);
					}
					return Result;  // Success
				} else {
					UInvError('BagHasAnyItem failed. Invalid bag name in BagName array.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to BagHasAnyItem is not a string or array of strings.');  // Error
				return undefined;
			}
		},

		// AddToAllItemsPropertyValue: Adds an amount to a property's value for all of a bag's items which have the property (returns true), or undefined on error.
		//                             Does not touch bag unless UInvQuantity changed.  Deletes item if UInvQuantity would become <= 0.
		AddToAllItemsPropertyValue : function (BagName, ItemPropertyName, Amount) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (ItemPropertyName === "UInvDefaultItemType") {
						UInvError('AddToAllItemsPropertyValue cannot be used to modify the value of UInvDefaultItemType. Use SetItemsDefaultType instead.');  // Error
						return undefined;
					}
					if (!UInv.isUndefined(Amount)) {
						Amount = tryIntParse(Amount);
						if (UInv.isNumber(Amount)) {
							if ((ItemPropertyName === "UInvQuantity") && (Amount !== Math.round(Amount))) {
								UInvError('AddToAllItemsPropertyValue failed. Value added to UInvQuantity must be an integer.');  // Error
								return undefined;
							} else {
								Amount = Math.round(Amount);
							}
							var Items = UInv.GetItemsArray(BagName), i;
							if ((ItemPropertyName === "UInvQuantity") && (UInv.GetAllBagPockets().length > 1)) {
								UInvError('AddToAllItemsPropertyValue failed. Items with pockets cannot have their quantity increased.');  // Error
								return undefined;
							}
							// pre-error check here ***
							for (i = 0; i < Items.length; i++) {
								UInv.AddToItemPropertyValue(BagName, Items[i], ItemPropertyName, Amount);
							}
							UInv.SetCurrentBagName(BagName);
							return true;  // Success
						} else {
							UInvError('AddToAllItemsPropertyValue failed. Amount is not a number.');  // Error
							return undefined;
						}
					} else {
						UInvError('AddToAllItemsPropertyValue failed. Amount not defined.');  // Error
						return undefined;
					}
				} else {
					UInvError('AddToAllItemsPropertyValue cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to AddToAllItemsPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// AddItem: Adds item to bag, returns true if successful.  Quantity defaults to 1.  Use UInvMergeItemMethod to determine what happens on item collision.
		AddItem : function (BagName, ItemType, Quantity, NewItemName, StartDepth, CurrentDepth) {
			if (UInv.isString(BagName) && UInv.isString(ItemType)) {
				BagName = FixBagName(BagName);
				if (!UInv.isUndefined(ValidateItemName(ItemType))) {
					ItemType = FixItemName(ItemType);
					if (UInv.isUndefined(Quantity)) {
						Quantity = 1;
					} else {
						Quantity = tryIntParse(Quantity);
						if (!UInv.isNumber(Quantity)) {
							UInvError('Quantity passed to AddItem is not a number.');  // Error
							return undefined;
						}
					}
					if ((Quantity !== Math.round(Quantity)) || (Quantity <= 0)) {
						UInvError('Quantity passed to AddItem must be a positive integer.');  // Error
						return undefined;
					}
					if (UInv.BagExists(BagName)) {
						if (UInv.isUndefined(StartDepth)) {
							StartDepth = UInv.GetPocketDepth(BagName);
						}
						if (UInv.isUndefined(CurrentDepth)) {
							CurrentDepth = StartDepth;
						}
						var Item = UInv.GetDefaultItemObject(ItemType), TempBag = "", Result;
						if (Item) {
							if (UInv.isProperty(Item, "UInvPocket")) {
								Quantity = 1;  // Items with pockets don't stack  ***  Make more?
							}
							Item.UInvQuantity = Quantity;
							if (UInv.isProperty(Item, "UInvVariableType")) {
								Item.UInvDefaultItemType = ItemType;
							}
							if (UInv.isUndefined(NewItemName)) {
								NewItemName = ItemType;
							} else if (UInv.isString(NewItemName)) {
								NewItemName = FixItemName(NewItemName);
								if (UInv.isUndefined(NewItemName)) {
									return undefined;  // Error
								}
							} else {
								UInvError('AddItem failed. NewItemName is not a string.');  // Error
								return undefined;
							}
							UInv.IncrementUpdateLock();  // Prevent unnecessary updates
							TempBag = UInv.GetUniqueBagName();
							UInv.CreateBag(TempBag);
							if (Item.UInvQuantity === 1) {
								delete Item.UInvQuantity;
							}
							State.variables.UInvBags[TempBag][ItemType] = Item;
							if (UInv.isProperty(Item, "UInvPocket")) {  // Create actual pockets on item
								var Pockets = Item.UInvPocket, Keys = Object.keys(Pockets), i;
								var NotVarType = !UInv.isProperty(State.variables.UInvBags[TempBag][ItemType], "UInvVariableType");
								if (NotVarType) {
									State.variables.UInvBags[TempBag][ItemType].UInvVariableType = "x";  // Temporarily make it a variable type so default pockets don't show for GetItemObject
								}
								delete State.variables.UInvBags[TempBag][ItemType].UInvPocket;
								for (i = 0; i < Keys.length; i++) {
									if (["-", ""].includes(Pockets[Keys[i]])) {
										UInv.CreatePocket(TempBag, ItemType, Keys[i]);
									} else if (!UInv.AddPocket(TempBag, ItemType, Keys[i], Pockets[Keys[i]], StartDepth, CurrentDepth)) {
										if (UInv.isProperty(State.variables.UInvBags[TempBag][ItemType], "UInvPocket")) {
											delete State.variables.UInvBags[TempBag][ItemType].UInvPocket;
										}
										UInv.DeleteBag(TempBag);
										UInv.DecrementUpdateLock();
										UInvError('AddItem failed. ItemType "' + ItemType + '" has an invalid bag/pocket type of "' + Pockets[Keys[i]] + '".');  // Error
										return undefined;
									}
								}
								if (NotVarType) {
									delete State.variables.UInvBags[TempBag][ItemType].UInvVariableType;  // Make it not a variable type, the way it should be
								}
							}
							Result = UInv.MoveItem(TempBag, BagName, ItemType, Quantity, NewItemName);  // Deals with possible item collisions
							UInv.DeleteBag(TempBag);
							RemoveItemObjectsDefaultProperties(State.variables.UInvBags[BagName][Result], ItemType);
							UInv.SetCurrentBagName(BagName);
							UInv.SetCurrentItemName(ItemType);
							UInv.DecrementUpdateLock();
							return Result;  // Success
						} else {
							UInvError('AddItem failed. ItemType "' + ItemType + '" is not a default item.');  // Error
							return undefined;
						}
					} else {
						UInvError('AddItem cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('AddItem failed. ItemType cannot be "' + ItemType + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to AddItem is not a string.');  // Error
				return undefined;
			}
		},

		// AddItems: Adds an array of items to bag (Quantity = 1 for each), returns true if all items are successfully added.
		AddItems : function (BagName, ItemArray) {
			if (UInv.isString(BagName)) {
				if (UInv.isArrayOfStrings(ItemArray)) {
					var Result = [], Ret, i;
					BagName = FixBagName(BagName);
					if (ItemArray.length > 0) {
						for (i = 0; i < ItemArray.length; i++) {
							Ret = UInv.AddItem(BagName, ItemArray[i]);
							if (Ret === undefined) {
								Result = undefined;
							} else if (!UInv.isBoolean(Result)) {
								Result.push(Ret);
							}
						}
						return Result;  // Success or Error  ***
					} else {
						UInvError('ItemArray passed to AddItems is empty.');  // Error
						return undefined;
					}
				} else {
					UInvError('ItemArray passed to AddItems is not an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to AddItems is not a string.');  // Error
				return undefined;
			}
		},

		// CreateItem: Creates an item without linking to a DefaultItemObject.  Quantity defaults to 1.
		CreateItem : function (BagName, ItemName, Quantity) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				if (!UInv.isUndefined(ValidateItemName(ItemName))) {
					ItemName = FixItemName(ItemName);
					if (UInv.BagExists(BagName)) {
						if (UInv.BagHasItem(BagName, ItemName)) {
							UInvError('CreateItem failed. Item "' + ItemName + '" already exists in bag "' + BagName + '".');  // Error
							return undefined;
						} else {
							if (UInv.isUndefined(Quantity)) {
								Quantity = 1;
							} else {
								Quantity = tryIntParse(Quantity);
								if (!UInv.isNumber(Quantity)) {
									UInvError('Quantity passed to CreateItem is not a number.');  // Error
									return undefined;
								}
							}
							if ((Quantity === Math.round(Quantity)) && (Quantity > 0)) {
								State.variables.UInvBags[BagName][ItemName] = {};
								if (Quantity > 1) {
									State.variables.UInvBags[BagName][ItemName].UInvQuantity = Quantity;
								}
								if (UInv.GetDefaultItemObject(ItemName)) {
									State.variables.UInvBags[BagName][ItemName].UInvDefaultItemType = "-";
								}
								UInv.SetBagTouched(BagName);
								UInv.SetCurrentBagName(BagName);
								UInv.SetCurrentItemName(ItemName);
								return ItemName;  // Success
							} else {
								UInvError('Quantity passed to CreateItem must be a positive integer.');  // Error
								return undefined;
							}
						}
					} else {
						UInvError('CreateItem cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('CreateItem failed. ItemName "' + ItemName + '" is not an allowed item name.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to CreateItem is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemPropertyCount: Returns the number of ItemName's item properties from BagName (including UInvQuantity and UInvDefaultItemType), or undefined if there is an error.
		GetItemPropertyCount : function (BagName, ItemName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						UInv.SetCurrentItemName(ItemName);
						UInv.SetCurrentBagName(BagName);
						return Object.keys(UInv.GetItemObject(BagName, ItemName)).length;  // Success
					} else {
						UInvError('GetItemPropertyCount cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemPropertyCount cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemPropertyCount is not a string.');  // Error
				return undefined;
			}
		},

		// SetItemsPropertyValue: Set the value of ItemPropertyName to Value for all items in BagName.
		SetItemsPropertyValue : function (BagName, ItemPropertyName, Value) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				if (UInv.BagExists(BagName)) {
					if (arguments.length >= 3) {
						var Items = UInv.GetItemsArray(BagName);
						if (Items.length > 0) {
							var i = 0;
							for (i = 0; i < Items.length; i++) {
								UInv.SetItemPropertyValue(BagName, Items[i], ItemPropertyName, Value);
							}
						}
						return true;  // Success
					} else {
						UInvError('SetItemsPropertyValue failed. Value parameter is missing.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName "' + BagName + '" passed to SetItemsPropertyValue does not exist.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to SetItemsPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// SetItemPropertyValues: Sets multiple property values on an item, creating those properties if they don't already exist.
		SetItemPropertyValues : function (BagName, ItemName, ValuesObject) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						if (UInv.isGenericObject(ValuesObject)) {
							var Props = Object.keys(ValuesObject), Result = true;
							if (Props.length > 0) {
								var i = 0;
								for (i = 0; i < Props.length; i++) {
									// Do some checking to make sure values are valid first  ***
									if (UInv.SetItemPropertyValue(BagName, ItemName, Props[i], ValuesObject[Props[i]]) === undefined) {
										Result = undefined;
									}
								}
							}
							UInv.SetCurrentItemName(ItemName);
							UInv.SetCurrentBagName(BagName);
							return Result;  // Success or Error  ***
						} else {
							UInvError('ValuesObject passed to SetItemPropertyValues is not a generic object.');  // Error
							return undefined;
						}
					} else {
						UInvError('SetItemPropertyValues cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName "' + BagName + '" passed to SetItemPropertyValues does not exist.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to SetItemPropertyValues is not a string.');  // Error
				return undefined;
			}
		},

		// ItemPropertyHasValue: Returns true if item's property ===/contains Value, false if it doesn't, otherwise return undefined on error.
		ItemPropertyHasValue : function (BagName, ItemName, ItemPropertyName, Value) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						UInv.SetCurrentItemName(ItemName);
						UInv.SetCurrentBagName(BagName);
						if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
							if (arguments.length >= 4) {
								var Val = UInv.GetItemPropertyValue(BagName, ItemName, ItemPropertyName);
								if (typeof(Val) === typeof(Value)) {
									return UInv.valuesAreEqual(Val, Value);  // Success
								} else if (UInv.isArray(Val)) {
									return Val.includes(Value);  // Success
								} else {
									return false;  // Success
								}
							} else {
								UInvError('ItemPropertyHasValue failed. Value parameter is missing.');  // Error
								return undefined;
							}
						} else {
							UInvError('ItemPropertyHasValue cannot find property "' + ItemPropertyName + '" in item "' + ItemName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('ItemPropertyHasValue cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ItemPropertyHasValue cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to ItemPropertyHasValue is not a string.');  // Error
				return undefined;
			}
		},

		// CopyItemsByProperty: Copy all items from SourceBagName to DestinationBagName that have the ItemPropertyName, or ItemPropertyName === Value if Value is passed.
		CopyItemsByProperty : function (SourceBagName, DestinationBagName, ItemPropertyName, Value) {
			if (UInv.isString(SourceBagName) && UInv.isString(DestinationBagName) && UInv.isString(ItemPropertyName)) {
				SourceBagName = FixBagName(SourceBagName);
				DestinationBagName = FixBagName(DestinationBagName);
				if (UInv.BagExists(SourceBagName)) {
					if (UInv.BagExists(DestinationBagName)) {
						if (SourceBagName !== DestinationBagName) {
							if (arguments.length >= 4) {
								var Items = [], Result = [];
								if (UInv.isUndefined(Value)) {
									Items = UInv.GetItemsArrayByProperty(SourceBagName, ItemPropertyName);
								} else {
									Items = UInv.GetItemsArrayWherePropertyEquals(SourceBagName, ItemPropertyName, Value);
								}
								if (Items.length > 0) {
									var i = 0, Ret = "";
									for (i = 0; i < Items.length; i++) {
										Ret = UInv.CopyItem(SourceBagName, DestinationBagName, Items[i]);
										if (Ret === undefined) {
											Result = undefined;
										} else if (!UInv.isBoolean(Result)) {
											Result.push(Ret);
										}
									}
								}
								return Result;  // Success or Error  ***
							} else {
								UInvError('CopyItemsByProperty failed. Value parameter is missing.');  // Error
								return undefined;
							}
						} else {
							UInvError('CopyItemsByProperty failed. Source and destination bags cannot be the same.');  // Error
							return undefined;
						}
					} else {
						UInvError('CopyItemsByProperty cannot find bag "' + DestinationBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('CopyItemsByProperty cannot find bag "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to CopyItemsByProperty is not a string.');  // Error
				return undefined;
			}
		},

		// DeleteItemsByProperty: Delete all items from BagName that have the ItemProperty, or ItemProperty === Value if Value is passed.
		DeleteItemsByProperty : function (BagName, ItemPropertyName, Value) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = [];
					if (arguments.length >= 3) {
						Items = UInv.GetItemsArrayWherePropertyEquals(BagName, ItemPropertyName, Value);
					} else {
						Items = UInv.GetItemsArrayByProperty(BagName, ItemPropertyName);
					}
					return UInv.DeleteItem(BagName, Items);  // Success
				} else {
					UInvError('DeleteItemsByProperty cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to DeleteItemsByProperty is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemWithHighestPropertyValue: Returns the ItemName with the highest value of ItemPropertyName in BagName (items without ItemPropertyName are ignored),
		//                                  randomly picks one of the highest if multiple items are tied for highest, "" if none found, or undefined on error.
		GetItemWithHighestPropertyValue : function (BagName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArrayByProperty(BagName, ItemPropertyName);
					if (Items.length > 0) {
						var HiItems = [ Items[0] ], HiVal = UInv.GetItemPropertyValue(BagName, Items[0], ItemPropertyName);
						if (Items.length > 1) {
							var i, Value = 0;
							for (i = 1; i < Items.length; i++) {
								Value = UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName);
								if (Value > HiVal) {
									HiVal = Value;
									HiItems = [ Items[i] ];
								} else if (Value === HiVal) {
									HiItems.push(Items[i]);
								}
							}
						}
						UInv.SetCurrentBagName(BagName);
						return HiItems.random();  // Success
					} else {
						return "";  // Success - Not found
					}
				} else {
					UInvError('GetItemWithHighestPropertyValue cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemWithHighestPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemWithLowestPropertyValue: Returns the ItemName with the lowest value of ItemPropertyName in BagName (items without ItemPropertyName are ignored),
		//                                 randomly picks one of the lowest if multiple items are tied for lowest, "" if none found, or undefined on error.
		GetItemWithLowestPropertyValue : function (BagName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArrayByProperty(BagName, ItemPropertyName);
					if (Items.length > 0) {
						var LoItems = [ Items[0] ], LoVal = UInv.GetItemPropertyValue(BagName, Items[0], ItemPropertyName);
						if (Items.length > 1) {
							var i, Value = 0;
							for (i = 1; i < Items.length; i++) {
								Value = UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName);
								if (Value < LoVal) {
									LoVal = Value;
									LoItems = [ Items[i] ];
								} else if (Value === LoVal) {
									LoItems.push(Items[i]);
								}
							}
						}
						UInv.SetCurrentBagName(BagName);
						return LoItems.random();  // Success
					} else {
						return "";  // Success - Not found
					}
				} else {
					UInvError('GetItemWithLowestPropertyValue cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemWithLowestPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// GetRandomItemPropertyValue: Returns the value of ItemPropertyName for a random item in BagName (items without ItemPropertyName are ignored), "" if none found, or undefined on error.
		GetRandomItemPropertyValue : function (BagName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArrayByProperty(BagName, ItemPropertyName);
					if (Items.length > 0) {
						return UInv.GetItemPropertyValue(BagName, Items.random(), ItemPropertyName);  // Success
					} else {
						return "";  // Success - Not found
					}
				} else {
					UInvError('GetRandomItemPropertyValue cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetRandomItemPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// GetTotalItemPropertyValue: Returns the total of all items' ItemPropertyName values (multiplied by UInvQuantity) added together
		//                            (all values must be numbers; items without ItemPropertyName are treated as having a value of zero)
		GetTotalItemPropertyValue : function (BagName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArrayByProperty(BagName, ItemPropertyName), i = 0, Value = 0, Result = 0;
					if (Items.length > 0) {
						for (i = 1; i < Items.length; i++) {
							if (UInv.ItemHasProperty(BagName, Items[i], ItemPropertyName)) {
								Value = UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName);
								if (UInv.isNumber(Value)) {
									Result += (Value * UInv.BagHasItem(BagName, Items[i]));
								} else {
									UInvError('GetTotalItemPropertyValue failed. All values of ItemPropertyName must be numbers. ("' + Items[i] + '.' + ItemPropertyName + '" is type ' + (typeof Value)  + ')');  // Error
									return undefined;
								}
							}
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetTotalItemPropertyValue cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetTotalItemPropertyValue is not a string.');  // Error
				return undefined;
			}
		},

		// DeleteItemProperty: Deletes item property ItemPropertyName.  If ItemPropertyName is not passed, then delete all properties on ItemName, except UInvQuantity, and set UInvDefaultItemType to "-".
		//                     Cannot delete UInvQuantity, UInvDefaultItemType, or UInvPocket.  Returns true if successful, otherwise false.
		DeleteItemProperty : function (BagName, ItemName, ItemPropertyName) {
			if (UInv.isString(ItemName)) {
				if (UInv.isString(BagName)) {
					BagName = FixBagName(BagName);
					ItemName = FixItemName(ItemName);
					if (UInv.BagExists(BagName)) {
						var Quantity = UInv.BagHasItem(BagName, ItemName), Item;
						if (Quantity) {
							if (UInv.isString(ItemPropertyName)) {
								UInv.SetCurrentItemName(ItemName);
								UInv.SetCurrentBagName(BagName);
								if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
									if (UInv.ReservedItemProperties.includes(ItemPropertyName)) {
										UInvError('DeleteItemProperty cannot delete property "' + ItemPropertyName + '". This is a protected property.');  // Error
										return undefined;
									}
									if (!UInv.isProperty(State.variables.UInvBags[BagName][ItemName], ItemPropertyName)) {  // Change item type to "-" so it can remove default properties
										UInv.SetItemsDefaultType(BagName, ItemName, "-");
									}
									delete State.variables.UInvBags[BagName][ItemName][ItemPropertyName];
									return true;  // Success
								} else {
									return true;  // Success - property already doesn't exist
								}
							} else if (UInv.isUndefined(ItemPropertyName)) {
								// Delete all properties except ReservedItemProperties
								Item = {};
								if (Quantity > 1) {
									Item.UInvQuantity = Quantity;
								}
								if (UInv.GetDefaultItemObject(ItemName)) {
									Item.UInvDefaultItemType = "-";
								}
								if (UInv.isProperty(State.variables.UInvBags[BagName][ItemName], "UInvPocket")) {
									Item.UInvPocket = State.variables.UInvBags[BagName][ItemName].UInvPocket;
								}
								if (UInv.isProperty(State.variables.UInvBags[BagName][ItemName], "UInvCell")) {
									Item.UInvCell = State.variables.UInvBags[BagName][ItemName].UInvCell;
								}
								State.variables.UInvBags[BagName][ItemName] = Item;
								return true;  // Success
							} else {
								UInvError('ItemPropertyName passed to DeleteItemProperty is not a string.');  // Error
								return undefined;
							}
						} else {
							UInvError('DeleteItemProperty cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('DeleteItemProperty cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else if (UInv.isArrayOfStrings(BagName)) {
					if (UInv.BagExists(BagName)) {
						var i = 0, Result = true;
						for (i = 0; i < BagName.length; i++) {
							if (!UInv.DeleteItemProperty(BagName[i], ItemName, ItemPropertyName)) {  // handle errors here better?  ***
								Result = undefined;
							}
						}
						return Result;  // Success
					} else {
						UInvError('DeleteItemProperty failed. Invalid bag name in BagName array.');  // Error
						return undefined;
					}
				} else {
					UInvError('DeleteItemProperty cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('ItemName passed to DeleteItemProperty is not a string.');  // Error
				return undefined;
			}
		},

		// MoveItemsByProperty: Move all items from SourceBagName to DestinationBagName that have the ItemPropertyName, or ItemPropertyName === Value if Value is passed.
		MoveItemsByProperty : function (SourceBagName, DestinationBagName, ItemPropertyName, Value) {
			if (UInv.isString(SourceBagName) && UInv.isString(DestinationBagName) && UInv.isString(ItemPropertyName)) {
				SourceBagName = FixBagName(SourceBagName);
				DestinationBagName = FixBagName(DestinationBagName);
				if (UInv.BagExists(SourceBagName)) {
					if (UInv.BagExists(DestinationBagName)) {
						if (SourceBagName !== DestinationBagName) {
							if (arguments.length >= 4) {
								var Items = [], Result = true;
								if (UInv.isUndefined(Value)) {
									Items = UInv.GetItemsArrayByProperty(SourceBagName, ItemPropertyName);
								} else {
									Items = UInv.GetItemsArrayWherePropertyEquals(SourceBagName, ItemPropertyName, Value);
								}
								if (Items.length > 0) {
									var i = 0, Ret = "";
									for (i = 0; i < Items.length; i++) {
										Ret = UInv.MoveItem(SourceBagName, DestinationBagName, Items[i]);
										if (UInv.isUndefined(Ret) || UInv.isUndefined(Result)) {
											Result = undefined;
										} else {
											if (UInv.isBoolean(Result)) {
												Result = [ Ret ];
											} else {
												Result.push(Ret);
											}
										}
									}
								}
								return Result;  // Success or Error  ***
							} else {
								UInvError('MoveItemsByProperty failed. Value parameter is missing.');  // Error
								return undefined;
							}
						} else {
							UInvError('MoveItemsByProperty failed. Source and destination bags cannot be the same.');  // Error
							return undefined;
						}
					} else {
						UInvError('MoveItemsByProperty cannot find bag "' + DestinationBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('MoveItemsByProperty cannot find bag "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to MoveItemsByProperty is not a string.');  // Error
				return undefined;
			}
		},

		// RenameItemProperty: Renames item property.  Returns true if it succeeds.  Bag is not touched.
		RenameItemProperty : function (BagName, ItemName, CurrentItemPropertyName, NewItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(CurrentItemPropertyName) && UInv.isString(NewItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (!UInv.ReservedBagProperties.includes(ItemName)) {
					if ((CurrentItemPropertyName !== "UInvQuantity") && (NewItemPropertyName !== "UInvQuantity")) {
						if (UInv.BagExists(BagName)) {
							if (UInv.BagHasItem(BagName, ItemName)) {
								if (UInv.ItemHasProperty(BagName, ItemName, CurrentItemPropertyName)) {
									if (UInv.ItemHasProperty(BagName, ItemName, NewItemPropertyName)) {
										UInvError('RenameItemProperty failed. Property "' + NewItemPropertyName + '" already exists on item "' + ItemName + '".');  // Error
										return undefined;
									} else if (CurrentItemPropertyName === NewItemPropertyName) {
										UInvError('RenameItemProperty failed. CurrentItemPropertyName cannot be the same as NewItemPropertyName.');  // Error
										return undefined;
									} else {
										UInv.SetCurrentItemName(ItemName);
										UInv.SetCurrentBagName(BagName);
										Object.defineProperty(State.variables.UInvBags[BagName][ItemName], NewItemPropertyName, Object.getOwnPropertyDescriptor(State.variables.UInvBags[BagName][ItemName], CurrentItemPropertyName));
										delete State.variables.UInvBags[BagName][ItemName][CurrentItemPropertyName];
										return true;  // Success
									}
								} else {
									UInvError('RenameItemProperty cannot find property "' + CurrentItemPropertyName + '" in item "' + ItemName + '".');  // Error
									return undefined;
								}
							} else {
								UInvError('RenameItemProperty cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('RenameItemProperty cannot find bag "' + BagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('RenameItemProperty failed. ItemPropertyName cannot be "UInvQuantity".');  // Error
						return undefined;
					}
				} else {
					UInvError('RenameItemProperty failed. ItemName cannot be "' + ItemName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to RenameItemProperty is not a string.');  // Error
				return undefined;
			}
		},

		// GetObjectOfItemPropertyValues: Returns an object in the format { ItemName : Value, ... } for each item in bag that has a property of ItemPropertyName.
		GetObjectOfItemPropertyValues : function (BagName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName), ItemValues = {}, i = 0;
					UInv.SetCurrentBagName(BagName);
					for (i = 0; i < Items.length; i++) {
						if (UInv.ItemHasProperty(BagName, Items[i], ItemPropertyName)) {
							ItemValues[Items[i]] = UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName);
						}
					}
					return ItemValues;  // Success
				} else {
					UInvError('GetObjectOfItemPropertyValues cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetObjectOfItemPropertyValues is not a string.');  // Error
				return undefined;
			}
		},

		// GetAllPropertyValues: Returns an array of all unique values of the items' ItemPropertyName in a bag.
		GetAllPropertyValues : function (BagName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName), Values = [], i = 0;
					UInv.SetCurrentBagName(BagName);
					for (i = 0; i < Items.length; i++) {
						if (UInv.ItemHasProperty(BagName, Items[i], ItemPropertyName)) {
							Values.pushUnique(UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName));
						}
					}
					return Values;  // Success
				} else {
					UInvError('GetAllPropertyValues cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetAllPropertyValues is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemByProperty: Returns a random item from a bag that has property ItemPropertyName.  Sets that item as the current item.
		GetItemByProperty : function (BagName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArrayByProperty(BagName, ItemPropertyName);
					UInv.SetCurrentBagName(BagName);
					if (Items.length > 0) {
						var Rnd = random(Items.length - 1);
						UInv.SetCurrentItemName(Items[Rnd]);
						return Items[Rnd];  // Success
					} else {
						return "";  // Success
					}
				} else {
					UInvError('GetItemByProperty cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemByProperty is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemByType: Returns a random ItemName from a bag that is of type ItemType.  Sets that item as the current item.
		GetItemByType : function (BagName, ItemType) {
			if (UInv.isString(BagName) && UInv.isString(ItemType)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArrayByType(BagName, ItemType);
					UInv.SetCurrentBagName(BagName);
					if (Items.length > 0) {
						var Rnd = random(Items.length - 1);
						UInv.SetCurrentItemName(Items[Rnd]);
						return Items[Rnd];  // Success
					} else {
						return "";  // Success
					}
				} else {
					UInvError('GetItemByType cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemByType is not a string.');  // Error
				return undefined;
			}
		},

		// GetRandomItemValue: Returns a random value of an item's ItemPropertyName in a bag if it has that property.  Sets that item as the current item.
		GetRandomItemValue : function (BagName, ItemPropertyName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Item = UInv.GetItemByProperty(BagName, ItemPropertyName);
					UInv.SetCurrentBagName(BagName);
					if (Item) {
						UInv.SetCurrentItemName(Item);
						return UInv.GetItemPropertyValue(BagName, Item, ItemPropertyName);  // Success
					} else {
						return "";  // Success
					}
				} else {
					UInvError('GetRandomItemValue cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetRandomItemValue is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemWherePropertyEquals: Returns a random ItemName from a bag where ItemPropertyName === Value.  Sets that item as the current item.
		GetItemWherePropertyEquals : function (BagName, ItemPropertyName, Value) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				if (!UInv.isUndefined(Value)) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						if (arguments.length >= 3) {
							var Items = UInv.GetItemsArrayWherePropertyEquals(BagName, ItemPropertyName, Value);
							UInv.SetCurrentBagName(BagName);
							if (Items.length > 0) {
								var Rnd = random(Items.length - 1);
								UInv.SetCurrentItemName(Items[Rnd]);
								return Items[Rnd];  // Success
							} else {
								return "";  // Success
							}
						} else {
							UInvError('GetItemWherePropertyEquals failed. Value parameter is missing.');  // Error
							return undefined;
						}
					} else {
						UInvError('GetItemWherePropertyEquals cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemWherePropertyEquals failed. Value parameter is undefined.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemWherePropertyEquals is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemWherePropertyGreaterThan: Returns a random ItemName from a bag where ItemPropertyName === Value.  Sets that item as the current item.
		GetItemWherePropertyGreaterThan : function (BagName, ItemPropertyName, Value) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				if (!UInv.isUndefined(Value)) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						var Items = UInv.GetItemsArrayWherePropertyGreaterThan(BagName, ItemPropertyName, Value);
						UInv.SetCurrentBagName(BagName);
						if (Items.length > 0) {
							var Rnd = random(Items.length - 1);
							UInv.SetCurrentItemName(Items[Rnd]);
							return Items[Rnd];  // Success
						} else {
							return "";  // Success
						}
					} else {
						UInvError('GetItemWherePropertyGreaterThan cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemWherePropertyGreaterThan failed. Value parameter is undefined.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemWherePropertyGreaterThan is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemWherePropertyLessThan: Returns a random ItemName from a bag where ItemPropertyName === Value.  Sets that item as the current item.
		GetItemWherePropertyLessThan : function (BagName, ItemPropertyName, Value) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				if (!UInv.isUndefined(Value)) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						var Items = UInv.GetItemsArrayWherePropertyLessThan(BagName, ItemPropertyName, Value);
						UInv.SetCurrentBagName(BagName);
						if (Items.length > 0) {
							var Rnd = random(Items.length - 1);
							UInv.SetCurrentItemName(Items[Rnd]);
							return Items[Rnd];  // Success
						} else {
							return "";  // Success
						}
					} else {
						UInvError('GetItemWherePropertyLessThan cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemWherePropertyLessThan failed. Value parameter is undefined.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemWherePropertyLessThan is not a string.');  // Error
				return undefined;
			}
		},

		// GetRandomItem: Returns a random ItemName from the bag.  Sets that item as the current item.
		GetRandomItem : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName);
					UInv.SetCurrentBagName(BagName);
					if (Items.length > 0) {
						var Rnd = random(Items.length - 1);
						UInv.SetCurrentItemName(Items[Rnd]);
						return Items[Rnd];  // Success
					} else {
						return "";  // Success
					}
				} else {
					UInvError('GetRandomItem cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetRandomItem is not a string.');  // Error
				return undefined;
			}
		},

		// ResetItemProperties: Removes all properties from an item (except UInvQuantity and UInvPocket if it exists).  If DefaultItemType is passed then it loads the default properties of that item.
		ResetItemProperties : function (BagName, ItemName, DefaultItemType) {
			if (UInv.isString(ItemName)) {
				var i;
				if (UInv.isString(BagName)) {
					BagName = FixBagName(BagName);
					ItemName = FixItemName(ItemName);
					if (UInv.BagExists(BagName)) {
						var Quantity = UInv.BagHasItem(BagName, ItemName);
						if (Quantity) {
							var hasPockets = false, Pockets, NewPockets, NewItemName;
							if (UInv.isUndefined(DefaultItemType)) {
								DefaultItemType = UInv.GetItemsDefaultType(BagName, ItemName);
								if (DefaultItemType) {
									if (UInv.ItemHasPocket(BagName, ItemName)) {  // Keep current pockets
										hasPockets = true;
										Quantity = 1;
										Pockets = UInv.GetItemPocketObject(BagName, ItemName);
										UInv.UnlinkPocketFromContainer(BagName, ItemName);
									}
									UInv.DeleteItem(BagName, ItemName);
									UInv.SetCurrentBagName(BagName);
									UInv.SetCurrentItemName(ItemName);
									NewItemName = UInv.AddItem(BagName, DefaultItemType, Quantity, ItemName);  // Success
									if (hasPockets) {  // Restore pockets
										if (UInv.ItemHasPocket(BagName, NewItemName)) {  // Delete new pockets
											NewPockets = UInv.GetItemPocketNameArray(BagName, NewItemName);
											for (i = 0; i < NewPockets.length; i++) {
												UInv.DeletePocket(BagName, NewItemName, NewPockets[i]);
											}
										}
										NewPockets = Object.keys(Pockets);
										for (i = 0; i < NewPockets.length; i++) {  // Restore old pockets
											UInv.AddExistingBagAsPocket(BagName, NewItemName, NewPockets[i], Pockets[NewPockets[i]]);
										}
									}
									return true;  // Success
								} else {
									UInvError('ResetItemProperties failed. Item does not have a default type.');  // Error
									return undefined;
								}
							} else if (UInv.isString(DefaultItemType)) {
								if (UInv.GetDefaultItemObject(DefaultItemType)) {
									if (UInv.ItemHasPocket(BagName, ItemName)) {  // Keep current pockets
										hasPockets = true;
										Quantity = 1;
										Pockets = UInv.GetItemPocketObject(BagName, ItemName);
										UInv.UnlinkPocketFromContainer(BagName, ItemName);
									}
									UInv.DeleteItem(BagName, ItemName);
									NewItemName = UInv.AddItem(BagName, DefaultItemType, Quantity, ItemName);
									if (hasPockets) {  // Restore pockets
										if (UInv.ItemHasPocket(BagName, NewItemName)) {  // Delete new pockets
											NewPockets = UInv.GetItemPocketNameArray(BagName, NewItemName);
											for (i = 0; i < NewPockets.length; i++) {
												UInv.DeletePocket(BagName, NewItemName, NewPockets[i]);
											}
										}
										NewPockets = Object.keys(Pockets);
										for (i = 0; i < NewPockets.length; i++) {  // Restore old pockets
											UInv.AddExistingBagAsPocket(BagName, NewItemName, NewPockets[i], Pockets[NewPockets[i]]);
										}
									}
									return true;  // Success
								} else {
									UInvError('ResetItemProperties failed. DefaultItemType "' + DefaultItemType + '" is not a default item.');  // Error
									return undefined;
								}
							} else {
								UInvError('DefaultItemType passed to ResetItemProperties is not a string.');  // Error
								return undefined;
							}
						} else {
							UInvError('ResetItemProperties cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('ResetItemProperties cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else if (UInv.isArrayOfStrings(BagName)) {
					if (UInv.BagExists(BagName)) {
						var Result = true;
						for (i = 0; i < BagName.length; i++) {
							Result = UInv.ResetItemProperties(BagName[i], ItemName, DefaultItemType);
						}
						return Result;  // Success
					} else {
						UInvError('ResetItemProperties failed. Invalid bag name in BagName array.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName passed to ResetItemProperties is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('ItemName passed to ResetItemProperties is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayWhereItemNameContains: Returns an array of ItemNames where item's name contains the substring    *** use RegExp matching?
		GetItemsArrayWhereItemNameContains : function (BagName, SubString) {
			if (UInv.isString(BagName) && UInv.isString(SubString)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName);
					UInv.SetCurrentBagName(BagName);
					if (Items.length > 0) {
						var Result = [], i = 0;
						for (i = 0; i < Items.length; i++) {
							if (Items[i].includes(SubString.toLowerCase())) {
								Result.push(Items[i]);
							}
						}
						return Result;  // Success
					} else {
						return [];  // Success
					}
				} else {
					UInvError('GetItemsArrayWhereItemNameContains cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Parameter passed to GetItemsArrayWhereItemNameContains is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayWherePropertyValueContains: Returns an array of ItemNames where item's ItemPropertyName contains the substring    *** use RegExp matching?
		GetItemsArrayWherePropertyValueContains : function (BagName, ItemPropertyName, SubString, CaseSensitive) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName) && UInv.isString(SubString)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName);
					UInv.SetCurrentBagName(BagName);
					if (Items.length > 0) {
						var Result = [], i = 0;
						if (UInv.isUndefined(CaseSensitive)) {
							CaseSensitive = false;
						}
						for (i = 0; i < Items.length; i++) {
							if (UInv.ItemHasProperty(BagName, ItemPropertyName)) {
								if (CaseSensitive) {
									if (UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName).includes(SubString)) {
										Result.push(Items[i]);
									}
								} else {
									if (UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName).toLowerCase().includes(SubString.toLowerCase())) {
										Result.push(Items[i]);
									}
								}
							}
						}
						return Result;  // Success
					} else {
						return [];  // Success
					}
				} else {
					UInvError('GetItemsArrayWherePropertyValueContains cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Parameter passed to GetItemsArrayWherePropertyValueContains is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemPropertyValueObject: Returns an object in the format { ItemName : ItemPropertyName's value, ... } for each item in BagName that has the property ItemPropertyName.
		//                             Items that don't have ItemPropertyName are ignored.  Returns undefined on error.
		GetItemPropertyValueObject : function (BagName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName);
					UInv.SetCurrentBagName(BagName);
					if (Items.length > 0) {
						var Result = {}, i = 0;
						for (i = 0; i < Items.length; i++) {
							if (UInv.ItemHasProperty(BagName, Items[i], ItemPropertyName)) {
								Result[Items[i]] = ItemPropertyName;
							}
						}
						return Result;  // Success
					} else {
						return {};  // Success
					}
				} else {
					UInvError('GetItemPropertyValueObject cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Parameter passed to GetItemPropertyValueObject is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArraySortedByProperty: Returns an array of item names in BagName, sorted by the value in ItemPropertyName (subsorted by ItemName), or by ItemName if ItemPropertyName isn't set.
		//         The array is sorted by number or boolean if all item property values are of that type, otherwise it converts non-strings to strings and does a lowercase comparison.
		//         Items that don't have ItemPropertyName are ignored.  Returns undefined on error.
		GetItemsArraySortedByProperty : function (BagName, ItemPropertyName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName);
					UInv.SetCurrentBagName(BagName);
					if (Items.length > 0) {
						if (!UInv.isUndefined(ItemPropertyName)) {
							var Result = [], Key = [], i = 0, temp = [], ChangeType = true;
							temp = UInv.GetAllPropertyValues(BagName, ItemPropertyName);
							if (UInv.isArrayOfNumbers(temp) || UInv.isArrayOfBooleans(temp)) {
								ChangeType = false;
							}
							for (i = 0; i < Items.length; i++) {
								if (UInv.ItemHasProperty(BagName, Items[i], ItemPropertyName)) {
									Result[i] = Items[i];
									temp = UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName);
									if (ChangeType && !UInv.isString(temp)) {
										temp = temp.toString();
									}
									if (UInv.isString(temp)) {
										temp = temp.toLowerCase();
									}
									Key[i] = temp;
								}
							}
							return UInv.getArraySortedByOtherArray(Result, Key);  // Success
						} else {
							return Items.sort( function compare(a, b) {  // String sort function; a & b are item names, so they will always be strings
								if (a.toLowerCase() < b.toLowerCase()) {
									return -1;
								}
								if (a.toLowerCase() > b.toLowerCase()) {
									return 1;
								}
								return 0;  // a === b
							});  // Success
						}
					} else {
						return [];  // Success
					}
				} else {
					UInvError('GetItemsArraySortedByProperty cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetItemsArraySortedByProperty is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemCountByFunction: Returns the sum of the values returned by function (function is passed BagName) or undefined on error.
		GetItemCountByFunction : function (BagName, CountFunction) {
			var tmp;
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.isFunction(CountFunction)) {
						UInv.SetCurrentBagName(BagName);
						tmp = CountFunction(BagName);
						if (UInv.isUndefined(tmp)) {
							UInv.Error("Error: GetItemCountByFunction failed. CountFunction's return value is undefined.");  // Error
							return undefined;
						}
						return tmp;  // Success
					} else {
						UInvError('CountFunction passed to GetItemCountByFunction is not a function.');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemCountByFunction cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else if (UInv.isArrayOfStrings(BagName)) {
				if (UInv.isFunction(CountFunction)) {
					var i = 0, Result = 0;
					if (BagName.length > 0) {
						for (i = 0; i < BagName.length; i++) {
							if (UInv.BagExists(BagName[i])) {
								tmp = CountFunction(BagName);
								if (UInv.isUndefined(tmp)) {
									UInv.Error("Error: GetItemCountByFunction failed. CountFunction's return value is undefined.");  // Error
									return undefined;
								}
								Result += tmp;
							} else {
								UInvError('GetItemCountByFunction cannot find bag "' + BagName + '".');  // Error
								return undefined;
							}
						}
					}
					return Result;  // Success
				} else {
					UInvError('CountFunction passed to GetItemCountByFunction is not a function.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetItemCountByFunction is not a string or an array of strings.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayByFunction: Returns an array of items where function is true (function is passed BagName and ItemName strings) or undefined on error.
		GetItemsArrayByFunction : function (BagName, SelectionFunction) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.isFunction(SelectionFunction)) {
						var Items = UInv.GetItemsArray(BagName), i = 0, tmp, Result = [];
						UInv.SetCurrentBagName(BagName);
						if (Items.length > 0) {
							for (i = 0; i < Items.length; i++) {
								tmp = SelectionFunction(BagName, Items[i]);
								if (UInv.isUndefined(tmp)) {
									UInv.Error("Error: GetItemsArrayByFunction failed. SelectionFunction's return value is undefined.");  // Error
									return undefined;
								}
								if (tmp) {
									Result.push([Items[i]]);
								}
							}
						}
						return Result;  // Success
					} else {
						UInvError('SelectionFunction passed to GetItemsArrayByFunction is not a function.');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemsArrayByFunction cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetItemsArrayByFunction is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArraySortedByFunction: Returns an array of ItemNames sorted by the SortFunction function, or undefined on error.
		//                                The SortFunction will be passed the parameters (BagName, ItemName1, ItemName2), and
		//                                if the function returns a "truthy" value, then those two items will be swapped in the array.
		GetItemsArraySortedByFunction : function (BagName, SortFunction) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.isFunction(SortFunction)) {
						var Items = UInv.GetItemsArray(BagName), tmp, i = 0, n = 0, Continue = true;
						UInv.SetCurrentBagName(BagName);
						if (Items.length > 0) {
							while ((n <= Items.length) && Continue) {
								Continue = false;
								for (i = 0; i < Items.length - 1; i++) {
									tmp = SortFunction(BagName, Items[i], Items[i + 1]);
									if (UInv.isUndefined(tmp)) {
										UInv.Error("Error: GetItemsArraySortedByFunction failed. SortFunction's return value is undefined.");  // Error
										return undefined;
									}
									if (tmp) {
										Continue = true;
										tmp = Items[i];
										Items[i] = Items[i + 1];
										Items[i + 1] = tmp;
									}
								}
								n++;
							}
						}
						if (n > Items.length) {
							UInvError('GetItemsArraySortedByFunction failed. SortFunction is not returning consistent results.');  // Error
							return undefined;
						} else {
							return Items;  // Success
						}
					} else {
						UInvError('SortFunction passed to GetItemsArraySortedByFunction is not a function.');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemsArraySortedByFunction cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to GetItemsArraySortedByFunction is not a string.');  // Error
				return undefined;
			}
		},

		// ItemHasAllProperties: Returns whether all of the item's properties are listed in ItemPropertyNameArray, false if the item has no properties, or undefined on error.
		ItemHasAllProperties : function (BagName, ItemName, ItemPropertyNameArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						if (UInv.isArrayOfStrings(ItemPropertyNameArray)) {
							var Props = UInv.GetItemPropertiesArray(BagName, ItemName);
							if (!UInv.isArray(ItemPropertyNameArray)) {
								ItemPropertyNameArray = [ ItemPropertyNameArray ];
							}
							if ((Props.length > 0) && (ItemPropertyNameArray.length > 0)) {
								var i;
								for (i = 0; i < Props.length; i++) {
									if (!ItemPropertyNameArray.includes(Props[i])) {
										return false;  // Success
									}
								}
								return true;  // Success
							}
							return false;  // Success
						} else {
							UInvError('ItemHasAllProperties failed. ItemPropertyNameArray is not an array of strings.');  // Error
							return undefined;
						}
					} else {
						UInvError('ItemHasAllProperties cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ItemHasAllProperties cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to ItemHasAllProperties is not a string.');  // Error
				return undefined;
			}
		},

		// ItemHasAnyProperties: Returns whether any of the item's properties are listed in ItemPropertyNameArray, false if the item has no properties, or undefined on error.
		ItemHasAnyProperties : function (BagName, ItemName, ItemPropertyNameArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						if (UInv.isArrayOfStrings(ItemPropertyNameArray)) {
							var Props = UInv.GetItemPropertiesArray(BagName, ItemName);
							if (!UInv.isArray(ItemPropertyNameArray)) {
								ItemPropertyNameArray = [ ItemPropertyNameArray ];
							}
							if ((Props.length > 0) && (ItemPropertyNameArray.length > 0)) {
								var i;
								for (i = 0; i < Props.length; i++) {
									if (ItemPropertyNameArray.includes(Props[i])) {
										return true;  // Success
									}
								}
							}
							return false;  // Success
						} else {
							UInvError('ItemHasAnyProperties failed. ItemPropertyNameArray is not an array of strings.');  // Error
							return undefined;
						}
					} else {
						UInvError('ItemHasAnyProperties cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ItemHasAnyProperties cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to ItemHasAnyProperties is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayWithAllProperties: Returns an array of all items which have all of the properties in ItemPropertyNameArray (per the ItemHasAllProperties function), or undefined on error.
		//                                 Items which have no properties will not be included.
		GetItemsArrayWithAllProperties : function (BagName, ItemPropertyNameArray) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.isString(ItemPropertyNameArray)) {
						ItemPropertyNameArray = [ ItemPropertyNameArray ];
					}
					if (UInv.isArrayOfStrings(ItemPropertyNameArray)) {
						var Items = UInv.GetItemsArray(BagName), Result = [], i;
						for (i = 0; i < Items.length; i++) {
							if (UInv.ItemHasAllProperties(BagName, Items[i], ItemPropertyNameArray)) {
								Result.push(Items[i]);
							}
						}
						return Result;  // Success
					} else {
						UInvError('GetItemsArrayWithAllProperties failed. ItemPropertyNameArray is not an array of strings.');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemsArrayWithAllProperties cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayWithAllProperties is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayWithoutProperties: Returns an array of ItemNames in BagName that do not have any ItemPropertyName/Array as any of their properties, or undefined on error.
		GetItemsArrayWithoutProperties : function (BagName, ItemPropertyNameArray) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.isString(ItemPropertyNameArray)) {
						ItemPropertyNameArray = [ ItemPropertyNameArray ];
					}
					if (UInv.isArrayOfStrings(ItemPropertyNameArray)) {
						var Items = UInv.GetItemsArray(BagName), Result = [], i;
						for (i = 0; i < Items.length; i++) {
							if (!UInv.ItemHasAnyProperties(BagName, Items[i], ItemPropertyNameArray)) {
								Result.push(Items[i]);
							}
						}
						return Result;  // Success
					} else {
						UInvError('GetItemsArrayWithoutProperties failed. ItemPropertyNameArray is not an array of strings.');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemsArrayWithoutProperties cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayWithoutProperties is not a string.');  // Error
				return undefined;
			}
		},

		// SwapItemsProperties: Swaps the given properties of two items (except UInvDefaultItemType and UInvVariableType, plus UInvQuantity for items with pockets).  Returns true on success.
		SwapItemsProperties : function (BagName1, ItemName1, BagName2, ItemName2, ItemPropertyName) {
			if (UInv.isString(BagName1) && UInv.isString(ItemName1) && UInv.isString(BagName2) && UInv.isString(ItemName2)) {
				BagName1 = FixBagName(BagName1);
				ItemName1 = FixItemName(ItemName1);
				BagName2 = FixBagName(BagName2);
				ItemName2 = FixItemName(ItemName2);
				if (UInv.BagExists(BagName1)) {
					if (UInv.BagExists(BagName2)) {
						if (UInv.BagHasItem(BagName1, ItemName1)) {
							if (UInv.BagHasItem(BagName2, ItemName2)) {
								if (UInv.isString(ItemPropertyName)) {
									ItemPropertyName = [ ItemPropertyName ];
								}
								if (UInv.isArrayOfStrings(ItemPropertyName)) {
									ItemPropertyName = UInv.getUniqueArray(ItemPropertyName);  // Remove duplicates
									if (!ItemPropertyName.includesAny("UInvDefaultItemType", "UInvVariableType")) {
										if (!(ItemPropertyName.includes("UInvQuantity") && (UInv.ItemHasPocket(BagName1, ItemName1) || UInv.ItemHasPocket(BagName2, ItemName2)))) {
											var i = 0, Val;
											if (ItemPropertyName.length > 0) {
												for (i = 0; i < ItemPropertyName.length; i++) {
													if (UInv.ItemHasProperty(BagName1, ItemName1, ItemPropertyName[i])) {
														if (UInv.ItemHasProperty(BagName2, ItemName2, ItemPropertyName[i])) {
															// swap item property values
															Val = UInv.GetItemValue(BagName1, ItemName1, ItemPropertyName[i]);
															UInv.SetItemPropertyValue(BagName1, ItemName1, ItemPropertyName[i], UInv.GetItemValue(BagName2, ItemName2, ItemPropertyName[i]));
															UInv.SetItemPropertyValue(BagName2, ItemName2, ItemPropertyName[i], Val);
															if (ItemPropertyName[i] == "UInvPocket") {  // Update pockets on both items
																FixContainerReferences(BagName1, ItemName1, BagName2, ItemName2);
																FixContainerReferences(BagName2, ItemName2, BagName1, ItemName1);
															}
														} else {
															// move item property
															UInv.SetItemPropertyValue(BagName2, ItemName2, ItemPropertyName[i], UInv.GetItemValue(BagName1, ItemName1, ItemPropertyName[i]));
															if (ItemPropertyName[i] == "UInvPocket") {  // Update pockets on item 2
																FixContainerReferences(BagName1, ItemName1, BagName2, ItemName2);
															}
															if (["UInvPocket", "UInvCell"].includes(ItemPropertyName[i])) {  // Delete swapped away property
																delete State.variables.UInvBags[BagName1][ItemName1][ItemPropertyName[i]];
															} else {
																UInv.DeleteItemProperty(BagName1, ItemName1, ItemPropertyName[i]);
															}
														}
													} else {
														if (UInv.ItemHasProperty(BagName2, ItemName2, ItemPropertyName[i])) {
															// move item property
															UInv.SetItemPropertyValue(BagName1, ItemName1, ItemPropertyName[i], UInv.GetItemValue(BagName2, ItemName2, ItemPropertyName[i]));
															if (ItemPropertyName[i] == "UInvPocket") {  // Update pockets on item 1
																FixContainerReferences(BagName2, ItemName2, BagName1, ItemName1);
															}
															if (["UInvPocket", "UInvCell"].includes(ItemPropertyName[i])) {  // Delete swapped away property
																delete State.variables.UInvBags[BagName2][ItemName2][ItemPropertyName[i]];
															} else {
																UInv.DeleteItemProperty(BagName2, ItemName2, ItemPropertyName[i]);
															}
														}
													}
												}
											}
											return true;  // Success
										} else {
											UInvError('SwapItemsProperties failed. ItemPropertyName cannot be UInvQuantity if either item has pockets.');  // Error
											return undefined;
										}
									} else {
										UInvError('SwapItemsProperties failed. ItemPropertyName cannot be UInvDefaultItemType or UInvVariableType.');  // Error
										return undefined;
									}
								} else {
									UInvError('SwapItemsProperties failed. ItemPropertyName is not a string or array of strings.');  // Error
									return undefined;
								}
							} else {
								UInvError('SwapItemsProperties cannot find item "' + ItemName2 + '" in bag "' + BagName2 + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('SwapItemsProperties cannot find item "' + ItemName1 + '" in bag "' + BagName1 + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('SwapItemsProperties cannot find bag "' + BagName2 + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('SwapItemsProperties cannot find bag "' + BagName1 + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to SwapItemsProperties is not a string.');  // Error
				return undefined;
			}
		},

		// SwapItems: Swaps two items, optionally keeps certain item properties un-swapped.  Returns true on success, undefined on error.
		SwapItems : function (BagName1, ItemName1, BagName2, ItemName2, ExceptItemPropertyName) {
			if (UInv.isString(BagName1) && UInv.isString(ItemName1) && UInv.isString(BagName2) && UInv.isString(ItemName2)) {
				BagName1 = FixBagName(BagName1);
				ItemName1 = FixItemName(ItemName1);
				BagName2 = FixBagName(BagName2);
				ItemName2 = FixItemName(ItemName2);
				if (UInv.BagExists(BagName1)) {
					if (UInv.BagExists(BagName2)) {
						if (UInv.BagHasItem(BagName1, ItemName1)) {
							if (UInv.BagHasItem(BagName2, ItemName2)) {
								if (UInv.isString(ExceptItemPropertyName)) {
									ExceptItemPropertyName = [ ExceptItemPropertyName ];
								}
								if (BagName1 === BagName2) {
									if (UInv.isUndefined(ExceptItemPropertyName)) {
										return true;  // Success - items already in same bag
									} else if (UInv.isArrayOfStrings(ExceptItemPropertyName)) {  // Just swap excepted properties
										UInv.SwapItemsProperties(BagName1, ItemName1, BagName2, ItemName2, ExceptItemPropertyName);
										return true;  // Success
									} else {
										UInvError('SwapItems failed. ExceptItemPropertyName is not a string or array of strings.');  // Error
										return undefined;
									}
								} else {
									if (UInv.isUndefined(ExceptItemPropertyName) || UInv.isArrayOfStrings(ExceptItemPropertyName)) {  // Swap items
										var TempBag = UInv.GetUniqueBagName(), Item1Obj = {}, Item2Obj = {}, i;
										UInv.IncrementUpdateLock();  // Prevent unnecessary updates
										if (UInv.isArrayOfStrings(ExceptItemPropertyName)) {  // Store excepted properties
											for (i = 0; i < ExceptItemPropertyName.length; i++) {
												if (UInv.ItemHasProperty(BagName1, ItemName1, ExceptItemPropertyName[i])) {
													Item1Obj[ExceptItemPropertyName[i]] = UInv.GetItemPropertyValue(BagName1, ItemName1, ExceptItemPropertyName[i]);
												}
												if (UInv.ItemHasProperty(BagName2, ItemName2, ExceptItemPropertyName[i])) {
													Item2Obj[ExceptItemPropertyName[i]] = UInv.GetItemPropertyValue(BagName2, ItemName2, ExceptItemPropertyName[i]);
												}
											}
										}
										UInv.CreateBag(TempBag);
										UInv.MoveItem(BagName1, TempBag, ItemName1);
										UInv.MoveItem(BagName2, BagName1, ItemName2);
										UInv.MoveItem(TempBag, BagName2, ItemName1);
										UInv.DeleteBag(TempBag);
										if (UInv.isArrayOfStrings(ExceptItemPropertyName)) {  // Swap excepted properties
											for (i = 0; i < ExceptItemPropertyName.length; i++) {
												if (UInv.isProperty(Item2Obj, ExceptItemPropertyName[i])) {
													UInv.SetItemPropertyValue(BagName2, ItemName1, ExceptItemPropertyName[i], Item2Obj[ExceptItemPropertyName[i]]);
												} else if (UInv.ItemHasProperty(BagName2, ItemName1, ExceptItemPropertyName[i])) {
													UInv.DeleteItemProperty(BagName2, ItemName1, ExceptItemPropertyName[i]);
												}
												if (UInv.isProperty(Item1Obj, ExceptItemPropertyName[i])) {
													UInv.SetItemPropertyValue(BagName1, ItemName2, ExceptItemPropertyName[i], Item1Obj[ExceptItemPropertyName[i]]);
												} else if (UInv.ItemHasProperty(BagName1, ItemName2, ExceptItemPropertyName[i])) {
													UInv.DeleteItemProperty(BagName1, ItemName2, ExceptItemPropertyName[i]);
												}
											}
										}
										UInv.DecrementUpdateLock();
										UInv.SetCurrentBagName(BagName1);
										UInv.SetCurrentItemName(ItemName1);
										return true;  // Success
									} else {
										UInvError('SwapItems failed. ExceptItemPropertyName is not a string or array of strings.');  // Error
										return undefined;
									}
								}
							} else {
								UInvError('SwapItems cannot find item "' + ItemName2 + '" in bag "' + BagName2 + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('SwapItems cannot find item "' + ItemName1 + '" in bag "' + BagName1 + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('SwapItems cannot find bag "' + BagName2 + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('SwapItems cannot find bag "' + BagName1 + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to SwapItems is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagItemArrayWhereItemPropertyEquals: Returns an array of [[BagName, ItemName], ...] where the item's ItemPropertyName property == Value (all entries are unique), or undefined on error.
		GetBagItemArrayWhereItemPropertyEquals : function (BagNameArray, ItemPropertyName, Value) {
			if (UInv.isString(ItemPropertyName)) {
				if (UInv.isString(BagNameArray)) {
					BagNameArray = [ BagNameArray ];
				}
				if (UInv.isArrayOfStrings(BagNameArray)) {
					if (UInv.BagExists(BagNameArray)) {
						if (arguments.length >= 3) {
							var Result = [], Items, Match = {}, i, j;
							for (i = 0; i < BagNameArray.length; i++) {
								Items = UInv.GetItemsArrayWherePropertyEquals(BagNameArray[i], ItemPropertyName, Value);
								for (j = 0; j < Items.length; j++) {
									if (!UInv.isProperty(Match, BagNameArray[i]+Items[j])) {  // Make sure the item isn't already in the Results array
										Match[BagNameArray[i]+Items[j]] = true;
										Result.push([BagNameArray[i], Items[j]]);
									}
								}
							}
							return Result;  // Success
						} else {
							UInvError('GetBagItemArrayWhereItemPropertyEquals failed.  Value parameter is missing.');  // Error
							return undefined;
						}
					} else {
						UInvError('GetBagItemArrayWhereItemPropertyEquals failed.  Unknown bag in BagNameArray.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagNameArray passed to GetBagItemArrayWhereItemPropertyEquals is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('ItemPropertyName passed to GetBagItemArrayWhereItemPropertyEquals is not a string.');  // Error
				return undefined;
			}
		},

		// RestackItems: Attempts to restack any items which may be stacked incorrectly.  Returns true if any were restacked, false for no changes, and undefined on error.
		RestackItems : function (BagName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Result = false, Test = true, Start = 0, Items, i, j;
					UInv.IncrementUpdateLock();
					while (Test) {
						Test = false;
						Items = UInv.GetItemsArray(BagName).sort();
						if (Items.length > 1) {
							for (i = Start; i < Items.length - 1; i++) {
								Start = i;  // So the loop can pick up where it left off
								for (j = i + 1; j < Items.length; j++) {
									if (UInv.ItemsMatch(BagName, Items[i], BagName, Items[j])) {  // Merge stacks
										if ((Items[i].indexOf("item") == 0) && (Items[j].indexOf("item") != 0)) {  // Prefer item names that do NOT start with "item"
											UInv.SetItemQuantity(BagName, Items[j], UInv.BagHasItem(BagName, Items[j]) + UInv.BagHasItem(BagName, Items[i]));
											UInv.DeleteItem(BagName, Items[i]);
										} else {  // default to first item
											UInv.SetItemQuantity(BagName, Items[i], UInv.BagHasItem(BagName, Items[i]) + UInv.BagHasItem(BagName, Items[j]));
											UInv.DeleteItem(BagName, Items[j]);
										}
										Result = true;
										Test = true;
										break;
									}
								}
								if (Test) {
									break;
								}
							}
						}
					}
					UInv.DecrementUpdateLock();
					UInv.SetCurrentBagName(BagName);
					return Result;
				} else {
					UInvError('RestackItems cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to RestackItems is not a string.');  // Error
				return undefined;
			}
		},

		// MoveBagPropertyValueToItem: Moves an amount of a number from a bag's property to an item's property, limited by the minimum and maximum values.
		//                             Deletes the bag, item, or property (depending on DeletionType) if the property's value gets set to DeletionValue.  Returns the destination value or undefined on error.
		MoveBagPropertyValueToItem : function (SourceBagName, SourceBagPropertyName, DestinationBagName, DestinationItemName, DestinationItemPropertyName, Amount, MinimumValue, MaximumValue, DeletionValue, DeletionType) {
			if (UInv.isString(SourceBagName) && UInv.isString(SourceBagPropertyName) && UInv.isString(DestinationBagName) && UInv.isString(DestinationItemName)) {
				SourceBagName = FixBagName(SourceBagName);
				DestinationBagName = FixBagName(DestinationBagName);
				if (UInv.BagExists(SourceBagName)) {
					if (UInv.BagExists(DestinationBagName)) {
						DestinationItemName = FixItemName(DestinationItemName);
						if (UInv.BagHasItem(DestinationBagName, DestinationItemName)) {
							if (UInv.BagHasProperty(SourceBagName, SourceBagPropertyName)) {
								if (UInv.isUndefined(DestinationItemPropertyName)) {
									DestinationItemPropertyName = SourceBagPropertyName;
								}
								if (["UInvDefaultItemType", "UInvPocket"].includes(DestinationItemPropertyName)) {
									UInvError('MoveBagPropertyValueToItem failed. DestinationItemPropertyName cannot be "' + DestinationItemPropertyName + '".');  // Error
									return undefined;
								}
								if (DestinationItemPropertyName === "UInvQuantity") {
									if (!UInv.isInteger(UInv.GetBagPropertyValue(SourceBagName, SourceBagPropertyName))) {
										UInvError("MoveBagPropertyValueToItem failed. Source bag property must be an integer to move it to an item's UInvQuantity.");  // Error
										return undefined;
									}
									if ((!UInv.isUndefined(Amount)) && (!UInv.isInteger(Amount))) {
										UInvError("MoveBagPropertyValueToItem failed. Amount must be an integer to move it to an item's UInvQuantity.");  // Error
										return undefined;
									}
									MinimumValue = 0;
									DeletionValue = 0;
									if (UInv.isString(DeletionType) && (DeletionType !== "object")) {
										DeletionType = "item";
									}
								}
								if (!UInv.isUndefined(Amount)) {
									Amount = tryIntParse(Amount);
									if (UInv.isNumber(Amount)) {
										var SrcVal = UInv.GetBagPropertyValue(SourceBagName, SourceBagPropertyName);
										SrcVal = tryIntParse(SrcVal);
										if (UInv.isNumber(SrcVal)) {
											var DstVal = 0;
											if (UInv.ItemHasProperty(DestinationBagName, DestinationItemName, DestinationItemPropertyName)) {
												DstVal = UInv.GetItemPropertyValue(DestinationBagName, DestinationItemName, DestinationItemPropertyName);
												DstVal = tryIntParse(DstVal);
											}
											if (UInv.isNumber(DstVal)) {
												var TmpAmt = Amount;
												if (!UInv.isUndefined(MinimumValue)) {
													MinimumValue = tryIntParse(MinimumValue);
													if (UInv.isUndefined(MinimumValue)) {
														UInvError('MoveBagPropertyValueToItem failed. If used, MinimumValue must be a number.');  // Error
														return undefined;
													}
													if (SrcVal - Amount < MinimumValue) {  // Can't reduce source below minimum
														Amount = SrcVal - MinimumValue;
													}
													if (DstVal + Amount < MinimumValue) {  // Can't reduce destination below minimum (for when Amount is negative)
														Amount = MinimumValue - DstVal;
													}
												}
												if (!UInv.isUndefined(MaximumValue)) {
													MaximumValue = tryIntParse(MaximumValue);
													if (UInv.isUndefined(MaximumValue)) {
														UInvError('MoveBagPropertyValueToItem failed. If used, MaximumValue must be a number.');  // Error
														return undefined;
													}
													if ((!UInv.isUndefined(MinimumValue)) && (MinimumValue > MaximumValue)) {
														UInvError('MoveBagPropertyValueToItem failed. When both are used, MaximumValue must be greater than MinimumValue.');  // Error
														return undefined;
													}
													if (SrcVal - Amount > MaximumValue) {  // Can't increase source above maximum (for when Amount is negative)
														Amount = SrcVal - MaximumValue;
													}
													if (DstVal + Amount > MaximumValue) {  // Can't increase destination above maximum
														Amount = MaximumValue - DstVal;
													}
												}
												if (((TmpAmt >= 0) && (Amount > TmpAmt)) || ((TmpAmt < 0) && (Amount < TmpAmt))) {
													UInvError('MoveBagPropertyValueToItem failed. Source (' + SrcVal + ') and/or Destination (' + DstVal + ') values are too far out of MinimumValue (' + MinimumValue + ') and/or MaximumValue (' + MaximumValue + ') range.');  // Error
													return undefined;
												}
												if (!UInv.isUndefined(DeletionValue)) {
													DeletionValue = tryIntParse(DeletionValue);
													if (UInv.isUndefined(DeletionValue)) {
														UInvError('MoveBagPropertyValueToItem failed. If used, DeletionValue must be a number.');  // Error
														return undefined;
													}
													if (SrcVal - Amount == DeletionValue) {
														if (UInv.isString(DeletionType)) {
															DeletionType = DeletionType.toLowerCase();
														} else {
															DeletionType = "property";
														}
														switch (DeletionType) {
															case "bag":  // delete bag
															case "object":  // delete bag or item
																UInv.DeleteBag(SourceBagName);
																break;
															case "item":  // delete item (do nothing in this case)
																UInv.SetBagPropertyValue(SourceBagName, SourceBagPropertyName, SrcVal - Amount);
																break;
															default:  // delete property
																UInv.DeleteBagProperty(SourceBagName, SourceBagPropertyName);
														}
													} else {
														UInv.SetBagPropertyValue(SourceBagName, SourceBagPropertyName, SrcVal - Amount);
													}
													if (DstVal + Amount == DeletionValue) {
														if (UInv.isString(DeletionType)) {
															DeletionType = DeletionType.toLowerCase();
														} else {
															DeletionType = "property";
														}
														switch (DeletionType) {
															case "item":  // delete item
															case "object":  // delete bag or item
																UInv.DeleteItem(DestinationBagName, DestinationItemName);
																break;
															case "bag":  // delete bag (do nothing in this case)
																UInv.SetItemPropertyValue(DestinationBagName, DestinationItemName, DestinationItemPropertyName, DstVal + Amount);
																break;
															default:  // delete property
																UInv.DeleteItemProperty(DestinationBagName, DestinationItemName, DestinationItemPropertyName);
														}
													} else {
														UInv.SetItemPropertyValue(DestinationBagName, DestinationItemName, DestinationItemPropertyName, DstVal + Amount);
													}
													UInv.SetCurrentBagName(DestinationBagName);
													UInv.SetCurrentItemName(DestinationItemName);
													return DstVal + Amount;  // Success
												}
												UInv.SetBagPropertyValue(SourceBagName, SourceBagPropertyName, SrcVal - Amount);
												UInv.SetItemPropertyValue(DestinationBagName, DestinationItemName, DestinationItemPropertyName, DstVal + Amount);
												UInv.SetCurrentBagName(DestinationBagName);
												UInv.SetCurrentItemName(DestinationItemName);
												return DstVal + Amount;  // Success
											} else {
												UInvError("MoveBagPropertyValueToItem failed. Destination item's property value must be a number to add to or subtract from it.");  // Error
												return undefined;
											}
										} else {
											UInvError("MoveBagPropertyValueToItem failed. Source bag's property value must be a number to move an Amount of it.");  // Error
											return undefined;
										}
									} else {
										UInvError('MoveBagPropertyValueToItem failed. If used, Amount must be a number.');  // Error
										return undefined;
									}
								} else {
									var Val = UInv.GetBagPropertyValue(SourceBagName, SourceBagPropertyName);
									UInv.SetItemPropertyValue(DestinationBagName, DestinationItemName, DestinationItemPropertyName, Val);
									UInv.DeleteBagProperty(SourceBagName, SourceBagPropertyName);
									UInv.SetCurrentBagName(DestinationBagName);
									UInv.SetCurrentItemName(DestinationItemName);
									return Val;  // Success
								}
							} else {
								UInvError('MoveBagPropertyValueToItem failed. Source bag "' + SourceBagName + '" does not have property "' + SourceBagPropertyName + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('MoveBagPropertyValueToItem failed. Destination bag "' + DestinationBagName + '" does not contain item "' + DestinationItemName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('MoveBagPropertyValueToItem cannot find destination bag "' + DestinationBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('MoveBagPropertyValueToItem cannot find source bag "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to MoveBagPropertyValueToItem is not a string.');  // Error
				return undefined;
			}
		},

		// MoveItemPropertyValueToItem: Moves an amount of a number from one item's property to another item's property, limited by the minimum and maximum values.
		//                              Deletes the bag, item, or property (depending on DeletionType) if the property's value gets set to DeletionValue.  Returns the destination value or undefined on error.
		MoveItemPropertyValueToItem : function (SourceBagName, SourceItemName, SourceItemPropertyName, DestinationBagName, DestinationItemName, DestinationItemPropertyName, Amount, MinimumValue, MaximumValue, DeletionValue, DeletionType) {
			if (UInv.isString(SourceBagName) && UInv.isString(SourceItemName) && UInv.isString(SourceItemPropertyName) && UInv.isString(DestinationBagName) && UInv.isString(DestinationItemName)) {
				SourceBagName = FixBagName(SourceBagName);
				DestinationBagName = FixBagName(DestinationBagName);
				if (UInv.BagExists(SourceBagName)) {
					if (UInv.BagExists(DestinationBagName)) {
						SourceItemName = FixItemName(SourceItemName);
						if (UInv.BagHasItem(SourceBagName, SourceItemName)) {
							DestinationItemName = FixItemName(DestinationItemName);
							if (UInv.BagHasItem(DestinationBagName, DestinationItemName)) {
								if (UInv.ItemHasProperty(SourceBagName, SourceItemName, SourceItemPropertyName)) {
									if (UInv.isUndefined(DestinationItemPropertyName)) {
										DestinationItemPropertyName = SourceItemPropertyName;
									}
									if (["UInvDefaultItemType", "UInvPocket"].includes(SourceItemPropertyName)) {
										UInvError('MoveItemPropertyValueToItem failed. SourceItemPropertyName cannot be "' + SourceItemPropertyName + '".');  // Error
										return undefined;
									}
									if (["UInvDefaultItemType", "UInvPocket"].includes(DestinationItemPropertyName)) {
										UInvError('MoveItemPropertyValueToItem failed. DestinationItemPropertyName cannot be "' + DestinationItemPropertyName + '".');  // Error
										return undefined;
									}
									if (DestinationItemPropertyName === "UInvQuantity") {
										if ((!UInv.isUndefined(Amount)) && (!UInv.isInteger(Amount))) {
											UInvError("MoveItemPropertyValueToItem failed. Amount must be an integer to move it to an item's UInvQuantity.");  // Error
											return undefined;
										}
										MinimumValue = 0;
										DeletionValue = 0;
										if (UInv.isString(DeletionType) && (DeletionType !== "object")) {
											DeletionType = "item";
										}
									}
									if (!UInv.isUndefined(Amount)) {
										Amount = tryIntParse(Amount);
										if (UInv.isNumber(Amount)) {
											var SrcVal = UInv.GetItemPropertyValue(SourceBagName, SourceItemName, SourceItemPropertyName);
											SrcVal = tryIntParse(SrcVal);
											if (UInv.isNumber(SrcVal)) {
												var DstVal = 0;
												if (UInv.ItemHasProperty(DestinationBagName, DestinationItemName, DestinationItemPropertyName)) {
													DstVal = UInv.GetItemPropertyValue(DestinationBagName, DestinationItemName, DestinationItemPropertyName);
													DstVal = tryIntParse(DstVal);
												}
												if (UInv.isNumber(DstVal)) {
													var TmpAmt = Amount;
													if (!UInv.isUndefined(MinimumValue)) {
														MinimumValue = tryIntParse(MinimumValue);
														if (UInv.isUndefined(MinimumValue)) {
															UInvError('MoveItemPropertyValueToItem failed. If used, MinimumValue must be a number.');  // Error
															return undefined;
														}
														if (SrcVal - Amount < MinimumValue) {  // Can't reduce source below minimum
															Amount = SrcVal - MinimumValue;
														}
														if (DstVal + Amount < MinimumValue) {  // Can't reduce destination below minimum (for when Amount is negative)
															Amount = MinimumValue - DstVal;
														}
													}
													if (!UInv.isUndefined(MaximumValue)) {
														MaximumValue = tryIntParse(MaximumValue);
														if (UInv.isUndefined(MaximumValue)) {
															UInvError('MoveItemPropertyValueToItem failed. If used, MaximumValue must be a number.');  // Error
															return undefined;
														}
														if ((!UInv.isUndefined(MinimumValue)) && (MinimumValue > MaximumValue)) {
															UInvError('MoveItemPropertyValueToItem failed. When both are used, MaximumValue must be greater than MinimumValue.');  // Error
															return undefined;
														}
														if (SrcVal - Amount > MaximumValue) {  // Can't increase source above maximum (for when Amount is negative)
															Amount = SrcVal - MaximumValue;
														}
														if (DstVal + Amount > MaximumValue) {  // Can't increase destination above maximum
															Amount = MaximumValue - DstVal;
														}
													}
													if (((TmpAmt >= 0) && (Amount > TmpAmt)) || ((TmpAmt < 0) && (Amount < TmpAmt))) {
														UInvError('MoveItemPropertyValueToItem failed. Source (' + SrcVal + ') and/or Destination (' + DstVal + ') values are too far out of MinimumValue (' + MinimumValue + ') and/or MaximumValue (' + MaximumValue + ') range.');  // Error
														return undefined;
													}
													if (!UInv.isUndefined(DeletionValue)) {
														DeletionValue = tryIntParse(DeletionValue);
														if (UInv.isUndefined(DeletionValue)) {
															UInvError('MoveItemPropertyValueToItem failed. If used, DeletionValue must be a number.');  // Error
															return undefined;
														}
														if (SrcVal - Amount == DeletionValue) {
															if (UInv.isString(DeletionType)) {
																DeletionType = DeletionType.toLowerCase();
															} else {
																DeletionType = "property";
															}
															switch (DeletionType) {
																case "item":  // delete item
																case "object":  // delete bag or item
																	UInv.DeleteItem(SourceBagName);
																	break;
																case "bag":  // delete bag (do nothing in this case)
																	UInv.SetItemPropertyValue(SourceBagName, SourceItemName, SourceItemPropertyName, SrcVal - Amount);
																	break;
																default:  // delete property
																	UInv.DeleteItemProperty(SourceBagName, SourceItemName, SourceItemPropertyName);
															}
														} else {
															UInv.SetItemPropertyValue(SourceBagName, SourceItemName, SourceItemPropertyName, SrcVal - Amount);
														}
														if (DstVal + Amount == DeletionValue) {
															if (UInv.isString(DeletionType)) {
																DeletionType = DeletionType.toLowerCase();
															} else {
																DeletionType = "property";
															}
															switch (DeletionType) {
																case "item":  // delete item
																case "object":  // delete bag or item
																	UInv.DeleteItem(DestinationBagName, DestinationItemName);
																	break;
																case "bag":  // delete bag (do nothing in this case)
																	UInv.SetItemPropertyValue(DestinationBagName, DestinationItemName, DestinationItemPropertyName, DstVal + Amount);
																	break;
																default:  // delete property
																	UInv.DeleteItemProperty(DestinationBagName, DestinationItemName, DestinationItemPropertyName);
															}
														} else {
															UInv.SetItemPropertyValue(DestinationBagName, DestinationItemName, DestinationItemPropertyName, DstVal + Amount);
														}
														UInv.SetCurrentBagName(DestinationBagName);
														UInv.SetCurrentItemName(DestinationItemName);
														return DstVal + Amount;  // Success
													}
													UInv.SetItemPropertyValue(SourceBagName, SourceItemName, SourceItemPropertyName, SrcVal - Amount);
													UInv.SetItemPropertyValue(DestinationBagName, DestinationItemName, DestinationItemPropertyName, DstVal + Amount);
													UInv.SetCurrentBagName(DestinationBagName);
													UInv.SetCurrentItemName(DestinationItemName);
													return DstVal + Amount;  // Success
												} else {
													UInvError("MoveItemPropertyValueToItem failed. Destination item's property value must be a number to add to or subtract from it.");  // Error
													return undefined;
												}
											} else {
												UInvError("MoveItemPropertyValueToItem failed. Source item's property value must be a number to move an Amount of it.");  // Error
												return undefined;
											}
										} else {
											UInvError('MoveItemPropertyValueToItem failed. If used, Amount must be a number.');  // Error
											return undefined;
										}
									} else {
										var Val = UInv.GetItemPropertyValue(SourceBagName, SourceItemName, SourceItemPropertyName);
										UInv.SetItemPropertyValue(DestinationBagName, DestinationItemName, DestinationItemPropertyName, Val);
										UInv.DeleteItemProperty(SourceBagName, SourceItemName, SourceItemPropertyName);
										UInv.SetCurrentBagName(DestinationBagName);
										UInv.SetCurrentItemName(DestinationItemName);
										return Val;  // Success
									}
								} else {
									UInvError('MoveItemPropertyValueToItem failed. Item "' + SourceItemName + '" in bag "' + SourceBagName + '" does not have property "' + SourceItemPropertyName + '".');  // Error
									return undefined;
								}
							} else {
								UInvError('MoveItemPropertyValueToItem failed. Destination bag "' + DestinationBagName + '" does not contain item "' + DestinationItemName + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('MoveItemPropertyValueToItem failed. Source bag "' + SourceBagName + '" does not contain item "' + SourceItemName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('MoveItemPropertyValueToItem cannot find destination bag "' + DestinationBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('MoveItemPropertyValueToItem cannot find source bag "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to MoveItemPropertyValueToItem is not a string.');  // Error
				return undefined;
			}
		},

		// GetRawItemObject: Returns the raw item object.  FOR INTERNAL/TESTING USE ONLY.
		GetRawItemObject : function (BagName, ItemName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						UInv.SetCurrentBagName(BagName);
						UInv.SetCurrentItemName(ItemName);
						return State.variables.UInvBags[BagName][ItemName];  // Success
					} else {
						UInvError('GetRawItemObject cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetRawItemObject cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetRawItemObject is not a string.');  // Error
				return undefined;
			}
		},


		// UInv Tag Functions:
		// ===================

		// AddBagTag: Add or change a bag property to include BagTag.  If property exists, then the value gets put in an array if it isn't already.  Returns true if it succeeds.
		AddBagTag : function (BagName, BagPropertyName, BagTag) {
			if (UInv.isString(BagPropertyName)) {
				if (UInv.isString(BagName)) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						UInv.SetCurrentBagName(BagName);
						if (!UInv.isUndefined(BagTag)) {
							if (UInv.isArray(BagTag)) {
								var i = 0, AResult = true;
								if (BagTag.length > 0) {
									for (i = 0; i < BagTag.length; i++) {
										if (!UInv.AddBagTag(BagName, BagPropertyName, BagTag[i])) {
											AResult = undefined;
										}
									}
								}
								return AResult;  // Success (or Error)
							} else {
								var Value = [];
								if (UInv.BagHasProperty(BagName, BagPropertyName)) {
									Value = UInv.GetBagPropertyValue(BagName, BagPropertyName);
									if (UInv.isArray(Value)) {
										Value.push(BagTag);
									} else {
										Value = [ Value, BagTag ];
									}
								} else {
									Value = [ BagTag ];
								}
								UInv.SetBagPropertyValue(BagName, BagPropertyName, Value);
								return true;  // Success
							}
						} else {
							UInvError('AddBagTag failed. BagTag not defined.');  // Error
							return undefined;
						}
					} else {
						UInvError('AddBagTag cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else if (UInv.isArrayOfStrings(BagName)) {
					if (UInv.BagExists(BagName)) {
						var j = 0, BResult = true;
						for (j = 0; j < BagName.length; j++) {
							if (!UInv.AddBagTag(BagName[j], BagPropertyName, BagTag)) {
								BResult = undefined;
							}
						}
						return BResult;  // Success (or Error)
					} else {
						UInvError('AddBagTag failed. Invalid bag name in BagName array.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName passed to AddBagTag is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to AddBagTag is not a string.');  // Error
				return undefined;
			}
		},

		// AddItemTag: Add or change a item property to include ItemTag.  If property exists, then the value gets put in an array if it isn't already.  Returns true if it succeeds.
		AddItemTag : function (BagName, ItemName, ItemPropertyName, ItemTag) {
			if (UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				if (UInv.isString(BagName)) {
					BagName = FixBagName(BagName);
					ItemName = FixItemName(ItemName);
					if (UInv.BagExists(BagName)) {
						if (UInv.BagHasItem(BagName, ItemName)) {
							UInv.SetCurrentItemName(ItemName);
							UInv.SetCurrentBagName(BagName);
							if (!UInv.isUndefined(ItemTag)) {
								if (UInv.isArray(ItemTag)) {
									var i = 0, AResult = true;
									if (ItemTag.length > 0) {
										for (i = 0; i < ItemTag.length; i++) {
											if (!UInv.AddItemTag(BagName, ItemName, ItemPropertyName, ItemTag[i])) {
												AResult = undefined;
											}
										}
									}
									return AResult;  // Success (or Error)
								} else {
									var Value = [];
									if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
										Value = UInv.GetItemPropertyValue(BagName, ItemName, ItemPropertyName);  // Handle default item properties
										if (UInv.isArray(Value)) {
											Value.push(ItemTag);
											UInv.SetItemPropertyValue(BagName, ItemName, ItemPropertyName, Value);
											return true;  // Success
										} else {
											Value = [ Value, ItemTag ];
											UInv.SetItemPropertyValue(BagName, ItemName, ItemPropertyName, Value);
											return true;  // Success
										}
									} else {
										Value = [ ItemTag ];
										UInv.SetItemPropertyValue(BagName, ItemName, ItemPropertyName, Value);
										return true;  // Success
									}
								}
							} else {
								UInvError('AddItemTag failed. ItemTag not defined.');  // Error
								return undefined;
							}
						} else {
							UInvError('AddItemTag cannot find item "' + ItemName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('AddItemTag cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else if (UInv.isArrayOfStrings(BagName)) {
					if (UInv.BagExists(BagName)) {
						var j = 0, BResult = true;
						for (j = 0; j < BagName.length; j++) {
							if (!UInv.AddItemTag(BagName[j], ItemName, ItemPropertyName, ItemTag)) {
								BResult = undefined;
							}
						}
						return BResult;  // Success (or Error)
					} else {
						UInvError('AddItemTag failed. Invalid bag name in BagName array.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName passed to AddItemTag is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to AddItemTag is not a string.');  // Error
				return undefined;
			}
		},

		// DeleteBagTag: Delete one instance of BagTag from bag property.  Returns true if it succeeds.
		DeleteBagTag : function (BagName, BagPropertyName, BagTag) {
			if (UInv.isString(BagPropertyName)) {
				if (UInv.isString(BagName)) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						UInv.SetCurrentBagName(BagName);
						if (!UInv.isUndefined(BagTag)) {
							if (UInv.BagHasProperty(BagName, BagPropertyName)) {
								if (UInv.isArray(BagTag)) {
									var i = 0, AResult = true;
									if (BagTag.length > 0) {
										for (i = 0; i < BagTag.length; i++) {
											if (!UInv.DeleteBagTag(BagName, BagPropertyName, BagTag[i])) {
												AResult = undefined;
											}
										}
									}
									return AResult;  // Success (or Error)
								} else {
									var Value = UInv.GetBagPropertyValue(BagName, BagPropertyName);
									if (UInv.isArray(Value)) {
										if (UInv.arrayHasTag(Value, BagTag)) {
											Value.deleteAt(Value.indexOf(BagTag));
											UInv.SetBagPropertyValue(BagName, BagPropertyName, Value);
										}
									} else if (Value === BagTag) {
										UInv.DeleteBagProperty(BagName, BagPropertyName);
									}
									return true;  // Success
								}
							} else {
								return true;  // Success - bag property not found
							}
						} else {
							UInvError('DeleteBagTag failed. BagTag not defined.');  // Error
							return undefined;
						}
					} else {
						UInvError('DeleteBagTag cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else if (UInv.isArrayOfStrings(BagName)) {
					if (UInv.BagExists(BagName)) {
						var j = 0, BResult = true;
						for (j = 0; j < BagName.length; j++) {
							if (!UInv.DeleteBagTag(BagName[j], BagPropertyName, BagTag)) {
								BResult = undefined;
							}
						}
						return BResult;  // Success (or Error)
					} else {
						UInvError('DeleteBagTag failed. Invalid bag name in BagName array.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName passed to DeleteBagTag is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to DeleteBagTag is not a string.');  // Error
				return undefined;
			}
		},

		// DeleteItemTag: Delete one instance of ItemTag from item property.  Returns true if it succeeds.
		DeleteItemTag : function (BagName, ItemName, ItemPropertyName, ItemTag) {
			if (UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				if (UInv.isString(BagName)) {
					BagName = FixBagName(BagName);
					ItemName = FixItemName(ItemName);
					if (UInv.BagExists(BagName)) {
						UInv.SetCurrentBagName(BagName);
						UInv.SetCurrentItemName(ItemName);
						if (!UInv.isUndefined(ItemTag)) {
							if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
								if (UInv.isArray(ItemTag)) {
									var i = 0, AResult = true;
									if (ItemTag.length > 0) {
										for (i = 0; i < ItemTag.length; i++) {
											if (!UInv.DeleteItemTag(BagName, ItemName, ItemPropertyName, ItemTag[i])) {
												AResult = undefined;
											}
										}
									}
									return AResult;  // Success (or Error)
								} else {
									var Value = UInv.GetItemPropertyValue(BagName, ItemName, ItemPropertyName);  // Handle default item properties
									if (UInv.isArray(Value)) {
										if (UInv.arrayHasTag(Value, ItemTag)) {
											Value.deleteAt(Value.indexOf(ItemTag));
											UInv.SetItemPropertyValue(BagName, ItemName, ItemPropertyName, Value);
										}
										return true;  // Success
									} else {
										if (UInv.valuesAreEqual(Value, ItemTag)) {
											UInv.DeleteItemProperty(BagName, ItemName, ItemPropertyName);
										}
										return true;  // Success
									}
								}
							} else {
								return true;  // Success - ItemPropertyName doesn't exist, so it's already "deleted"
							}
						} else {
							UInvError('DeleteItemTag failed. ItemTag not defined.');  // Error
							return undefined;
						}
					} else {
						UInvError('DeleteItemTag cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else if (UInv.isArrayOfStrings(BagName)) {
					if (UInv.BagExists(BagName)) {
						var j = 0, BResult = true;
						for (j = 0; j < BagName.length; j++) {
							if (!UInv.DeleteItemTag(BagName[j], ItemName, ItemPropertyName, ItemTag)) {
								BResult = undefined;
							}
						}
						return BResult;  // Success (or Error)
					} else {
						UInvError('DeleteItemTag failed. Invalid bag name in BagName array.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName passed to DeleteItemTag is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to DeleteItemTag is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasTag: Returns true if bag's property contains the tag.
		BagHasTag : function (BagName, BagPropertyName, BagTag) {
			if (UInv.isString(BagName) && UInv.isString(BagPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					if (!UInv.isUndefined(BagTag)) {
						if (UInv.BagHasProperty(BagName, BagPropertyName)) {
							var Value = UInv.GetBagPropertyValue(BagName, BagPropertyName);
							if (UInv.isArray(Value)) {
								return UInv.arrayHasTag(Value, BagTag);  // Success
							} else {
								return UInv.valuesAreEqual(Value, BagTag);  // Success
							}
						} else {
							return false;  // Success - tag not on bag
						}
					} else {
						UInvError('BagHasTag failed. BagTag not defined.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagHasTag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagHasTag is not a string.');  // Error
				return undefined;
			}
		},

		// ItemHasTag: Returns true if item's property contains the tag.
		ItemHasTag : function (BagName, ItemName, ItemPropertyName, ItemTag) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						UInv.SetCurrentBagName(BagName);
						UInv.SetCurrentItemName(ItemName);
						if (!UInv.isUndefined(ItemTag)) {
							if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
								var Value = UInv.GetItemPropertyValue(BagName, ItemName, ItemPropertyName);
								if (UInv.isArray(Value)) {
									return UInv.arrayHasTag(Value, ItemTag);  // Success
								} else {
									return UInv.valuesAreEqual(Value, ItemTag);  // Success
								}
							} else {
								return false;  // Success - tag not on item
							}
						} else {
							UInvError('ItemHasTag failed. ItemTag not defined.');  // Error
							return undefined;
						}
					} else {
						UInvError('ItemHasTag cannot find item "' + ItemName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ItemHasTag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to ItemHasTag is not a string.');  // Error
				return undefined;
			}
		},

		// ItemHasAllTags: Returns true if item's property contains the tag.
		ItemHasAllTags : function (BagName, ItemName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						if (!UInv.isUndefined(ItemTagArray)) {
							UInv.SetCurrentBagName(BagName);
							UInv.SetCurrentItemName(ItemName);
							if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
								if (UInv.isArray(ItemTagArray)) {
									var i;
									for (i = 0; i < ItemTagArray.length; i++) {
										if (!UInv.ItemHasTag(BagName, ItemName, ItemPropertyName, ItemTagArray[i])) {
											return false;  // Success
										}
									}
									return true;  // Success
								} else {
									return UInv.ItemHasTag(BagName, ItemName, ItemPropertyName, ItemTagArray);  // Success
								}
							} else {
								return false;  // Success - ItemPropertyName not on item
							}
						} else {
							UInvError('ItemHasAllTags failed. ItemTagArray not defined.');  // Error
							return undefined;
						}
					} else {
						UInvError('ItemHasAllTags cannot find item "' + ItemName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ItemHasAllTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to ItemHasAllTags is not a string.');  // Error
				return undefined;
			}
		},

		// ItemHasAnyTag: Returns true if item's property contains the tag.
		ItemHasAnyTag : function (BagName, ItemName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						if (!UInv.isUndefined(ItemTagArray)) {
							UInv.SetCurrentBagName(BagName);
							UInv.SetCurrentItemName(ItemName);
							if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
								if (UInv.isArray(ItemTagArray)) {
									var i;
									for (i = 0; i < ItemTagArray.length; i++) {
										if (UInv.ItemHasTag(BagName, ItemName, ItemPropertyName, ItemTagArray[i])) {
											return true;  // Success
										}
									}
									return false;  // Success
								} else {
									return UInv.ItemHasTag(BagName, ItemName, ItemPropertyName, ItemTagArray);  // Success
								}
							} else {
								return false;  // Success - ItemPropertyName not on item
							}
						} else {
							UInvError('ItemHasAnyTag failed. ItemTagArray not defined.');  // Error
							return undefined;
						}
					} else {
						UInvError('ItemHasAnyTag cannot find item "' + ItemName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ItemHasAnyTag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to ItemHasAnyTag is not a string.');  // Error
				return undefined;
			}
		},

		// SetBagTag: Makes sure it has one of or removes all of tag BagTag based on whether Enabled is true or false, respectively.  Returns true on success.
		SetBagTag : function (BagName, BagPropertyName, BagTag, Enabled) {
			if (UInv.isString(BagPropertyName)) {
				if (UInv.isString(BagName)) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						UInv.SetCurrentBagName(BagName);
						if (!UInv.isUndefined(BagTag)) {
							if (UInv.isBoolean(Enabled)) {
								if (UInv.isArray(BagTag)) {
									var i = 0, AResult = true;
									if (BagTag.length > 0) {
										for (i = 0; i < BagTag.length; i++) {
											if (!UInv.SetBagTag(BagName, BagPropertyName, BagTag[i], Enabled)) {
												AResult = undefined;
											}
										}
									}
									return AResult;  // Success (or Error)
								} else if (Enabled) {
									if (UInv.BagHasProperty(BagName, BagPropertyName)) {  // Make sure it has at least one tag of BagTag
										if (!UInv.BagHasTag(BagName, BagPropertyName, BagTag)) {
											UInv.AddBagTag(BagName, BagPropertyName, BagTag);
										}
									} else {
										UInv.AddBagTag(BagName, BagPropertyName, BagTag);
									}
									return true;  // Success
								} else {
									if (UInv.BagHasProperty(BagName, BagPropertyName)) {  // Make sure it has no tags of BagTag
										while (UInv.BagHasTag(BagName, BagPropertyName, BagTag)) {
											UInv.DeleteBagTag(BagName, BagPropertyName, BagTag);
										}
									}
									return true;  // Success
								}
							} else {
								UInvError('SetBagTag failed. Enabled is not a boolean.');  // Error
								return undefined;
							}
						} else {
							UInvError('SetBagTag failed. BagTag not defined.');  // Error
							return undefined;
						}
					} else {
						UInvError('SetBagTag cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else if (UInv.isArrayOfStrings(BagName)) {
					if (UInv.BagExists(BagName)) {
						var j = 0, BResult = true;
						for (j = 0; j < BagName.length; j++) {
							if (!UInv.SetBagTag(BagName[j], BagPropertyName, BagTag, Enabled)) {
								BResult = undefined;
							}
						}
						return BResult;  // Success (or Error)
					} else {
						UInvError('SetBagTag failed. Invalid bag name in BagName array.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName passed to SetBagTag is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to SetBagTag is not a string.');  // Error
				return undefined;
			}
		},

		// SetItemTag: Makes sure it has one of or removes all of tag ItemTag based on whether Enabled is true or false, respectively.  Returns true on success.
		SetItemTag : function (BagName, ItemName, ItemPropertyName, ItemTag, Enabled) {
			if (UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				if (UInv.isString(BagName)) {
					BagName = FixBagName(BagName);
					ItemName = FixItemName(ItemName);
					if (UInv.BagExists(BagName)) {
						if (UInv.BagHasItem(BagName, ItemName)) {
							UInv.SetCurrentItemName(ItemName);
							UInv.SetCurrentBagName(BagName);
							if (!UInv.isUndefined(ItemTag)) {
								if (UInv.isArray(ItemTag)) {
									var i = 0, AResult = true;
									if (ItemTag.length > 0) {
										for (i = 0; i < ItemTag.length; i++) {
											if (!UInv.SetItemTag(BagName, ItemName, ItemPropertyName, ItemTag[i], Enabled)) {
												AResult = undefined;
											}
										}
									}
									return AResult;  // Success (or Error)
								} else if (Enabled) {
									if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {  // Make sure it has at least one tag of ItemTag
										if (!UInv.ItemHasTag(BagName, ItemName, ItemPropertyName, ItemTag)) {
											UInv.AddItemTag(BagName, ItemName, ItemPropertyName, ItemTag);
										}
									} else {
										UInv.AddItemTag(BagName, ItemName, ItemPropertyName, ItemTag);
									}
									return true;  // Success
								} else {
									if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {  // Make sure it has no tags of ItemTag
										while (UInv.ItemHasTag(BagName, ItemName, ItemPropertyName, ItemTag)) {
											UInv.DeleteItemTag(BagName, ItemName, ItemPropertyName, ItemTag);
										}
									}
									return true;  // Success
								}
							} else {
								UInvError('SetItemTag failed. ItemTag not defined.');  // Error
								return undefined;
							}
						} else {
							UInvError('SetItemTag cannot find item "' + ItemName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('SetItemTag cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else if (UInv.isArrayOfStrings(BagName)) {
					if (UInv.BagExists(BagName)) {
						var j = 0, BResult = true;
						for (j = 0; j < BagName.length; j++) {
							if (!UInv.SetItemTag(BagName[j], ItemName, ItemPropertyName, ItemTag, Enabled)) {
								BResult = undefined;
							}
						}
						return BResult;  // Success (or Error)
					} else {
						UInvError('SetItemTag failed. Invalid bag name in BagName array.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName passed to SetItemTag is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to SetItemTag is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagsArrayByBagTag: Returns an array of bag names for all bags that have BagTag in their BagPropertyName property.
		GetBagsArrayByBagTag : function (BagPropertyName, BagTag) {
			if (UInv.isString(BagPropertyName)) {
				if (!UInv.isUndefined(BagTag)) {
					var Bags = [], BagList = UInv.GetBagsArray(), i = 0;
					if (BagList.length > 0) {
						for (i = 0; i < BagList.length; i++) {
							if (UInv.BagHasTag(BagList[i], BagPropertyName, BagTag)) {
								Bags.push(BagList[i]);
							}
						}
					}
					return Bags;  // Success
				} else {
					UInvError('GetBagsArrayByBagTag failed. BagTag parameter is missing.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to GetBagsArrayByBagTag is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasAllBagTags: Returns true if the bag's property's value (which must be an array) has an equal or greater number of all tags in BagTagArray.  (true if BagTagArray is empty)
		BagHasAllBagTags : function (BagName, BagPropertyName, BagTagArray) {
			if (UInv.isString(BagName) && UInv.isString(BagPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					if (UInv.BagHasProperty(BagName, BagPropertyName)) {
						if (UInv.isArray(UInv.GetBagPropertyValue(BagPropertyName)) && UInv.isArray(BagTagArray)) {
							return UInv.arrayHasAllTags(UInv.GetBagPropertyValue(BagPropertyName), BagTagArray);
						} else {
							UInv.Error("Error: BagHasAllBagTags failed. Both BagPropertyName's value and BagTagArray parameter must be arrays.");  // Error
							return undefined;
						}
					} else {
						UInvError('BagHasAllBagTags cannot find bag property "' + BagPropertyName + '" on bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('BagHasAllBagTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagHasAllBagTags is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasAnyBagTag: Returns true if the bag's property's value (which must be an array) has any of the tags in BagTagArray.  (false if BagTagArray is empty)
		BagHasAnyBagTag : function (BagName, BagPropertyName, BagTagArray) {
			if (UInv.isString(BagName) && UInv.isString(BagPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					if (UInv.BagHasProperty(BagName, BagPropertyName)) {
						if (UInv.isArray(UInv.GetBagPropertyValue(BagPropertyName)) && UInv.isArray(BagTagArray)) {
							return UInv.arrayHasAnyTag(UInv.GetBagPropertyValue(BagPropertyName), BagTagArray);
						} else {
							UInv.Error("Error: BagHasAnyBagTag failed. Both BagPropertyName's value and BagTagArray parameter must be arrays.");  // Error
							return undefined;
						}
					} else {
						UInvError('BagHasAnyBagTag cannot find bag property "' + BagPropertyName + '" on bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('BagHasAnyBagTag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagHasAnyBagTag is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayByAllItemTags: Returns array of item names in bag with all tags.
		GetItemsArrayByAllItemTags : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0, Result = [];
					for (i = 0; i < Items.length; i++) {
						if (UInv.ItemHasAllTags(BagName, Items[i], ItemPropertyName, ItemTagArray)) {
							Result.push(Items[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetItemsArrayByAllItemTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayByAllItemTags is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayByAnyItemTag: Returns array of item names in bag with any tags.
		GetItemsArrayByAnyItemTag : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0, Result = [];
					for (i = 0; i < Items.length; i++) {
						if (UInv.ItemHasAnyTag(BagName, Items[i], ItemPropertyName, ItemTagArray)) {
							Result.push(Items[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetItemsArrayByAnyItemTag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayByAnyItemTag is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayWithoutAllItemTags: Returns array of item names in bag without any of the tags.
		GetItemsArrayWithoutAllItemTags : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0, Result = [];
					for (i = 0; i < Items.length; i++) {
						if (!UInv.ItemHasAllTags(BagName, Items[i], ItemPropertyName, ItemTagArray)) {
							Result.push(Items[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetItemsArrayWithoutAllItemTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayWithoutAllItemTags is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayWithoutAnyItemTags: Returns array of item names in bag without any of the tags.
		GetItemsArrayWithoutAnyItemTags : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0, Result = [];
					for (i = 0; i < Items.length; i++) {
						if (!UInv.ItemHasAnyTag(BagName, Items[i], ItemPropertyName, ItemTagArray)) {
							Result.push(Items[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetItemsArrayWithoutAnyItemTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayWithoutAnyItemTags is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayByItemTag: Returns array of item names in bag which have that tag.
		GetItemsArrayByItemTag : function (BagName, ItemPropertyName, ItemTag) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0, Result = [];
					for (i = 0; i < Items.length; i++) {
						if (UInv.ItemHasTag(BagName, Items[i], ItemPropertyName, ItemTag)) {
							Result.push(Items[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetItemsArrayByItemTag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayByItemTag is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagsArrayWithItemByBagTag: Returns array of bag names from bags with bag tag and item.
		GetBagsArrayWithItemByBagTag : function (BagPropertyName, BagTag, ItemName) {
			if (UInv.isString(BagPropertyName) && UInv.isString(ItemName)) {
				var Bags = UInv.GetBagsArray(), i = 0, Result = [];
				if (Bags.length > 0) {
					for (i = 0; i < Bags.length; i++) {
						if (UInv.BagHasTag(Bags[i], BagPropertyName, BagTag) && UInv.BagHasItem(Bags[i], ItemName)) {
							Result.push(Bags[i]);
						}
					}
				}
				return Result;  // Success
			} else {
				UInvError('Name passed to GetBagsArrayWithItemByBagTag is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagsArrayWithBothBagTags: Returns array of bag names with both tags on their respective bag properties.
		GetBagsArrayWithBothBagTags : function (BagPropertyName1, BagTag1, BagPropertyName2, BagTag2) {
			if (UInv.isString(BagPropertyName1) && UInv.isString(BagPropertyName2)) {
				var Bags = UInv.GetBagsArray(), i = 0, Result = [];
				if (Bags.length > 0) {
					for (i = 0; i < Bags.length; i++) {
						if (UInv.BagHasTag(Bags[i], BagPropertyName1, BagTag1) && UInv.BagHasTag(Bags[i], BagPropertyName2, BagTag2)) {
							Result.push(Bags[i]);
						}
					}
				}
				return Result;  // Success
			} else {
				UInvError('Name passed to GetBagsArrayWithBothBagTags is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayWithBothItemTags: Returns array of item names with both tags on their respective item properties in a bag.
		GetItemsArrayWithBothItemTags : function (BagName, ItemPropertyName1, ItemTag1, ItemPropertyName2, ItemTag2) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName1) && UInv.isString(ItemPropertyName2)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0, Result = [];
					for (i = 0; i < Items.length; i++) {
						if (UInv.ItemHasTag(BagName, Items[i], ItemPropertyName1, ItemTag1) && UInv.ItemHasTag(BagName, Items[i], ItemPropertyName2, ItemTag2)) {
							Result.push(Items[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetItemsArrayWithBothItemTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayWithBothItemTags is not a string.');  // Error
				return undefined;
			}
		},

		// GetUniqueBagTagsArray: Returns an array of unique bag tags (no duplicates) for this bag property.  Checks all bags if BagName is undefined.
		GetUniqueBagTagsArray : function (BagPropertyName, BagName) {
			if (UInv.isString(BagPropertyName)) {
				if (UInv.isUndefined(BagName)) {
					BagName = UInv.GetBagsArray();
				}
				var Result = [], i = 0;
				if (UInv.isString(BagName)) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						UInv.SetCurrentBagName(BagName);
						if (UInv.BagHasProperty(BagName, BagPropertyName)) {
							var Tags = UInv.GetBagPropertyValue(BagName, BagPropertyName);
							if (UInv.isArray(Tags)) {
								if (Tags.length > 0) {
									for (i = 0; i < Tags.length; i++) {
										Result.push(Tags[i]);
									}
								}
								return [].concatUnique(Result);  // Success
							} else {
								return [ Tags ];  // Success
							}
						} else {
							return [];  // Success
						}
					} else {
						UInvError('GetUniqueBagTagsArray cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else if (UInv.isArrayOfStrings(BagName)) {
					if (UInv.BagExists(BagName)) {
						var Tmp;
						if (BagName.length > 0) {
							for (i = 0; i < BagName.length; i++) {
								Tmp = UInv.GetUniqueBagTagsArray(BagPropertyName, BagName[i]);
								if (UInv.isUndefined(Tmp) || UInv.isUndefined(Result)) {
									Result = undefined;
									break;
								} else {
									Result = Result.concatUnique(Tmp);
								}
							}
						}
						return Result;  // Success (or Error, shouldn't happen)
					} else {
						UInvError('BagName array passed to GetUniqueBagTagsArray contains an invalid bag name.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName passed to GetUniqueBagTagsArray is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to GetUniqueBagTagsArray is not a string.');  // Error
				return undefined;
			}
		},

		// GetUniqueItemTagsArray: Returns an array unique item tags (no duplicates) for this item property.  Uses all bags if BagName is undefined.
		GetUniqueItemTagsArray : function (ItemPropertyName, BagName) {
			if (UInv.isString(ItemPropertyName)) {
				if (UInv.isUndefined(BagName)) {
					BagName = UInv.GetBagsArray();
				}
				var Result = [], i = 0;
				if (UInv.isString(BagName)) {
					BagName = FixBagName(BagName);
					if (UInv.BagExists(BagName)) {
						UInv.SetCurrentBagName(BagName);
						if (UInv.GetItemCount(BagName) > 0) {
							var Items = UInv.GetItemsArray(BagName);
							for (i = 0; i < Items.length; i++) {
								if (UInv.ItemHasProperty(BagName, Items[i], ItemPropertyName)) {
									var Tags = UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName);
									if (UInv.isArray(Tags)) {
										Result = Result.concatUnique(Tags);
									} else {
										Result = Result.concatUnique([ Tags ]);
									}
								}
							}
						}
						return Result;  // Success
					} else {
						UInvError('GetUniqueItemTagsArray cannot find bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else if (UInv.isArrayOfStrings(BagName)) {
					if (UInv.BagExists(BagName)) {
						var Tmp;
						if (BagName.length > 0) {
							for (i = 0; i < BagName.length; i++) {
								Tmp = UInv.GetUniqueItemTagsArray(ItemPropertyName, BagName[i]);
								if (UInv.isUndefined(Tmp) || UInv.isUndefined(Result)) {
									Result = undefined;
									break;
								} else {
									Result = Result.concatUnique(Tmp);
								}
							}
						}
						return Result;  // Success (or Error, shouldn't happen)
					} else {
						UInvError('BagName array passed to GetUniqueItemTagsArray contains an invalid bag name.');  // Error
						return undefined;
					}
				} else {
					UInvError('BagName passed to GetUniqueItemTagsArray is not a string or an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('ItemPropertyName passed to GetUniqueItemTagsArray is not a string.');  // Error
				return undefined;
			}
		},

		// GetAllUniqueItemTagsArray: Returns an array of all unique item tags in the ItemPropertName property for all items in bag.
		GetAllUniqueItemTagsArray : function (BagName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0, Result = [], Tags = [];
					if (Items.length > 0) {
						for (i = 0; i < Items.length; i++) {
							if (UInv.ItemHasProperty(BagName, Items[i], ItemPropertyName)) {
								Tags = UInv.GetItemPropertyValue(BagName, Items[i], ItemPropertyName);
								if (UInv.isArray(Tags)) {
									Result = Result.concatUnique(Tags);
								} else {
									Result = Result.concatUnique([ Tags ]);  // Success
								}
							}
						}
					}
					return Result;
				} else {
					UInvError('GetAllUniqueItemTagsArray cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetAllUniqueItemTagsArray is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasAllItemTags: Returns whether bag's items have all ItemTagArray tags in the ItemPropertyName property among its items.
		BagHasAllItemTags : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					if (!UInv.isArray(ItemTagArray)) {
						ItemTagArray = [ ItemTagArray ];
					}
					var Tags = UInv.GetAllUniqueItemTagsArray(BagName, ItemPropertyName), i = 0, Result = 0;
					for (i = 0; i < ItemTagArray.length; i++) {
						if (Tags.includes(ItemTagArray[i])) {
							Result += 1;
						}
					}
					return Result === ItemTagArray.length;  // Success
				} else {
					UInvError('BagHasAllItemTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagHasAllItemTags is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasAnyItemTag: Returns whether any of bag's items have ItemTagArray tag in their ItemPropertyName property.
		BagHasAnyItemTag : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					if (!UInv.isArray(ItemTagArray)) {
						ItemTagArray = [ ItemTagArray ];
					}
					var Tags = UInv.GetAllUniqueItemTagsArray(BagName, ItemPropertyName), i = 0;
					for (i = 0; i < ItemTagArray.length; i++) {
						if (Tags.includes(ItemTagArray[i])) {
							return true;  // Success
						}
					}
					return false;  // Success
				} else {
					UInvError('BagHasAnyItemTag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagHasAnyItemTag is not a string.');  // Error
				return undefined;
			}
		},

		// GetFullItemCountByAllItemTags: Returns full number of items with all item property tags.
		GetFullItemCountByAllItemTags : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0, Result = 0;
					for (i = 0; i < Items.length; i++) {
						if (UInv.ItemHasAllTags(BagName, Items[i], ItemPropertyName, ItemTagArray)) {
							Result += UInv.BagHasItem(BagName, Items[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetFullItemCountByAllItemTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetFullItemCountByAllItemTags is not a string.');  // Error
				return undefined;
			}
		},

		// GetFullItemCountByAnyItemTag: Returns full number of items with any item property tags.
		GetFullItemCountByAnyItemTag : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0, Result = 0;
					for (i = 0; i < Items.length; i++) {
						if (UInv.ItemHasAnyTag(BagName, Items[i], ItemPropertyName, ItemTagArray)) {
							Result += UInv.BagHasItem(BagName, Items[i]);
						}
					}
					return Result;  // Success
				} else {
					UInvError('GetFullItemCountByAnyItemTag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetFullItemCountByAnyItemTag is not a string.');  // Error
				return undefined;
			}
		},

		// GetBagTagQuantityObject: Returns an object with TagName : TagQuantity pairs.  { "UniqueBagTag1" : QuantityOfBagTag1, ... }
		GetBagTagQuantityObject : function (BagName, BagPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(BagPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasProperty(BagName, BagPropertyName)) {
						var Tags = UInv.GetBagPropertyValue(BagName, BagPropertyName);
						UInv.SetCurrentBagName(BagName);
						if (UInv.isArray(Tags)) {
							var UniqueTags = [].concatUnique(Tags), i = 0, Result = {};
							for (i = 0; i < UniqueTags.length; i++) {
								Result[UniqueTags[i]] = Tags.count(UniqueTags[i]);
							}
							return Result;  // Success
						} else {
							var Tmp = {};
							Tmp[Tags] = 1;
							return Tmp;  // Success
						}
					} else {
						UInvError('GetBagTagQuantityObject failed. Bag "' + BagName + '" does not have property "' + BagPropertyName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetBagTagQuantityObject cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetBagTagQuantityObject is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemTagQuantityObject: Returns an object with TagName : TagQuantity pairs.  { "UniqueItemTag1" : QuantityOfItemTag1, ... }
		GetItemTagQuantityObject : function (BagName, ItemName, ItemPropertyName) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
							var Tags = UInv.GetItemPropertyValue(BagName, ItemName, ItemPropertyName);
							UInv.SetCurrentBagName(BagName);
							UInv.SetCurrentItemName(ItemName);
							if (UInv.isArray(Tags)) {
								var UniqueTags = [].concatUnique(Tags), i = 0, Result = {};
								for (i = 0; i < UniqueTags.length; i++) {
									Result[UniqueTags[i]] = Tags.count(UniqueTags[i]);
								}
								return Result;  // Success
							} else {
								var Tmp = {};
								Tmp[Tags] = 1;
								return Tmp;  // Success
							}
						} else {
							UInvError('GetItemTagQuantityObject failed. Item "' + ItemName + '" does not have property "' + ItemPropertyName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('GetItemTagQuantityObject cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemTagQuantityObject cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemTagQuantityObject is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasItemByItemTag: Returns true if any item in bag has tag ItemTag, false if none do, or undefined on error.
		BagHasItemByItemTag : function (BagName, ItemPropertyName, ItemTag) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0;
					for (i = 0; i < Items.length; i++) {
						if (UInv.ItemHasTag(BagName, Items[i], ItemPropertyName, ItemTag)) {
							return true;  // Success
						}
					}
					return false;  // Success
				} else {
					UInvError('BagHasItemByItemTag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagHasItemByItemTag is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasItemWithAllItemTags: Returns true if any items in bag have all tags in ItemTagArray, false if none do, or undefined on error.
		BagHasItemWithAllItemTags : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0;
					for (i = 0; i < Items.length; i++) {
						if (UInv.ItemHasAllTags(BagName, Items[i], ItemPropertyName, ItemTagArray)) {
							return true;  // Success
						}
					}
					return false;  // Success
				} else {
					UInvError('BagHasItemWithAllItemTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagHasItemWithAllItemTags is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasItemWithAnyItemTag: Returns true if any items in bag have any tags in ItemTagArray, false if none do, or undefined on error.
		BagHasItemWithAnyItemTag : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0;
					for (i = 0; i < Items.length; i++) {
						if (UInv.ItemHasAnyTag(BagName, Items[i], ItemPropertyName, ItemTagArray)) {
							return true;  // Success
						}
					}
					return false;  // Success
				} else {
					UInvError('BagHasItemWithAnyItemTag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagHasItemWithAnyItemTag is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasItemWithoutAllItemTags: Returns true if any items in bag do not have all tags in ItemTagArray, false if none do, or undefined on error.
		BagHasItemWithoutAllItemTags : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0;
					for (i = 0; i < Items.length; i++) {
						if (!UInv.ItemHasAllTags(BagName, Items[i], ItemPropertyName, ItemTagArray)) {
							return true;  // Success
						}
					}
					return false;  // Success
				} else {
					UInvError('BagHasItemWithoutAllItemTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagHasItemWithoutAllItemTags is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasItemWithoutAnyItemTags: Returns true if any items in bag do not have any tags in ItemTagArray, false if none do, or undefined on error.
		BagHasItemWithoutAnyItemTags : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					var Items = UInv.GetItemsArray(BagName), i = 0;
					for (i = 0; i < Items.length; i++) {
						if (!UInv.ItemHasAnyTag(BagName, Items[i], ItemPropertyName, ItemTagArray)) {
							return true;  // Success
						}
					}
					return false;  // Success
				} else {
					UInvError('BagHasItemWithoutAnyItemTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to BagHasItemWithoutAnyItemTags is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasItemByBagTag: Returns true if any bags with BagPropertyName/BagTag have item, false if none do, or undefined on error.
		BagHasItemByBagTag : function (BagPropertyName, BagTag, ItemName) {
			if (UInv.isString(BagPropertyName) && UInv.isString(ItemName)) {
				var Bags = UInv.GetBagsArray(), i = 0;
				if (Bags.length > 0) {
					for (i = 0; i < Bags.length; i++) {
						if (UInv.BagHasTag(Bags[i], BagPropertyName, BagTag) && UInv.BagHasItem(Bags[i], ItemName)) {
							return true;  // Success
						}
					}
				}
				return false;  // Success
			} else {
				UInvError('Name passed to BagHasItemByBagTag is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasAllItemsByBagTag: Returns true if any bag with BagPropertyName/BagTag has all of the items in ItemNameArray, false if none do, or undefined on error.
		BagHasAllItemsByBagTag : function (BagPropertyName, BagTag, ItemNameArray) {
			if (UInv.isString(BagPropertyName)) {
				if (UInv.isArrayOfStrings(ItemNameArray)) {
					var Bags = UInv.GetBagsArray(), i = 0;
					if (Bags.length > 0) {
						for (i = 0; i < Bags.length; i++) {
							if (UInv.BagHasTag(Bags[i], BagPropertyName, BagTag) && UInv.BagHasAllItems(Bags[i], ItemNameArray)) {
								return true;  // Success
							}
						}
					}
					return false;  // Success
				} else {
					UInvError('ItemNameArray passed to BagHasAllItemsByBagTag is not an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to BagHasAllItemsByBagTag is not a string.');  // Error
				return undefined;
			}
		},

		// BagHasAnyItemByBagTag: Returns true if any bag with BagPropertyName/BagTag has any of the items in ItemName/Array, false if none do, or undefined on error.
		BagHasAnyItemByBagTag : function (BagPropertyName, BagTag, ItemNameArray) {
			if (UInv.isString(BagPropertyName)) {
				if (UInv.isArrayOfStrings(ItemNameArray)) {
					var Bags = UInv.GetBagsArray(), i = 0;
					if (Bags.length > 0) {
						for (i = 0; i < Bags.length; i++) {
							if (UInv.BagHasTag(Bags[i], BagPropertyName, BagTag) && UInv.BagHasAnyItems(Bags[i], ItemNameArray)) {
								return true;  // Success
							}
						}
					}
					return false;  // Success
				} else {
					UInvError('ItemNameArray passed to BagHasAnyItemByBagTag is not an array of strings.');  // Error
					return undefined;
				}
			} else {
				UInvError('BagPropertyName passed to BagHasAnyItemByBagTag is not a string.');  // Error
				return undefined;
			}
		},

		// CopyItemsByItemTag: Copy all items from SourceBagName to DestinationBagName which have ItemTag in the items' ItemPropertyName.
		CopyItemsByItemTag : function (SourceBagName, DestinationBagName, ItemPropertyName, ItemTag) {
			if (UInv.isString(SourceBagName) && UInv.isString(DestinationBagName) && UInv.isString(ItemPropertyName)) {
				SourceBagName = FixBagName(SourceBagName);
				DestinationBagName = FixBagName(DestinationBagName);
				if (UInv.BagExists(SourceBagName)) {
					if (UInv.BagExists(DestinationBagName)) {
						if (SourceBagName !== DestinationBagName) {
							var Items = UInv.GetItemsArrayByItemTag(SourceBagName, ItemPropertyName, ItemTag), Result = [];
							if (Items.length > 0) {
								var i = 0, Ret;
								for (i = 0; i < Items.length; i++) {
									Ret = UInv.CopyItem(SourceBagName, DestinationBagName, Items[i]);
									if (Ret === undefined) {
										Result = undefined;
									} else if (!UInv.isBoolean(Result)) {
										Result.push(Ret);
									}
								}
							}
							return Result;  // Success or Error  ***
						} else {
							UInvError('CopyItemsByItemTag failed. Source and destination bags cannot be the same.');  // Error
							return undefined;
						}
					} else {
						UInvError('CopyItemsByItemTag cannot find bag "' + DestinationBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('CopyItemsByItemTag cannot find bag "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to CopyItemsByItemTag is not a string.');  // Error
				return undefined;
			}
		},

		// MoveItemsByItemTag: Move all items from SourceBagName to DestinationBagName which have ItemTag in the items' ItemPropertyName.
		MoveItemsByItemTag : function (SourceBagName, DestinationBagName, ItemPropertyName, ItemTag) {
			if (UInv.isString(SourceBagName) && UInv.isString(DestinationBagName) && UInv.isString(ItemPropertyName)) {
				SourceBagName = FixBagName(SourceBagName);
				DestinationBagName = FixBagName(DestinationBagName);
				if (UInv.BagExists(SourceBagName)) {
					if (UInv.BagExists(DestinationBagName)) {
						if (SourceBagName !== DestinationBagName) {
							var Items = UInv.GetItemsArrayByItemTag(SourceBagName, ItemPropertyName, ItemTag), Result = true;
							if (Items.length > 0) {
								var i = 0, Ret = "";
								for (i = 0; i < Items.length; i++) {
									Ret = UInv.MoveItem(SourceBagName, DestinationBagName, Items[i]);
									if (UInv.isUndefined(Ret) || UInv.isUndefined(Result)) {
										Result = undefined;
									} else {
										if (UInv.isBoolean(Result)) {
											Result = [ Ret ];
										} else {
											Result.push(Ret);
										}
									}
								}
							}
							return Result;  // Success
						} else {
							UInvError('MoveItemsByItemTag failed. Source and destination bags cannot be the same.');  // Error
							return undefined;
						}
					} else {
						UInvError('MoveItemsByItemTag cannot find bag "' + DestinationBagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('MoveItemsByItemTag cannot find bag "' + SourceBagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to MoveItemsByItemTag is not a string.');  // Error
				return undefined;
			}
		},

		// DeleteItemsByItemTag: Delete all items from BagName which have ItemTag in the items' ItemPropertyName.
		DeleteItemsByItemTag : function (BagName, ItemPropertyName, ItemTag) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					return UInv.DeleteItem(BagName, UInv.GetItemsArrayByItemTag(BagName, ItemPropertyName, ItemTag));  // Success
				} else {
					UInvError('DeleteItemsByItemTag cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to DeleteItemsByItemTag is not a string.');  // Error
				return undefined;
			}
		},

		// GetMissingBagTagsArray: Returns an array of all tags in BagTagArray which were not found on the BagPropertyName for that bag, or undefined on error.
		GetMissingBagTagsArray : function (BagName, BagPropertyName, BagTagArray) {
			if (UInv.isString(BagName) && UInv.isString(BagPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasProperty(BagName, BagPropertyName)) {
						UInv.SetCurrentBagName(BagName);
						var Tags = UInv.GetBagPropertyValue(BagName, BagPropertyName);
						if (!UInv.isArray(Tags)) {
							Tags = [ Tags ];
						}
						if (!UInv.isArray(BagTagArray)) {
							BagTagArray = [ BagTagArray ];
						}
						if (BagTagArray.length > 0) {
							var i = 0, Result = [];
							for (i = 0; i < BagTagArray.length; i++) {
								if (!Tags.includes(BagTagArray[i])) {
									Result.push(BagTagArray[i]);
								}
							}
							return Result;  // Success
						} else {
							return [];  // Success
						}
					} else {
						UInvError('GetMissingBagTagsArray failed. Bag "' + BagName + '" does not have property "' + BagPropertyName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetMissingBagTagsArray cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetMissingBagTagsArray is not a string.');  // Error
				return undefined;
			}
		},

		// GetMissingItemTagsArray: Returns an array of all tags in ItemTagArray which were not found on the items' ItemPropertyName in that bag, or undefined on error.
		GetMissingItemTagsArray : function (BagName, ItemName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
							UInv.SetCurrentBagName(BagName);
							UInv.SetCurrentItemName(ItemName);
							var Tags = UInv.GetItemPropertyValue(BagName, ItemName, ItemPropertyName);
							if (!UInv.isArray(Tags)) {
								Tags = [ Tags ];
							}
							if (!UInv.isArray(ItemTagArray)) {
								ItemTagArray = [ ItemTagArray ];
							}
							if (ItemTagArray.length > 0) {
								var i = 0, Result = [];
								for (i = 0; i < ItemTagArray.length; i++) {
									if (!Tags.includes(ItemTagArray[i])) {
										Result.push(ItemTagArray[i]);
									}
								}
								return Result;  // Success
							} else {
								return [];  // Success
							}
						} else {
							UInvError('GetMissingItemTagsArray failed. Item "' + ItemName + '" does not have property "' + ItemPropertyName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('GetMissingItemTagsArray cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetMissingItemTagsArray cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetMissingItemTagsArray is not a string.');  // Error
				return undefined;
			}
		},

		// GetRandomBagTagFromRange: Returns a random tag from LowIndex to HighIndex (inclusive), returns undefined on error.
		GetRandomBagTagFromRange : function (BagName, BagPropertyName, HighIndex, LowIndex) {
			if (UInv.isString(BagName) && UInv.isString(BagPropertyName)) {
				if (UInv.isUndefined(LowIndex)) {
					LowIndex = 0;
				}
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasProperty(BagName, BagPropertyName)) {
						var Tags = UInv.GetBagPropertyValue(BagName, BagPropertyName);
						if (UInv.isArray(Tags)) {
							HighIndex = tryIntParse(HighIndex);
							LowIndex = tryIntParse(LowIndex);
							if (UInv.isInteger(HighIndex)) {
								if (UInv.isInteger(LowIndex)) {
									if ((LowIndex >= 0) && (LowIndex <= HighIndex)) {
										if ((HighIndex >= LowIndex) && (HighIndex < Tags.length)) {
											UInv.SetCurrentBagName(BagName);
											return Tags[random(LowIndex, HighIndex)];  // Success
										} else {
											UInv.Error("Error: GetRandomBagTagFromRange failed. HighIndex must be >= LowIndex and =< the highest array index for that property's array.");  // Error
											return undefined;
										}
									} else {
										UInvError('GetRandomBagTagFromRange failed. LowIndex must be >= 0 and < HighIndex.');  // Error
										return undefined;
									}
								} else {
									UInvError('GetRandomBagTagFromRange failed. LowIndex must be an integer.');  // Error
									return undefined;
								}
							} else {
								UInvError('GetRandomBagTagFromRange failed. HighIndex must be an integer.');  // Error
								return undefined;
							}
						} else {
							UInvError('GetRandomBagTagFromRange failed. Bag property "' + BagPropertyName + '" on bag "' + BagName + '" is not an array.');  // Error
							return undefined;
						}
					} else {
						UInvError('GetRandomBagTagFromRange cannot find property "' + BagPropertyName + '" on bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetRandomBagTagFromRange cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetRandomBagTagFromRange is not a string.');  // Error
				return undefined;
			}
		},

		// GetRandomItemTagFromRange: Returns a random tag from LowIndex to HighIndex (inclusive), returns undefined on error.
		GetRandomItemTagFromRange : function (BagName, ItemName, ItemPropertyName, HighIndex, LowIndex) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				if (UInv.isUndefined(LowIndex)) {
					LowIndex = 0;
				}
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
							var Tags = UInv.GetItemPropertyValue(BagName, ItemName, ItemPropertyName);
							if (UInv.isArray(Tags)) {
								HighIndex = tryIntParse(HighIndex);
								LowIndex = tryIntParse(LowIndex);
								if (UInv.isInteger(HighIndex)) {
									if (UInv.isInteger(LowIndex)) {
										if ((LowIndex >= 0) && (LowIndex <= HighIndex)) {
											if ((HighIndex >= LowIndex) && (HighIndex < Tags.length)) {
												UInv.SetCurrentBagName(BagName);
												UInv.SetCurrentItemName(ItemName);
												return Tags[random(LowIndex, HighIndex)];  // Success
											} else {
												UInv.Error("Error: GetRandomItemTagFromRange failed. HighIndex must be >= LowIndex and =< the highest array index for that property's array.");  // Error
												return undefined;
											}
										} else {
											UInvError('GetRandomItemTagFromRange failed. LowIndex must be >= 0 and < HighIndex.');  // Error
											return undefined;
										}
									} else {
										UInvError('GetRandomItemTagFromRange failed. LowIndex must be an integer.');  // Error
										return undefined;
									}
								} else {
									UInvError('GetRandomItemTagFromRange failed. HighIndex must be an integer.');  // Error
									return undefined;
								}
							} else {
								UInvError('GetRandomItemTagFromRange failed. Item property "' + ItemPropertyName + '" on item "' + ItemName + '" is not an array.');  // Error
								return undefined;
							}
						} else {
							UInvError('GetRandomItemTagFromRange cannot find property "' + ItemPropertyName + '" on item "' + ItemName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('GetRandomItemTagFromRange cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetRandomItemTagFromRange cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetRandomItemTagFromRange is not a string.');  // Error
				return undefined;
			}
		},

		// ArrayHasAllItemTags: Returns whether all of the item's tags exist in ItemTagArray, or undefined on error.
		ArrayHasAllItemTags : function (BagName, ItemName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
							UInv.SetCurrentBagName(BagName);
							UInv.SetCurrentItemName(ItemName);
							var Tags = UInv.GetItemPropertyValue(BagName, ItemName, ItemPropertyName);
							if (!UInv.isArray(Tags)) {
								Tags = [ Tags ];
							}
							if (!UInv.isArray(ItemTagArray)) {
								ItemTagArray = [ ItemTagArray ];
							}
							if ((Tags.length > 0) && (ItemTagArray.length > 0)) {
								var i;
								for (i = 0; i < Tags.length; i++) {
									if (!ItemTagArray.includes(Tags[i])) {
										return false;
									}
								}
								return true;  // Success
							} else {
								return false;  // Success
							}
						} else {
							UInvError('ArrayHasAllItemTags failed. Item "' + ItemName + '" does not have property "' + ItemPropertyName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('ArrayHasAllItemTags cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('ArrayHasAllItemTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to ArrayHasAllItemTags is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayWithAllItemTags: Returns an array of all items which have all of their tags in ItemTagArray (per the ArrayHasAllItemTags function), [] if ItemTagArray or the bag is empty, or undefined on error.
		GetItemsArrayWithAllItemTags : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					if (!UInv.isArray(ItemTagArray)) {
						ItemTagArray = [ ItemTagArray ];
					}
					var Items = UInv.GetItemsArray(BagName), Result = [];
					if (Items.length > 0) {
						var i;
						for (i = 0; i < Items.length; i++) {
							if (UInv.ItemHasProperty(BagName, Items[i], ItemPropertyName)) {
								if (UInv.ArrayHasAllItemTags(BagName, Items[i], ItemPropertyName, ItemTagArray)) {
									Result.push(Items[i]);
								}
							}
						}
						return Result;  // Success
					} else {
						return [];  // Success
					}
				} else {
					UInvError('GetItemsArrayWithAllItemTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayWithAllItemTags is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemTagCount: Returns the number of times an exact match for Tag is found in an item's tag array, or undefined on error.
		GetItemTagCount : function (BagName, ItemName, ItemPropertyName, Tag) {
			if (UInv.isString(BagName) && UInv.isString(ItemName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				ItemName = FixItemName(ItemName);
				if (UInv.BagExists(BagName)) {
					if (UInv.BagHasItem(BagName, ItemName)) {
						if (UInv.ItemHasProperty(BagName, ItemName, ItemPropertyName)) {
							UInv.SetCurrentBagName(BagName);
							UInv.SetCurrentItemName(ItemName);
							var Tags = UInv.GetItemPropertyValue(BagName, ItemName, ItemPropertyName), Result = 0;
							if (!UInv.isArray(Tags)) {
								Tags = [ Tags ];
							}
							if (Tags.length > 0) {
								var i;
								for (i = 0; i < Tags.length; i++) {
									if (Tags[i] === Tag) {
										Result++;
									}
								}
							}
							return Result;  // Success
						} else {
							UInvError('GetItemTagCount failed. Item "' + ItemName + '" does not have property "' + ItemPropertyName + '".');  // Error
							return undefined;
						}
					} else {
						UInvError('GetItemTagCount cannot find item "' + ItemName + '" in bag "' + BagName + '".');  // Error
						return undefined;
					}
				} else {
					UInvError('GetItemTagCount cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemTagCount is not a string.');  // Error
				return undefined;
			}
		},

		// GetItemsArrayWithMostItemTags: Returns an array of all items in BagName that are tied for the most tags from ItemTagArray in ItemPropertyName.
		GetItemsArrayWithMostItemTags : function (BagName, ItemPropertyName, ItemTagArray) {
			if (UInv.isString(BagName) && UInv.isString(ItemPropertyName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					UInv.SetCurrentBagName(BagName);
					if (!UInv.isArray(ItemTagArray)) {
						ItemTagArray = [ ItemTagArray ];
					}
					var Items = UInv.GetItemsArray(BagName);
					if ((Items.length > 0) && (ItemTagArray.length > 0)) {
						var Result = [], Max = 0, i, j, n;
						for (i = 0; i < Items.length; i++) {
							n = 0;
							if (UInv.ItemHasProperty(BagName, Items[i], ItemPropertyName)) {
								for (j = 0; j < ItemTagArray.length; j++) {
									n += UInv.GetItemTagCount(BagName, Items[i], ItemPropertyName, ItemTagArray[j]);
								}
							}
							if (n === Max) {
								Result.push(Items[i]);  // Add item to list
							} else if (n > Max) {
								Result = [ Items[i] ];  // New winner for most tags
								Max = n;
							}
						}
						return Result;  // Success
					} else {
						return [];  // Success
					}
				} else {
					UInvError('GetItemsArrayWithMostItemTags cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('Name passed to GetItemsArrayWithMostItemTags is not a string.');  // Error
				return undefined;
			}
		},


		// UInv Display Functions:
		// =======================

		// GetUpdateLocks: Returns the number of locks on updates.
		GetUpdateLocks : function () {
			if (UInv.isProperty(State.variables, "UInvUpdatesAreLocked")) {
				return State.variables.UInvUpdatesAreLocked;  // Success
			}
			return 0;  // Success
		},

		// UpdatesAreLocked: Returns whether automatic display updates are locked or not.
		UpdatesAreLocked : function () {
			return !!UInv.GetUpdateLocks();  // Success
		},

		// IncrementUpdateLock: Increments the update lock count.
		IncrementUpdateLock : function () {
			State.variables.UInvUpdatesAreLocked = UInv.GetUpdateLocks() + 1;
			return State.variables.UInvUpdatesAreLocked;  // Success
		},

		// DecrementUpdateLock: Increments the update lock count.
		DecrementUpdateLock : function () {
			if (UInv.GetUpdateLocks()) {
				if (--State.variables.UInvUpdatesAreLocked === 0) {
					$.wiki("<<unset $UInvUpdatesAreLocked>>");
					UInv.UpdateDisplay();
					return 0;  // Success
				} else {
					return State.variables.UInvUpdatesAreLocked;  // Success
				}
			}
			UInv.UpdateDisplay();
			return 0;  // Success
		},

		// GetMatchingEventHandlersArray: Returns an array of the handler ID of all handlers that match the parameters passed in (Handler and/or Options are optional).
		GetMatchingEventHandlersArray : function (Group, Evnt, Options, Handler) {
			if (UInv.isString(Group)) {
				if (UInv.isProperty(State.variables.UInvEventHandlers, Group)) {
					if (UInv.isString(Evnt)) {
						if (UInv.isProperty(State.variables.UInvEventHandlers[Group], Evnt)) {
							var Matches = [], HandlerIDs, Opts, i, j, n;
							if (UInv.isUndefined(Handler)) {
								if (UInv.isUndefined(Options)) {  // Get all items that match group and event names.
									return Object.keys(State.variables.UInvEventHandlers[Group][Evnt]);  // Success
								} else if (Options === false) {  // Find all matching items that don't have options.
									HandlerIDs = Object.keys(State.variables.UInvEventHandlers[Group][Evnt]);
									for (i = 0; i < HandlerIDs.length; i++) {
										if (!UInv.isProperty(State.variables.UInvEventHandlers[Group][Evnt][HandlerIDs[i]], "options")) {
											Matches.push(HandlerIDs[i]);
										}
									}
									return Matches;  // Success
								} else {  // Find items that also match all options.
									HandlerIDs = Object.keys(State.variables.UInvEventHandlers[Group][Evnt]);
									for (i = 0; i < HandlerIDs.length; i++) {
										n = 0;
										Opts = Object.keys(State.variables.UInvEventHandlers[Group][Evnt][HandlerIDs[i]].options);
										for (j = 0; j < Opts.length; j++) {
											if (UInv.isProperty(Options, Opts[j])) {
												if (State.variables.UInvEventHandlers[Group][Evnt][HandlerIDs[i]].options[Opts[j]] == Options[Opts[j]]) {
													n++;
												} else {
													break;
												}
											} else {
												break;
											}
										}
										if (n == Opts.length) {
											Matches.push(HandlerIDs[i]);
										}
									}
									return Matches;  // Success
								}
							} else if (UInv.isString(Handler)) {
								if (UInv.isUndefined(Options)) {  // Find items that match handler name.
									HandlerIDs = Object.keys(State.variables.UInvEventHandlers[Group][Evnt]);
									for (i = 0; i < HandlerIDs.length; i++) {
										if (State.variables.UInvEventHandlers[Group][Evnt][HandlerIDs[i]].handler == Handler) {
											Matches.push(HandlerIDs[i]);
										}
									}
								} else if (Options === false) {  // Find all matching items that don't have options.
									HandlerIDs = Object.keys(State.variables.UInvEventHandlers[Group][Evnt]);
									for (i = 0; i < HandlerIDs.length; i++) {
										if (State.variables.UInvEventHandlers[Group][Evnt][HandlerIDs[i]].handler == Handler) {
											if (!UInv.isProperty(State.variables.UInvEventHandlers[Group][Evnt][HandlerIDs[i]], "options")) {
												Matches.push(HandlerIDs[i]);
											}
										}
									}
									return Matches;  // Success
								} else {  // Find items that match handler name and all options.
									HandlerIDs = Object.keys(State.variables.UInvEventHandlers[Group][Evnt]);
									Opts = Object.keys(Options);
									for (i = 0; i < HandlerIDs.length; i++) {
										if (State.variables.UInvEventHandlers[Group][Evnt][HandlerIDs[i]].handler == Handler) {
											n = 0;
											for (j = 0; j < Opts.length; j++) {
												if (UInv.isProperty(State.variables.UInvEventHandlers[Group][Evnt][HandlerIDs[i]], Opts[j])) {
													if (State.variables.UInvEventHandlers[Group][Evnt][HandlerIDs[i]][Opts[j]] == Options[Opts[j]]) {
														n++;
													} else {
														break;
													}
												} else {
													break;
												}
											}
											if (n == Opts.length) {
												Matches.push(HandlerIDs[i]);
											}
										}
									}
								}
								return Matches;  // Success
							} else {
								UInvError('Handler passed to GetMatchingEventHandlersArray must be undefined or a string.');  // Error
								return undefined;
							}
						} else {
							return [];  // Success - Event doesn't have any handlers
						}
					} else {
						UInvError('Event passed to GetMatchingEventHandlersArray must be a string.');  // Error
						return undefined;
					}
				} else {
					return [];  // Success - Group doesn't have any handlers
				}
			} else {
				UInvError('Group passed to GetMatchingEventHandlersArray must be a string.');  // Error
				return undefined;
			}
		},

		// AddEventHandler: Adds an event handler to UInv that will call the setup function or widget when that UInv event is triggered.
		//					Returns the random handle ID on success, or undefined on error.
		AddEventHandler : function (Group, Evnt, Handler, Options) {
			if (UInv.isString(Group)) {
				if (UInv.isString(Evnt)) {
					if (UInv.isString(Handler)) {
						var UInvEvents = {
							general : ["MouseDown", "MouseUp"],
							bag : ["Touched"],
							table : ["Accept", "DragStart", "DragStop", "Drop"],
							radialMenu : ["Open", "WedgeClick", "DisabledWedgeClick", "Cancel"],
							cacheImages : ["Loaded", "Error"]
						};
						if (UInv.isProperty(UInvEvents, Group)) {
							if (UInvEvents[Group].includes(Evnt)) {
								if (!UInv.isProperty(State.variables.UInvEventHandlers, Group)) {
									State.variables.UInvEventHandlers[Group] = {};
								}
								if (!UInv.isProperty(State.variables.UInvEventHandlers[Group], Evnt)) {
									State.variables.UInvEventHandlers[Group][Evnt] = {};
								}
								// Generate unique random handle name
								var HandleID = "handle" + UInv.getRandomHexString();
								while (UInv.isProperty(State.variables.UInvEventHandlers[Group][Evnt], HandleID)) {
									HandleID = "handle" + UInv.getRandomHexString();
								}
								if (UInv.isUndefined(Options)) {
									if (UInv.GetMatchingEventHandlersArray(Group, Evnt, undefined, Handler).length === 0) {  // Add handler
										if (UInv.isFunction(setup[Handler])) {
											State.variables.UInvEventHandlers[Group][Evnt][HandleID] = { handler: Handler, type: "function" };
										} else {
											State.variables.UInvEventHandlers[Group][Evnt][HandleID] = { handler: Handler, type: "widget" };
										}
									} else {
										return UInv.GetMatchingEventHandlersArray(Group, Evnt, undefined, Handler)[0];  // Success - handler already exists
									}
								} else {  // Add handler and options
									if (UInv.isObject(Options)) {
										if (UInv.GetMatchingEventHandlersArray(Group, Evnt, Options, Handler).length === 0) {  // Add handler
											if (UInv.isFunction(setup[Handler])) {
												State.variables.UInvEventHandlers[Group][Evnt][HandleID] = { handler: Handler, type: "function", options: clone(Options) };
											} else {
												State.variables.UInvEventHandlers[Group][Evnt][HandleID] = { handler: Handler, type: "widget", options: clone(Options) };
											}
										} else {
											return UInv.GetMatchingEventHandlersArray(Group, Evnt, Options, Handler)[0];  // Success - handler already exists
										}
									} else {
										UInvError('Options passed to AddEventHandler must be undefined or an object.');  // Error
										return undefined;
									}
								}
								return HandleID;  // Success
							} else {
								UInvError('Event "' + Evnt + '" passed to AddEventHandler is not a valid event for group "' + Group + '".');  // Error
								return undefined;
							}
						} else {
							UInvError('Group "' + Group + '" passed to AddEventHandler is not a valid group.');  // Error
							return undefined;
						}
					} else {
						UInvError('Handler passed to AddEventHandler must be a string.');  // Error
						return undefined;
					}
				} else {
					UInvError('Event passed to AddEventHandler must be a string.');  // Error
					return undefined;
				}
			} else {
				UInvError('Group passed to AddEventHandler must be a string.');  // Error
				return undefined;
			}
		},

		// GetEventHandlerByID: Returns a UInv handler object if a matching one is found, or null if one doesn't exist, or undefined on error.
		GetEventHandlerByID : function (Group, Evnt, HandlerID) {
			if (UInv.isString(Group)) {
				if (UInv.isProperty(State.variables.UInvEventHandlers, Group)) {
					if (UInv.isString(Evnt)) {
						if (UInv.isProperty(State.variables.UInvEventHandlers[Group], Evnt)) {
							if (UInv.isString(HandlerID)) {
								if (UInv.isProperty(State.variables.UInvEventHandlers[Group][Evnt], HandlerID)) {
									return clone(State.variables.UInvEventHandlers[Group][Evnt][HandlerID]);
								} else {
									return null;  // Success - HandlerID not found
								}
							} else {
								UInvError('HandlerID passed to GetEventHandlerByID must be a string.');  // Error
								return undefined;
							}
						} else {
							return null;  // Success - Event doesn't have any handlers
						}
					} else {
						UInvError('Event passed to GetEventHandlerByID must be a string.');  // Error
						return undefined;
					}
				} else {
					return null;  // Success - Group doesn't have any handlers
				}
			} else {
				UInvError('Group passed to GetEventHandlerByID must be a string.');  // Error
				return undefined;
			}
		},

		// CallEventHandlerEx: Triggers any matching event handlers and passes the Values object to them.
		//					   Returns an array of returned objects from all triggered handlers, or undefined on error.
		CallEventHandlerEx : function (Group, Evnt, Values) {
			if (UInv.isString(Group)) {
				if (UInv.isProperty(State.variables.UInvEventHandlers, Group)) {
					if (UInv.isString(Evnt)) {
						if (UInv.isProperty(State.variables.UInvEventHandlers[Group], Evnt)) {
							// verify that Values parameter exists and is valid here ***
							var Result = [], Ret, Handler, i, HandlerIDs = UInv.GetMatchingEventHandlersArray(Group, Evnt, Values);  // Get specific matching event handlers
							if (HandlerIDs.length === 0) {  // Get general matching event handlers
								HandlerIDs = UInv.GetMatchingEventHandlersArray(Group, Evnt, false);
							}
							for (i = 0; i < HandlerIDs.length; i++) {
								Handler = UInv.GetEventHandlerByID(Group, Evnt, HandlerIDs[i]);
								Values.eventGroup = Group;
								Values.eventType = Evnt;
								Values.handlerID = HandlerIDs[i];
								if (Handler.type == "function") {
									Ret = setup[Handler.handler](Values);
									if (UInv.isGenericObject(Ret)) {
										Result.push(Ret);
									} else {
										Result.push(undefined);
									}
								} else if (Handler.type == "widget") {
									State.temporary.UInvEvent = Values;
									$.wiki("<<" + Handler.handler + " _UInvEvent>>");
									if (UInv.isProperty(State.temporary, "UInvReturn")) {
										if (UInv.isGenericObject(State.temporary.return)) {
											Result.push(State.temporary.return);
										} else {
											Result.push(undefined);
										}
										$.wiki("<<forget _UInvReturn>>");
									}
									$.wiki("<<forget _UInvEvent>>");
								}
							}
							return Result;
						} else {
							return [];  // Success - Event doesn't have any handlers
						}
					} else {
						UInvError('Event passed to CallEventHandlerEx must be a string.');  // Error
						return undefined;
					}
				} else {
					return [];  // Success - Group doesn't have any handlers
				}
			} else {
				UInvError('Group passed to CallEventHandlerEx must be a string.');  // Error
				return undefined;
			}
		},

		// CallEventHandler: Triggers any matching event handlers and passes the Values object to them.
		//					 Returns a generic object from all of the combined returned objects from all triggered handlers, or undefined on error.
		CallEventHandler : function (Group, Evnt, Values) {
			if (UInv.isString(Group)) {
				if (UInv.isProperty(State.variables.UInvEventHandlers, Group)) {
					if (UInv.isString(Evnt)) {
						if (UInv.isProperty(State.variables.UInvEventHandlers[Group], Evnt)) {
							// verify that Values parameter exists and is valid here ***
							var Result = {}, Ret = UInv.CallEventHandlerEx(Group, Evnt, Values);
							if (Ret.length > 0) {
								var i, j, Props;
								for (i = 0; i < Ret.length; i++) {
									if (UInv.isGenericObject(Ret[i])) {
										Props = Object.keys(Ret[i]);
										for (j = 0; j < Props.length; j++) {
											if (UInv.isProperty(Result, Props[j])) {
												switch(Props[j]) {
													case "stopPropagation":
														if (Result.stopPropagation || Ret[i].stopPropagation) {
															Result.stopPropagation = true;  // Prefer to override default
														} else {
															Result.stopPropagation = Ret[i].stopPropagation;
														}
														break;
													case "acceptVal":
														if (!Result.acceptVal || !Ret[i].acceptVal) {
															Result.acceptVal = false;  // Prefer to override default
														} else {
															Result.acceptVal = Ret[i].acceptVal;
														}
														break;
													case "overrideDefaultAction":
														if (Result.overrideDefaultAction || Ret[i].overrideDefaultAction) {
															Result.overrideDefaultAction = true;  // Prefer to override default
														} else {
															Result.overrideDefaultAction = Ret[i].overrideDefaultAction;
														}
														break;
													case "openRadialMenu":
														if (Result.openRadialMenu || Ret[i].openRadialMenu) {
															Result.openRadialMenu = true;  // Prefer to override default
														} else {
															Result.openRadialMenu = Ret[i].openRadialMenu;
														}
														break;
													case "radialMenuWedgeItems":
														Result = UInv.combineGenericObjects(Result, Ret[i]);
														break;
													case "radialMenuHandler":  // modify AddEventHandler to accept an array of handlers, then pass the array created here? ***
														Result.radialMenuHandler = Ret[i].radialMenuHandler;
														/*
														if (UInv.isArrayOfStrings(Result.radialMenuHandler)) {
															Result.radialMenuHandler.push(Ret[i].radialMenuHandler);
														} else {
															Result.radialMenuHandler = [Result.radialMenuHandler, Ret[i].radialMenuHandler];
														}
														*/
														break;
													case "radialMenuOptions":
														Result = UInv.combineGenericObjects(Result, Ret[i]);
														break;
													case "keepOpen":
														if (Result.keepOpen || Ret[i].keepOpen) {
															Result.keepOpen = true;  // Prefer to override default
														} else {
															Result.keepOpen = Ret[i].keepOpen;
														}
														break;
													case "retryLoad":
														if (Result.retryLoad || Ret[i].retryLoad) {
															Result.retryLoad = true;  // Prefer to override default
														} else {
															Result.retryLoad = Ret[i].retryLoad;
														}
														break;
													default:
														Result[Props[j]] = Ret[i][Props[j]];
												}
											} else {
												Result[Props[j]] = Ret[i][Props[j]];
											}
										}
									}
								}
							}
							return Result;
						} else {
							return {};  // Success - Event doesn't have any handlers
						}
					} else {
						UInvError('Event passed to CallEventHandler must be a string.');  // Error
						return undefined;
					}
				} else {
					return {};  // Success - Group doesn't have any handlers
				}
			} else {
				UInvError('Group passed to CallEventHandler must be a string.');  // Error
				return undefined;
			}
		},

		// DeleteEventHandler: Deletes any matching event handlers.  Returns the number of deleted handlers, or undefined on error.
		DeleteEventHandler : function (Group, Evnt, Handler, Options) {
			if (UInv.isString(Group)) {
				if (UInv.isProperty(State.variables.UInvEventHandlers, Group)) {
					if (UInv.isString(Evnt)) {
						if (UInv.isProperty(State.variables.UInvEventHandlers[Group], Evnt)) {
							if (UInv.isProperty(State.variables.UInvEventHandlers[Group][Evnt], Handler)) {
								delete State.variables.UInvEventHandlers[Group][Evnt][Handler];
								return 1;  // Success - Deleted by HandlerID
							} else {
								var i, HandlerIDs = UInv.GetMatchingEventHandlersArray(Group, Evnt, Options, Handler);
								for (i = 0; i < HandlerIDs.length; i++) {
									delete State.variables.UInvEventHandlers[Group][Evnt][HandlerIDs[i]];
								}
								return HandlerIDs.length;  // Success
							}
						} else {
							return 0;  // Success - Event doesn't have any handlers
						}
					} else {
						UInvError('Event passed to DeleteEventHandler must be a string.');  // Error
						return undefined;
					}
				} else {
					return 0;  // Success - Group doesn't have any handlers
				}
			} else {
				UInvError('Group passed to DeleteEventHandler must be a string.');  // Error
				return undefined;
			}
		},

		// FixTableCells: Makes sure each item is assigned a unique cell.  Tries to make sure items will display in table UInvTable if that parameter is used, assuming there is enough room.
		FixTableCells : function (BagName, UInvTable) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					var Items = UInv.GetItemsArray(BagName);
					if (Items.length > 0) {
						var i, j, Val, Dups, Cell = 0, MaxCell = Infinity;
						if (!UInv.isUndefined(UInvTable)) {
							if (UInvTable.data("uinv") === "table") {
								if (UInvTable.attr("id") == BagName) {
									i = UInvTable.data("cellrows");
									j = UInvTable.data("cellcolumns");
									if (UInv.isInteger(i) && (i > 0) && UInv.isInteger(j) && (j > 0)) {
										MaxCell = (i * j) - 1;  // move items if they won't display in current table
									}
								} else {
									UInvError('UInvTable passed to FixTableCells does not match BagName of "' + BagName + '".');  // Error
									return undefined;
								}
							} else {
								UInvError('UInvTable passed to FixTableCells is not a UInv table element.');  // Error
								return undefined;
							}
						}
						for (i = 0; i < Items.length; i++) {
							if (UInv.ItemHasProperty(BagName, Items[i], "UInvCell")) {
								// Make sure there are no duplicates
								Val = UInv.GetItemPropertyValue(BagName, Items[i], "UInvCell");
								if (Val > MaxCell) {
									// Move item if it won't display in current table
									while (UInv.GetItemCountWherePropertyEquals(BagName, "UInvCell", Cell) > 0) {
										++Cell;
									}
									UInv.SetItemPropertyValue(BagName, Items[i], "UInvCell", Cell++);
								} else {
									if (UInv.GetItemCountWherePropertyEquals(BagName, "UInvCell", Val) > 1) {
										// Unmark duplicates
										Dups = UInv.GetItemsArrayWherePropertyEquals(BagName, "UInvCell", Val);
										Dups.delete(Items[i]);  // Current item stays put
										for (j = 0; j < Dups.length; j++) {
											UInv.DeleteItemProperty(BagName, Dups[j], "UInvCell");
										}
									}
								}
							} else {
								// Give item a cell
								while (UInv.GetItemCountWherePropertyEquals(BagName, "UInvCell", Cell) > 0) {
									++Cell;
								}
								UInv.SetItemPropertyValue(BagName, Items[i], "UInvCell", Cell++);
							}
						}
					}
					return true;  // Success
				} else {
					UInvError('FixTableCells cannot find bag "' + BagName + '".');  // Error
					return undefined;
				}
			} else {
				UInvError('BagName passed to FixTableCells is not a string.');  // Error
				return undefined;
			}
		},

		// InitializeRadialMenu: Create radial menu div element.
		InitializeRadialMenu : function () {
			var el = document.createElement("div");
			el.id = "uinv-radial-menu";
			el.style.position = "absolute";
			el.style.transition = "transform 200ms ease-in, opacity 200ms ease-in";
			el.style["pointer-events"] = "none";
			el.dataset.status = "closed";
			el.style.transform = "scale(0, 0)";
			el.style.opacity = 0;
			el.style.zIndex = 9999;
			document.body.appendChild(el);
		},

		// DisplayRadialMenu: Gets radial menu prepared for use.
		DisplayRadialMenu : function (WedgeItems, Pos, Handler, Options) {
			function getPoint (theta, r, posOffset, negOffset) {
				if (typeof posOffset == "undefined") {
					posOffset = { x: 0, y: 0 };
				}
				if (typeof negOffset == "undefined") {
					negOffset = { x: 0, y: 0 };
				}
				return { x: (r*Math.cos(theta)) + posOffset.x - negOffset.x, y: (r*Math.sin(theta)) + posOffset.y - negOffset.y };
			}
			function wedgePath (i, clr, ctr, r1, a1, b1, r2, a2, b2) {
				var start1 = getPoint(a1, r1, ctr), end1 = getPoint(b1, r1, ctr, start1);
				var start2 = getPoint(b2, r2, ctr), end2 = getPoint(a2, r2, ctr, start2);
				var path = '<path d="M' + start1.x + ',' + start1.y + ' a' + r1 + ',' + r1 + ' 0 0,1 ' + end1.x + ',' + end1.y;
				path += ' L' + start2.x + ',' + start2.y + ' a' + r2 + ',' + r2 + ' 0 0,0 ' + end2.x + ',' + end2.y + ' z" fill="';
				if (clr == "mask") {  // wedge mask
					path += 'white" />';
				} else if (WedgeItems[i+1].disabled !== true) {  // clickable wedge
					path += clr + '" class="uinv-wedge" data-id="' + (i+1) + '" data-data="' + WedgeItems[i+1].data;
					path += '" stroke="' + strokeColor + '" stroke-width="' + strokeWidth + '" pointer-events="auto">';
						if (showTooltips) {  // deepscan-disable-line
						path += '<title> ' + WedgeItems[i+1].hint + '</title>';
					}
					path += '<desc>' + WedgeItems[i+1].hint + '</desc></path>';  // for blind users
				} else {  // disabled wedge
					path += disabledColor + '" class="uinv-disabled-wedge" data-id="' + (i+1) + '" data-data="' + WedgeItems[i+1].data;
					path += '" stroke="' + disabledStrokeColor + '" stroke-width="' + disabledStrokeWidth + '" pointer-events="auto">';
						if (showTooltips) {  // deepscan-disable-line
						path += '<title> ' + WedgeItems[i+1].hint + ' (disabled)</title>';
					}
					path += '<desc>' + WedgeItems[i+1].hint + ' (disabled)</desc></path>';  // for blind users
				}
				return path;
			}
			function wedges (ctr, n, r1, r2, gap, clr) {
				var tGap1 = gap/r1, tGap2 = gap/r2;
				var dTheta = (2*Math.PI)/n, paths = [];
				var theta = (-0.5*Math.PI) - (0.5*dTheta), i;
				for (i = 0; i < n; i++) {
					if (WedgeItems[i+1] !== undefined) {
						paths.push( wedgePath(i, clr, ctr,
							r1, theta + tGap1, (theta + dTheta) - tGap1,
							r2, theta + tGap2, (theta + dTheta) - tGap2
						) );
					}
					theta += dTheta;
				}
				return paths.join("\n");
			}
			function wedgeClickHandler (ev) {

				function WedgeUpdate (Arr, DataName, Opts) {
					var i, DatNo = -1;
					for (i = 0; i < Arr.length; i++) {
						if (Arr[i].data == DataName) {
							DatNo = i;
							break;
						}
					}
					if (DatNo >=0) {
						var Keys = Object.keys(Opts);
						for (i = 0; i < Keys.length; i++) {
							Arr[DatNo][Keys[i]] = Opts[Keys[i]];
						}
					} else {
						if (UInv.GetUserAlerts() & UInv.ERROR_TO_CONSOLE) {
							console.log('Warning: Nonexistent DataName "' + DataName + '" passed to WedgeUpate.');  // Throw a proper error here? ***
						}
					}
					return Arr;
				}

				if (ev.button == 0) {
					var Ret, el, RM = setup.UInvRadialMenuData;
					var Quant = UInv.BagHasItem(RM.srcBag, RM.draggedItem);
					var data = $(this).data("data");
					ev.stopPropagation();
					ev.wedgeID = $(this).data("id");
					ev.wedgeData = data;
					ev.srcBag = RM.srcBag;
					ev.draggedItem = RM.draggedItem;
					ev.oldCellNo = RM.oldCellNo;
					ev.destBag = RM.destBag;
					ev.droppedOnItem = RM.droppedOnItem;
					ev.newCellNo = RM.newCellNo;
					ev.radialMenuWedgeItems = clone(RM.radialMenuWedgeItems);
					ev.pos = clone(RM.pos);
					ev.radialMenuHandler = RM.radialMenuHandler;
					ev.radialMenuOptions = clone(RM.radialMenuOptions);
					if ($(this).hasClass("uinv-wedge")) {
						ev.wedgeDisabled = false;
						Ret = UInv.CallEventHandler("radialMenu", "WedgeClick", ev);  // radialMenu WedgeClick event
						if (UInv.isUndefined(Ret.radialMenuWedgeItems)) {
							Ret.radialMenuWedgeItems = clone(RM.radialMenuWedgeItems);
						}
						if (UInv.isUndefined(Ret.radialMenuHandler)) {
							Ret.radialMenuHandler = RM.radialMenuHandler;
						}
						if (UInv.isUndefined(Ret.radialMenuOptions)) {
							Ret.radialMenuOptions = clone(RM.radialMenuOptions);
						}
						if (Ret.overrideDefaultAction !== true) {
							switch(data) {
								case "DropAll":
									UInv.IncrementUpdateLock();
									if (RM.destBag != RM.srcBag) {  // Move to new bag
										UInv.MoveItem(RM.srcBag, RM.destBag, RM.draggedItem);  // handle move failure due to pocket protection ***
									}
									UInv.SetItemPropertyValue(RM.destBag, RM.draggedItem, "UInvCell", RM.newCellNo);
									UInv.DecrementUpdateLock();
									break;
								case "Drop1":
								case "DropHalf":
								case "DropQuarter":
									UInv.IncrementUpdateLock();
									var TempBag = UInv.GetUniqueBagName(), Amt = 1;
									if (data == "DropHalf") {
										Amt = Math.trunc(Quant * 0.5);
									} else if (data == "DropQuarter") {
										Amt = Math.trunc(Quant * 0.25);
									}
									UInv.CreateBag(TempBag);
									UInv.MoveItem(RM.srcBag, TempBag, RM.draggedItem, Amt);  // handle move failure due to pocket protection ***
									UInv.MoveItem(TempBag, RM.destBag, RM.draggedItem);  // handle move failure due to pocket protection ***
									UInv.SetItemPropertyValue(RM.destBag, RM.draggedItem, "UInvCell", RM.newCellNo);
									UInv.DeleteBag(TempBag);
									Ret.keepOpen = true;
									UInv.DecrementUpdateLock();
									break;
								case "Take1":
									UInv.IncrementUpdateLock();
									UInv.MoveItem(RM.destBag, RM.srcBag, RM.draggedItem, 1);  // handle move failure due to pocket protection ***
									Ret.keepOpen = true;
									UInv.DecrementUpdateLock();
									break;
							}
							Quant = UInv.BagHasItem(RM.srcBag, RM.draggedItem);
							/* Default:
								{ icon: "fa-plus-square", hint: "Drop all (" + Quant + " items)", data: "DropAll" }
								{ icon: "plus-one_white.svg", hint: "Drop one", data: "Drop1" }
								{ icon: "plus-half_white.svg", hint: "Drop half", data: "DropHalf" }
								{ icon: "minus-one_white.svg", hint: "Take one", data: "Take1" }
								{ icon: "plus-quarter_white.svg", hint: "Drop 1/4th", data: "DropQuarter" }
								fa-sync-alt = swap items
								fa-times-circle = cancel radial menu
							*/
							WedgeUpdate(Ret.radialMenuWedgeItems, "DropAll", { hint: "Drop all (" + Quant + " items)" });
							if (Quant == 1) {
								WedgeUpdate(Ret.radialMenuWedgeItems, "Drop1", { disabled: true, hint: "Drop one" });
							} else {
								WedgeUpdate(Ret.radialMenuWedgeItems, "Drop1", { disabled: false, hint: "Drop one (of " + Quant + " items)" });
							}
							if (Quant < 4) {
								WedgeUpdate(Ret.radialMenuWedgeItems, "DropHalf", { disabled: true, hint: "Drop half" });
							} else {
								WedgeUpdate(Ret.radialMenuWedgeItems, "DropHalf", { disabled: false, hint: "Drop half (" + Math.trunc(Quant * 0.5) + " of " + Quant + " items)" });
							}
							if (RM.droppedOnItem !== "") {
								if (!UInv.ItemsMatch(RM.srcBag, RM.draggedItem, RM.destBag, RM.droppedOnItem)) {  // Don't allow picking up items when they're not the same type
									WedgeUpdate(Ret.radialMenuWedgeItems, "Take1", { disabled: true, hint: "Pick up one" });
								} else {
									WedgeUpdate(Ret.radialMenuWedgeItems, "Take1", { disabled: false, hint: "Pick up one (of " + UInv.BagHasItem(RM.destBag, RM.droppedOnItem) + " items)" });
								}
							}
							if (Quant < 8) {
								WedgeUpdate(Ret.radialMenuWedgeItems, "DropQuarter", { disabled: true, hint: "Drop 1/4th" });
							} else {
								WedgeUpdate(Ret.radialMenuWedgeItems, "DropQuarter", { disabled: false, hint: "Drop 1/4th (" + Math.trunc(Quant * 0.25) + " of " + Quant + " items)" });
							}
							RM.radialMenuWedgeItems = clone(Ret.radialMenuWedgeItems);
							RM.radialMenuHandler = Ret.radialMenuHandler;
							RM.radialMenuOptions = clone(Ret.radialMenuOptions);
							UInv.DisplayRadialMenu(Ret.radialMenuWedgeItems, Pos, Ret.radialMenuHandler, Ret.radialMenuOptions);
						}
						if (Ret.keepOpen !== true) {
							el = $("#uinv-radial-menu").get(0);
							el.dataset.status = "closed";
							el.style.transform = "scale(0, 0)";
							el.style.opacity = 0;
						}
					} else {
						ev.wedgeDisabled = true;
						Ret = UInv.CallEventHandler("radialMenu", "DisabledWedgeClick", ev);  // radialMenu DisabledWedgeClick event
						if (Ret.keepOpen === false) {
							el = $("#uinv-radial-menu").get(0);
							el.dataset.status = "closed";
							el.style.transform = "scale(0, 0)";
							el.style.opacity = 0;
						}
					}
				}
			}

			/*
			var WedgeItems = [{ icon: "menu-burger_white.svg", hint: "Show menu", data: "menu", disabled: true },  // any double-quotes in WedgeItems[#].data need to be escaped ***
						{ icon: "fa-image", hint: "Show image", data: "image" },
						{ icon: "fa-headphones", hint: "Show audio", data: "audio", disabled: true },
						{ icon: "fa-home", hint: "Return to main page", data: "home" },
						,  // handle undefined wedges as blank spaces
						{ icon: "fa-video", hint: "Show video", data: "video" },
						{ icon: "fa-envelope", hint: "Show email", data: "email" }];
			Default Options:
					{
						iconSize: 32, radius: 100, gap: 1, pad: 2, iconColor: "white", showTooltips: true,
						innerGradientColor: "rgb(4,111,191)", innerGradientOpacity: 1, innerGradientOffset: 0,
						outerGradientColor: "rgb(4,111,191)", outerGradientOpacity: 0, outerGradientOffset: 100,
						hoverColor: "rgba(0,144,226,0.3)", strokeColor: "#0090e2", strokeWidth: 0,
						disabledColor: "rgba(128,128,128,0.5)", disabledOpacity: "0.4", disabledStrokeColor: "#0090e2", disabledStrokeWidth: 0
					}
			*/
			// Radial menu init
			var div = $("#uinv-radial-menu").get(0);
			if (UInv.isUndefined(div)) {
				UInv.InitializeRadialMenu();
				div = $("#uinv-radial-menu").get(0);
			}
			if (!UInv.isArrayOfObjects(WedgeItems)) {
				UInvError('DisplayRadialMenu failed. WedgeItems parameter is not an array of objects.');  // Error
				return undefined;
			}
			if (WedgeItems.length === 0) {
				return true;  // Success
			}
			if (UInv.isUndefined(Options) || !UInv.isGenericObject(Options)) {
				Options = {};
			}
			div.radialMenuWedgeItems = WedgeItems;
			div.radialMenuHandler = Handler;
			div.radialMenuOptions = Options;
			var Ret = UInv.CallEventHandler("radialMenu", "Open", div);  // radialMenu Open event
			if (UInv.isProperty(Ret, "radialMenuWedgeItems")) {
				WedgeItems = Ret.radialMenuWedgeItems;
			}
			if (UInv.isProperty(Ret, "radialMenuHandler")) {
				Handler = Ret.radialMenuHandler;
			}
			if (UInv.isProperty(Ret, "radialMenuOptions")) {
				Options = Ret.radialMenuOptions;
			}
			if (!UInv.isUndefined(Handler) && UInv.isString(Handler)) {
				UInv.AddEventHandler("radialMenu", "Open", Handler);
				UInv.AddEventHandler("radialMenu", "WedgeClick", Handler);
				UInv.AddEventHandler("radialMenu", "DisabledWedgeClick", Handler);
				UInv.AddEventHandler("radialMenu", "Cancel", Handler);
			}
			var num = WedgeItems.length - 1;  // num = number of outer ring options
			var r1M = Options.iconSize ? Options.iconSize : 32;  // r1M = icon height/width in pixels
			var r2M = Options.radius ? Options.radius : 100;  // r2M = radial menu radius in pixels
			var gapM = Options.gap ? Options.gap : 1;  // gapM = circle and wedge gap size???
			var pad = Options.pad ? Options.pad : 2;  // pad = circle and wedge margin???
			var iconColor = Options.iconColor ? Options.iconColor : "white";
			var showTooltips = Options.showTooltips ? Options.showTooltips : true;
			var innerGradientColor = Options.innerGradientColor ? Options.innerGradientColor : "rgb(4,111,191)";
			var innerGradientOpacity = Options.innerGradientOpacity ? Options.innerGradientOpacity : 1;
			var innerGradientOffset = Options.innerGradientOffset ? Options.innerGradientOffset : 0;
			var outerGradientColor = Options.outerGradientColor ? Options.outerGradientColor : "rgb(4,111,191)";
			var outerGradientOpacity = Options.outerGradientOpacity ? Options.outerGradientOpacity : 0;
			var outerGradientOffset = Options.outerGradientOffset ? Options.outerGradientOffset : 100;
			var hoverColor = Options.hoverColor ? Options.hoverColor : "rgba(0,144,226,0.3)";
			var strokeColor = Options.strokeColor ? Options.strokeColor : "#0090e2";
			var strokeWidth = Options.strokeWidth ? Options.strokeWidth : 0;
			var disabledColor = Options.disabledColor ? Options.disabledColor : "rgba(128,128,128,0.5)";
			var disabledOpacity = Options.disabledOpacity ? Options.disabledOpacity : "0.4";
			var disabledStrokeColor = Options.disabledStrokeColor ? Options.disabledStrokeColor : "#0090e2";
			var disabledStrokeWidth = Options.disabledStrokeWidth ? Options.disabledStrokeWidth : 0;
			var center = { x: r2M + pad, y: r2M + pad };
			var w = (2*r2M) + (2*pad), h = (2*r2M) + (2*pad);
			div.dataset.r = r2M;
			$(div).find(".uinv-wedge").off();
			$(div).find(".uinv-disabled-wedge").off();
			// Add wedge hover styling
			if (!UInv.docHasCSSElement(".uinv-wedge:hover")) {
				var styleEl = document.createElement("style");
				styleEl.title = "uinv-hover";
				document.head.appendChild(styleEl);
				var styleSheet = styleEl.sheet;
				styleSheet.insertRule(".uinv-wedge:hover { fill: " + hoverColor + "; }", 0);
			}
			// Create the radial menu as an SVG element
			var svg = '<svg id="uinv-radial-menu-svg" style="display: block; width: ' + w + 'px; height: ' + h + 'px;">';
			// Centered gradient background
			svg += '<defs><radialGradient id="Gradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">';
			svg += '<stop offset="' + innerGradientOffset + '%" style="stop-color:' + innerGradientColor + '; stop-opacity:' + innerGradientOpacity + '" />';
			svg += '<stop offset="' + outerGradientOffset + '%" style="stop-color:' + outerGradientColor + '; stop-opacity:' + outerGradientOpacity + '" />';
			svg += '</radialGradient>';
			// Radial menu mask so Gradient background is visible
			svg += '<mask id="Mask">';
			if (WedgeItems[0] !== undefined) {
				svg += '<circle cx="' + center.x + '" cy="' + center.y + '" r="' + (r1M - (2*gapM)) + '" fill="white" />';
			}
			svg += wedges(center, num, r1M, r2M, gapM, "mask") + '</mask></defs>';
			// Background circle
			svg += '<circle id="uinv-radial-menu-bkg" cx="' + center.x + '" cy="' + center.y + '" r="' + r2M + '" fill="url(#Gradient)" mask="url(#Mask)" pointer-events="none" />';
			// Main circle
			if (WedgeItems[0] !== undefined) {
				svg += '<circle data-id="0" data-data="' + WedgeItems[0].data + '" cx="' + center.x + '" cy="' + center.y + '" r="' + (r1M - (2*gapM)) + '"';
				if (WedgeItems[0].disabled !== true) {
					svg += ' class="uinv-wedge" fill="transparent" stroke="' + strokeColor + '" stroke-width="' + strokeWidth + '" pointer-events="auto">';
					if (showTooltips) {  // deepscan-disable-line
						svg += '<title> ' + WedgeItems[0].hint + '</title>';
					}
					svg += '<desc>' + WedgeItems[0].hint + '</desc></circle>';  // for blind users
				} else {
					svg += ' class="uinv-disabled-wedge" fill="' + disabledColor + '" stroke="' + disabledStrokeColor + '" stroke-width="' + disabledStrokeWidth + '" pointer-events="auto">';
					if (showTooltips) {  // deepscan-disable-line
						svg += '<title> ' + WedgeItems[0].hint + ' (disabled)</title>';
					}
					svg += '<desc>' + WedgeItems[0].hint + ' (disabled)</desc></circle>';  // for blind users
				}
			}
			// Main wedges
			svg += wedges(center, num, r1M, r2M, gapM, "transparent") + '</svg>';
			div.style.width = w + "px";
			div.style.height = h + "px";
			// Starting size and opacity
			div.style.transform = "scale(0, 0)";
			div.style.opacity = 0;
			$(div).html(svg);
			// Add center icon/image
			var thetaM = -0.5*Math.PI, el, elCenter, pic, isImg, i;
			for (i = 0; i < WedgeItems.length; i++) {
				isImg = false;
				if (WedgeItems[i] !== undefined) {  // Add wedge icons/images
					pic = WedgeItems[i].icon;
					if ((/^fa-*/).test(pic) && !(/\./).test(pic)) {  // if icon starts with "fa-" and does not contain ".", then assume it's a Font Awesome glyph
						el = document.createElement("div");
						el.className = "fa " + pic;
					} else {
						isImg = true;
						el = document.createElement("img");
					}
					if (i === 0) {
						elCenter = getPoint(thetaM, 0, center);
					} else {
						elCenter = getPoint(thetaM, (r1M + r2M)/2, center);
					}
					el.style.position = "absolute";
					el.style.color = iconColor;
					el.style.width = r1M + "px";
					el.style.height = r1M + "px";
					el.style.top = Math.round(elCenter.y - (r1M/2)) + "px";
					el.style.left = Math.round(elCenter.x - (r1M/2)) + "px";
					el.style["line-height"] = r1M + "px";
					el.style["font-size"] = r1M + "px";
					el.style["text-align"] = "center";
					el.style["pointer-events"] = "none";
					// prevent text and images from being highlighted/selected
					el.style["-webkit-touch-callout"] = "none";  // iOS Safari
					el.style["-webkit-user-select"] = "none";  // Safari
					el.style["-khtml-user-select"] = "none";  // Konqueror HTML
					el.style["-moz-user-select"] = "none";  // Firefox
					el.style["-ms-user-select"] = "none";  // Internet Explorer/Edge
					el.style["user-select"] = "none";  // Non-prefixed version, currently supported by Chrome and Opera
					if (WedgeItems[i].disabled === true) {
						el.style.opacity = disabledOpacity;
					}
					if (isImg) {
						el.src = setup.ImagePath + pic;
					}
					div.appendChild(el);
				}
				if (i !== 0) {
					thetaM += (2*Math.PI)/(WedgeItems.length - 1);
				}
			}
			$(div).find(".uinv-wedge").on("mouseup", wedgeClickHandler);
			$(div).find(".uinv-disabled-wedge").on("mouseup", wedgeClickHandler);
			$(div).css({
				left: Math.round(Pos.x - r2M + window.scrollX) + "px",
				top: Math.round((Pos.y - (2*r2M)) + r2M + window.scrollY) + "px",
				transform: "scale(1, 1)",
				opacity: 1
			});
			div.dataset.status = "opened";
			return true;  // Success
		},

		// DisplayItemList: Displays all items in a bag in a single string.   *** Combine items with identical names if possible
		DisplayItemList : function (BagName, PluralItemPropertyName, EmptyString, SeparatorString, ConjunctionString, SingleItemPropertyName) {
			if (UInv.isString(BagName)) {
				BagName = FixBagName(BagName);
				if (UInv.BagExists(BagName)) {
					if (!UInv.isString(PluralItemPropertyName)) {
						PluralItemPropertyName = "";
					}
					if (!UInv.isString(EmptyString)) {
						EmptyString = "nothing";
					}
					if (!UInv.isString(SeparatorString)) {
						SeparatorString = ",";
					}
					if (!UInv.isString(ConjunctionString)) {
						ConjunctionString = "and";
					}
					if (!UInv.isString(SingleItemPropertyName)) {
						SingleItemPropertyName = "";
					}
					var Items = UInv.GetItemsArray(BagName);
					if (Items.length > 0) {
						var Result = "", Amt = 0, i;
						UInv.ClearErrors();
						for (i = 0; i < Items.length; i++) {
							if ((i === Items.length - 1) && (i !== 0) && (ConjunctionString !== "")) {
								Result += ConjunctionString + " ";
							}
							Amt = UInv.BagHasItem(BagName, Items[i]);
							if (Amt === 1) {
								if (SingleItemPropertyName === "") {
									Result += Items[i];
								} else {
									if (UInv.ItemHasProperty(BagName, Items[i], SingleItemPropertyName)) {
										Result += UInv.GetItemPropertyValue(BagName, Items[i], SingleItemPropertyName);
										if (UInv.GetLastError() !== "") {
											Result += UInv.GetLastError();
											UInv.ClearErrors();
										}
									} else {
										UInvError('DisplayItemList failed. Cannot find single item property "' + SingleItemPropertyName + '" on item "' + Items[i] + '" in bag "' + BagName + '".');  // Error
										Result += Items[i];  // Use fallback item name
									}
								}
							} else {
								Amt = UInv.numberToAPString(Amt);
								if (PluralItemPropertyName === "") {
									Result += Amt + " " + Items[i];
								} else {
									if (UInv.ItemHasProperty(BagName, Items[i], PluralItemPropertyName)) {
										Result += Amt + " " + UInv.GetItemPropertyValue(BagName, Items[i], PluralItemPropertyName);
										if (UInv.GetLastError() !== "") {
											Result += UInv.GetLastError();
											UInv.ClearErrors();
										}
									} else {
										UInvError('DisplayItemList failed. Cannot find plural item property "' + PluralItemPropertyName + '" on item "' + Items[i] + '" in bag "' + BagName + '".');  // Error
										Result += Items[i];  // Use fallback item name
									}
								}
							}
							if (i < Items.length - 1) {
								if (Items.length > 2) {
									Result += SeparatorString + " ";
								} else {
									Result += " ";
								}
							}
						}
						return Result;  // Success
					}
					return EmptyString;  // Success
				} else {
					UInvError('DisplayItemList cannot find bag "' + BagName + '".');  // Error
					return '(Error: DisplayItemList cannot display unknown bag "' + BagName + '".)';
				}
			} else {
				UInvError('BagName passed to DisplayItemList is not a string.');  // Error
				return '(Error: DisplayItemList cannot display invalid bag name.)';
			}
		},

		// DisplayArray: Displays all elements in an array in a single string.
		DisplayArray : function (YourArray, EmptyString, SeparatorString, ConjunctionString, UseAPNumbers) {
			if (arguments.length < 1)  {
				return "nothing";
			}
			if (!UInv.isArray(YourArray)) {
				YourArray = [ YourArray ];
			}
			if (!UInv.isString(EmptyString)) {
				EmptyString = "nothing";
			}
			if (YourArray.length == 0) {
				return EmptyString;
			}
			if (!UInv.isString(SeparatorString)) {
				SeparatorString = ",";
			}
			if (!UInv.isString(ConjunctionString)) {
				ConjunctionString = "and";
			}
			if (!UInv.isString(UseAPNumbers)) {
				UseAPNumbers = false;
			}
			var Result = "", i;
			for (i = 0; i < YourArray.length; i++) {
				if ((i === YourArray.length - 1) && (i !== 0) && (ConjunctionString !== "")) {
					Result += ConjunctionString + " ";
				}
				if (UInv.isNumber(YourArray[i]) && UseAPNumbers) {
					Result += UInv.numberToAPString(YourArray[i]);
				} else {
					Result += YourArray[i];
				}
				if (i < YourArray.length - 1) {
					if (YourArray.length > 2) {
						Result += SeparatorString + " ";
					} else {
						Result += " ";
					}
				}
			}
			return Result;  // Success
		},

		// UpdateDisplay: Updates the display of any data-uinv="X" HTML elements.
		UpdateDisplay : function (Container) {

			function DropHandler(event, ui) {
				ui.draggable.position( { of: $(this), my: "center", at: "center" } );
				var SrcBag = ui.draggable.data("bagname");
				var DraggedItem = ui.draggable.data("itemname");
				var OldCellNo = UInv.GetItemPropertyValue(SrcBag, DraggedItem, "UInvCell");
				var DestBag = $(this).data("bagname");
				var NewCellNo = $(this).data("cellno");
				var DroppedOnItem = UInv.GetItemWherePropertyEquals(DestBag, "UInvCell", NewCellNo);
				var Quant = UInv.BagHasItem(SrcBag, DraggedItem);
				var Pos = { x: event.clientX, y: event.clientY };
				var radialMenuWedgeItems = [
					{ icon: "fa-plus-square", hint: "Drop all (" + Quant + " items)", data: "DropAll" },
					{ icon: "plus-one_white.svg", hint: "Drop one", data: "Drop1" },
					{ icon: "plus-half_white.svg", hint: "Drop half", data: "DropHalf" },
					{ icon: "minus-one_white.svg", hint: "Pick up one", data: "Take1" },
					{ icon: "plus-quarter_white.svg", hint: "Drop 1/4th", data: "DropQuarter" }];
				if (Quant == 1) {
					radialMenuWedgeItems[1].disabled = true;
				} else {
					radialMenuWedgeItems[1].hint = "Drop one (of " + Quant + " items)";
				}
				if (Quant < 4) {
					radialMenuWedgeItems[2].disabled = true;
				} else {
					radialMenuWedgeItems[2].hint = "Drop half (" + Math.trunc(Quant * 0.5) + " of " + Quant + " items)";
				}
				if (DroppedOnItem !== "") {
					if (!UInv.ItemsMatch(SrcBag, DraggedItem, DestBag, DroppedOnItem)) {  // Don't allow merge of items since they're not the same type
						radialMenuWedgeItems[3].disabled = true;
					} else {
						radialMenuWedgeItems[3].hint = "Pick up one (of " + UInv.BagHasItem(DestBag, DroppedOnItem) + " items)";
					}
				} else {
					radialMenuWedgeItems[3].disabled = true;
				}
				if (Quant < 8) {
					radialMenuWedgeItems[4].disabled = true;
				} else {
					radialMenuWedgeItems[4].hint = "Drop 1/4th (" + Math.trunc(Quant * 0.25) + " of " + Quant + " items)";
				}
				event.srcBag = SrcBag;
				event.draggedItem = DraggedItem;
				event.oldCellNo = OldCellNo;
				event.destBag = DestBag;
				event.droppedOnItem = DroppedOnItem;
				event.newCellNo = NewCellNo;
				event.pos = clone(Pos);
				event.ui = ui;
				event.radialMenuWedgeItems = clone(radialMenuWedgeItems);
				var Ret = UInv.CallEventHandler("table", "Drop", event);  // table Drop event
				if (Ret.openRadialMenu === true) {
					if (!UInv.isUndefined(Ret.radialMenuWedgeItems)) {
						if (!UInv.isProperty(Ret, "radialMenuOptions")) {
							Ret.radialMenuOptions = undefined;
						}
						if (!UInv.isProperty(Ret, "radialMenuHandler")) {
							Ret.radialMenuHandler = undefined;
						}
						UInv.DisplayRadialMenu(Ret.radialMenuWedgeItems, Pos, Ret.radialMenuHandler, Ret.radialMenuOptions);
						Ret.overrideDefaultAction = true;
					} else {
						Ret.radialMenuWedgeItems = clone(radialMenuWedgeItems);
					}
				} else {  // If return values not set, set with defaults.
					if (UInv.isUndefined(Ret.radialMenuWedgeItems)) {
						Ret.radialMenuWedgeItems = clone(radialMenuWedgeItems);
					}
					if (!UInv.isProperty(Ret, "radialMenuOptions")) {
						Ret.radialMenuOptions = undefined;
					}
					if (!UInv.isProperty(Ret, "radialMenuHandler")) {
						Ret.radialMenuHandler = undefined;
					}
				}
				if (UInv.isProperty(setup, "UInvRadialMenuData")) {
					delete setup.UInvRadialMenuData;
				}
				setup.UInvRadialMenuData = {  // Store data for radial menu events
					srcBag: SrcBag,
					draggedItem: DraggedItem,
					oldCellNo: OldCellNo,
					destBag: DestBag,
					droppedOnItem: DroppedOnItem,
					newCellNo: NewCellNo,
					radialMenuWedgeItems: clone(Ret.radialMenuWedgeItems),
					pos: clone(Pos),
					radialMenuHandler: Ret.radialMenuHandler,
					radialMenuOptions: clone(Ret.radialMenuOptions)
				};
				if (Ret.overrideDefaultAction !== true) {
					if (DroppedOnItem !== "") {
						if ((SrcBag != DestBag) || (OldCellNo != NewCellNo)) {  // Make sure item wasn't dropped back at original location
							if (UInv.ItemsMatch(SrcBag, DraggedItem, DestBag, DroppedOnItem)) {  // Merge items since they're the same type
								if (Quant > 1) {
									UInv.DisplayRadialMenu(radialMenuWedgeItems, Pos);
								} else {
									UInv.IncrementUpdateLock();
									if (DestBag != SrcBag) {  // Move to new bag
										UInv.MoveItem(SrcBag, DestBag, DraggedItem);  // handle move failure due to pocket protection ***
									}
									UInv.SetItemPropertyValue(DestBag, DraggedItem, "UInvCell", NewCellNo);
									UInv.DecrementUpdateLock();
								}
							} else {  // Swap items
								UInv.IncrementUpdateLock();
								UInv.SwapItems(SrcBag, DraggedItem, DestBag, DroppedOnItem, "UInvCell");
								UInv.DecrementUpdateLock();
							}
						}
					} else {  // Change UInvCell to new cell
						if ((Quant > 1) && (SrcBag != DestBag)) {
							UInv.DisplayRadialMenu(radialMenuWedgeItems, Pos);
						} else {
							UInv.IncrementUpdateLock();
							if (DestBag != SrcBag) {  // Move to new bag
								UInv.MoveItem(SrcBag, DestBag, DraggedItem);  // handle move failure due to pocket protection ***
							}
							UInv.SetItemPropertyValue(DestBag, DraggedItem, "UInvCell", NewCellNo);
							UInv.DecrementUpdateLock();
						}
					}
				}
			}

			if (UInv.isUndefined(Container)) {
				Container = document;
			}
			var Matches = $(Container).find("[data-uinv]");
			if (Matches.length > 0) {
				var i, Table, BagName, CellMargin, BorderMargin, CellRows, x, CellCols, y, Row, RowClass, CellClass, ItemClass, IconClass, TextClass, PadTxt, Count, Item, Txt;
				for (i = 0; i < Matches.length; i++) {
					Count = 0;
					if ($(Matches[i]).data("uinv") === "table") {  // Update tables
						Table = $(Matches[i]);
						BagName = Table.attr("id");
						UInv.FixTableCells(BagName, Table);
						CellMargin = Table.data("cellmargin");
						BorderMargin = Table.data("bordermargin");
						CellRows = Table.data("cellrows");
						CellCols = Table.data("cellcolumns");
						RowClass = Table.data("rowclass");
						CellClass = Table.data("cellclass");
						ItemClass = Table.data("itemclass");
						IconClass = Table.data("iconclass");
						TextClass = Table.data("textclass");
						Table.find("[data-uinv='item']").off();  // Release handlers
						Table.empty();
						for (x = 0; x < CellRows; x++) {
							Table.append('<div class="' + RowClass + '" id="' + BagName + '-row' + x + '" data-uinv="table-row"></div>');
							Row = $(Container).find("#" + BagName + "-row" + x);
							for (y = 0; y < CellCols; y++) {
								PadTxt = "";
								if (x === 0) {
									PadTxt = ' margin-top: ' + (BorderMargin + CellMargin) + 'px;';
								}
								if (x === CellRows - 1) {
									PadTxt += ' margin-bottom: ' + (BorderMargin + CellMargin) + 'px;';
								}
								if (y === 0) {
									PadTxt += ' margin-left: ' + (BorderMargin + CellMargin) + 'px;';
								}
								if (y === CellCols - 1) {
									PadTxt += ' margin-right: ' + (BorderMargin + CellMargin) + 'px;';
								}
								Item = UInv.GetItemWherePropertyEquals(BagName, "UInvCell", Count);
								if (Item !== "") {
									Txt = '<span data-uinv="table-cell" class="' + CellClass + '" id="' + BagName + '-cell' + Count + '" data-bagname="' + BagName + '" data-cellno=' + Count++ + ' style="margin: ' + CellMargin + 'px;' + PadTxt + '">';
									Txt += '<div data-uinv="item" class="' + ItemClass + '" id="' + BagName + '-item-' + Item + '" data-bagname="' + BagName + '" data-itemname="' + Item + '">';
									Txt += '<img src="' + setup.ImagePath + UInv.GetItemPropertyValue(BagName, Item, "image") + '" class="' + IconClass + '" id="' + BagName + '-icon-' + Item + '" unselectable="on" onselectstart="return false;">';
									if (UInv.BagHasItem(BagName, Item) > 1) {
										Txt += '<span class="' + TextClass + '" id="' + BagName + '-text' + Count + '" unselectable="on" onselectstart="return false;">' + UInv.BagHasItem(BagName, Item) + '</span>';
									}
									Txt += '</div></span>';
									Row.append(Txt);
								} else {
									Row.append('<span data-uinv="table-cell" class="' + CellClass + '" id="' + BagName + '-cell' + Count + '" data-bagname="' + BagName + '" data-cellno=' + Count++ + ' style="margin: ' + CellMargin + 'px;' + PadTxt + '"></span>');
								}
							}
						}
					}
					// Add update code for future display objects here.
				}
				if (UInv.isFunction($(Container).find("[data-uinv='table-cell']").droppable)) {
					$(Container).find("[data-uinv='table-cell']")
						.droppable({  // see: http://api.jqueryui.com/droppable/ & https://jqueryui.com/droppable/
							scope: "first",
							revert: "invalid",
							accept: function (el) {
								// This gets called once for each droppable element on DragStart
								var SrcBag = $(el).data("bagname");
								var DraggedItem = $(el).data("itemname");
								var DestBag = $(this).data("bagname");
								var NewCellNo = $(this).data("cellno");
								var DroppedOnItem = UInv.GetItemWherePropertyEquals(DestBag, "UInvCell", NewCellNo);
								el.srcBag = SrcBag;
								el.draggedItem = DraggedItem;
								el.destBag = DestBag;
								el.droppedOnItem = DroppedOnItem;
								el.newCellNo = NewCellNo;
								el.acceptVal = $(el).hasClass("dragging");  // drag indicator
								var Ret = UInv.CallEventHandler("table", "Accept", el);  // table Accept event
								if (UInv.isProperty(Ret, "acceptVal")) {
									return Ret.acceptVal;
								} else {
									return $(el).hasClass("dragging");  // drag indicator
								}
							},
							drop: DropHandler
						});
					$(Container).find("[data-uinv='item']")
						.on("mousedown touchstart", function (ev) {  // event handler here?  ***
							if (ev.button == 0) {
								$(this).addClass("grabbing");
							} })
						.on("mouseup touchend", function (ev) {  // event handler here?  ***
							if (ev.button == 0) {
								$(this).removeClass("grabbing");
							} })
						.draggable({  // see: https://api.jqueryui.com/draggable/ & https://jqueryui.com/draggable/
							revert: "invalid",
							containment: "document",
							scope: "first",
							cursor: "grabbing",
							snap: false,
							start: function (event, ui) {
								if (event.button == 0) {
									$(this).addClass("grabbing");
									$(this).addClass("dragging");  // drag indicator
									if (!UInv.isUndefined(event.target.setCapture)) {
										event.target.setCapture();
									}
									var SrcBag = $(this).data("bagname");
									var DraggedItem = $(this).data("itemname");
									event.srcBag = SrcBag;
									event.draggedItem = DraggedItem;
									event.ui = ui;
									UInv.CallEventHandler("table", "DragStart", event);  // table DragStart event
									/*
									var Ret = UInv.CallEventHandler("table", "DragStart", event);  // table DragStart event
									if (Ret.someValue != true) {
									}
									*/
								} else {
									event.preventDefault();
								}
							},
							stop: function (event, ui) {
								$(this).removeClass("grabbing");
								$(this).removeClass("dragging");  // drag indicator
								var SrcBag = $(this).data("bagname");
								var DraggedItem = $(this).data("itemname");
								event.srcBag = SrcBag;
								event.draggedItem = DraggedItem;
								event.ui = ui;
								UInv.CallEventHandler("table", "DragStop", event);  // table DragStart event
								/*
								var Ret = UInv.CallEventHandler("table", "DragStart", event);  // table DragStart event
								if (Ret.someValue != true) {
								}
								*/
							}
						});
				} else {
					// Page reload from browser (such as CTRL+F5) caused drag-drop to not get set up properly, so retry.
					setTimeout(UInv.UpdateDisplay, 100);
				}
			}
			return true;
		},


		// UInv Other Functions:
		// =====================

		// GetUserAlerts: Returns the $UInvShowAlerts value (or false if it doesn't exist).
		GetUserAlerts : function () {
			if (!UInv.isUndefined(setup.UInvUserAlertsDebug)) {  // Handle "xyzzy" debug override on reload of save file.
				if (UInv.isUndefined(State.variables.UInvShowAlerts) || State.variables.UInvShowAlerts !== setup.UInvUserAlertsDebug) {
					setup.UInvUserAlertsBackup = State.variables.UInvShowAlerts;
					UInv.SetUserAlerts(setup.UInvUserAlertsDebug);
					console.log('UInv: Game restarted with console logging enabled through debug override. Type "xyzzy" while on game window to cancel.');
				}
			}
			if (UInv.isProperty(State.variables, "UInvShowAlerts")) {
				return State.variables.UInvShowAlerts;
			}
			return false;
		},

		// SetUserAlerts: Allows the type of error messages returned by UInv to be controlled.  Returns the current value of $UInvShowAlerts.
		SetUserAlerts : function (ErrorSetting, ErrorStringAddendum) {
			if (!UInv.isUndefined(ErrorSetting)) {
				if (UInv.isInteger(ErrorSetting)) {
					State.variables.UInvShowAlerts = ErrorSetting;
				} else if (ErrorSetting) {
					State.variables.UInvShowAlerts = UInv.ERROR_THROW_ERROR + UInv.ERROR_SHOW_PASSAGE_NAME;  // Default
				} else {
					if (UInv.isProperty(State.variables, "UInvShowAlerts")) {
						delete State.variables.UInvShowAlerts;
					}
				}
			}
			if (!UInv.isUndefined(ErrorStringAddendum)) {
				if (UInv.isString(ErrorStringAddendum) || UInv.isNumber(ErrorStringAddendum) || UInv.isObject(ErrorStringAddendum) || UInv.isBoolean(ErrorStringAddendum)) {
					if (ErrorStringAddendum === "") {
						if (UInv.isProperty(State.variables, "UInvErrorStringAddendum")) {
							delete State.variables.UInvErrorStringAddendum;
						}
					} else {
						State.variables.UInvErrorStringAddendum = ErrorStringAddendum;
					}
				}
			}
			return UInv.GetUserAlerts();
		},

		// ClearErrors: Sets the error string to "".
		ClearErrors : function () {
			State.variables.UInvLastErrorMessage = "";
			return true;  // Success
		},

		// GetLastError: Returns the last error string.  Also clears error messages if Clear is set to true.
		GetLastError : function (Clear) {
			var Err = "";
			if (UInv.isUndefined(Clear)) {
				Clear = false;
			}
			if (UInv.isProperty(State.variables, "UInvLastErrorMessage")) {
				Err = State.variables.UInvLastErrorMessage;
			}
			if (Clear) {
				UInv.ClearErrors();
			}
			return Err;  // Success
		},

		// SetMergeItemMethod: Sets the $UInvMergeItemMethod variable which controls how UInv handles cases where functions attempt to merge two non-equal items.
		SetMergeItemMethod : function (Method) {
			if (!UInv.isUndefined(Method)) {
				if ((Method >=1) && (Method <= 6)) {
					State.variables.UInvMergeItemMethod = Method;
					return true;  // Sets merge method
				} else {
					if (!UInv.isProperty(State.variables, "UInvMergeItemMethod")) {
						State.variables.UInvMergeItemMethod = UInv.MERGE_USE_ONLY_DESTINATION_PROPERTIES;  // default
					}
					return false;  // Value not valid
				}
			} else {
				if (!UInv.isProperty(State.variables, "UInvMergeItemMethod")) {
					State.variables.UInvMergeItemMethod = UInv.MERGE_USE_ONLY_DESTINATION_PROPERTIES;  // default
				}
				return false;  // Value not valid
			}
		},

		// Initialize: Set up variables.  Returns "false" if any were already set, otherwise it returns "true".
		Initialize : function (DisplayErrors) {

			var ignoredElements = [];  // ["a", "button"];  // Add element names to prevent clicks from triggering events when clicking on those elements.
			function handleMouseDown (ev) {
				var Ret = UInv.CallEventHandler("general", "MouseDown", ev);  // general MouseDown event
				if (Ret.stopPropagation === true) {
					ev.stopPropagation();
				}
				if (ev.button == 0) {
					if ((($(ev.target).parents("#story").length > 0) || ($(ev.target).parents().length <= 2))  // Make sure that the click is in the story area or the background, not on the UI bar
						&& (ev.clientX < document.documentElement.offsetWidth) && (ev.clientY < document.documentElement.offsetHeight)  // Ignore clicks on the scrollbar
						&& !ignoredElements.includes(ev.target.localName))  // Ignore clicks on certain elements
					{
						var el = $("#uinv-radial-menu").get(0);
						if (UInv.isUndefined(el)) {
							UInv.InitializeRadialMenu();
						} else {
							if (el.dataset.status == "opened") {  // Cancel radial menu
								ev.cancelType = "MouseDown";
								Ret = UInv.CallEventHandler("radialMenu", "Cancel", ev);  // radialMenu Cancel event (MouseDown)
								if (Ret.keepOpen !== true) {
									el.dataset.status = "closed md";
									el.style.transform = "scale(0, 0)";
									el.style.opacity = 0;
								}
								UInv.UpdateDisplay();
							}
						}
					}
				}
			}
			function handleMouseUp (ev) {
				if (ev.button == 0) {
					if ((($(ev.target).parents("#story").length > 0) || ($(ev.target).parents().length <= 2))  // Make sure that the click is in the story area or the background, not on the UI bar
						&& (ev.clientX < document.documentElement.offsetWidth) && (ev.clientY < document.documentElement.offsetHeight)  // Ignore clicks on the scrollbar
						&& !ignoredElements.includes(ev.target.localName))  // Ignore clicks on certain elements
					{
						var el = $("#uinv-radial-menu").get(0);
						if (UInv.isUndefined(el)) {
							UInv.InitializeRadialMenu();
						} else {
							if (el.dataset.status == "opened") {  // Cancel radial menu
								ev.cancelType = "MouseUp";
								var Ret = UInv.CallEventHandler("radialMenu", "Cancel", ev);  // radialMenu Cancel event (MouseUp)
								if (Ret.keepOpen !== true) {
									el.dataset.status = "closed";
									el.style.transform = "scale(0, 0)";
									el.style.opacity = 0;
								}
								UInv.UpdateDisplay();
							} else {
								if (el.dataset.status == "closed md") {
									el.dataset.status = "closed";
								/*
								} else {  // Open radial menu at new location
									$("#event").empty().wiki("Opened");  // pass this to a handler function??? check to see if radial menu should be opened, and get icons and options? ***
									el.dataset.status = "opened";
									var r = parseInt(el.dataset.r);
									el.style.left = Math.round(ev.clientX - r + window.scrollX) + "px";
									el.style.top = Math.round((ev.clientY - (2*r)) + r + window.scrollY) + "px";
									el.style.transform = "scale(1, 1)";
									el.style.opacity = 1;
								*/
								}
							}
						}
					}
				}
			}

			var Result = true;
			if (UInv.isProperty(State.variables, "UInvBags")) {
				delete State.variables.UInvBags;
				State.variables.UInvBags = {};
				Result = false;
			} else {
				State.variables.UInvBags = {};
			}
			if (UInv.isProperty(State.variables, "UInvCurrentBagName")) {
				delete State.variables.UInvCurrentBagName;
				Result = false;
			}
			if (UInv.isProperty(State.variables, "UInvCurrentItemName")) {
				delete State.variables.UInvCurrentItemName;
				Result = false;
			}
			if (UInv.isProperty(State.variables, "UInvErrorStringAddendum")) {
				delete State.variables.UInvErrorStringAddendum;
				Result = false;
			}
			if (UInv.isUndefined(setup.UInvUserAlertsDebug)) {
				if (UInv.isProperty(State.variables, "UInvShowAlerts")) {
					if (UInv.isUndefined(DisplayErrors)) {
						UInv.SetUserAlerts(false);
					} else {
						UInv.SetUserAlerts(DisplayErrors);
					}
					Result = false;
				} else {
					if (DisplayErrors) {
						UInv.SetUserAlerts(DisplayErrors);
					}
				}
			} else {
				UInv.SetUserAlerts(setup.UInvUserAlertsDebug);  // "xyzzy" debug override
				if (UInv.isUndefined(DisplayErrors)) {
					setup.UInvUserAlertsBackup = false;
				} else {
					setup.UInvUserAlertsBackup = DisplayErrors;
				}
				console.log('UInv: Game reinitialized with console logging enabled through debug override. Type "xyzzy" while on game window to cancel.');
			}
			if (UInv.isProperty(State.variables, "UInvLastErrorMessage")) {
				Result = false;
			}
			UInv.ClearErrors();
			if (UInv.isProperty(State.variables, "UInvMergeItemMethod")) {
				Result = false;
			}
			UInv.SetMergeItemMethod(UInv.MERGE_USE_ONLY_DESTINATION_PROPERTIES);  // default
			if (UInv.isProperty(State.variables, "UInvEventHandlers")) {
				delete State.variables.UInvEventHandlers;
				State.variables.UInvEventHandlers = {};
				Result = false;
			} else {
				State.variables.UInvEventHandlers = {};
			}
			// Prepare radial menu
			var div = $("#uinv-radial-menu").get(0);
			if (UInv.isUndefined(div)) {
				UInv.InitializeRadialMenu();
			}
			// Set up mouse down and up event handlers
			$(document).on("mousedown", handleMouseDown);
			$(document).on("mouseup", handleMouseUp);
			$("html").css("height", "100%");  // Make sure the whole window is covered so horizontal scrollbars can be properly detected.
			return Result;
		},

		// Version: Return a string showing the version of UInv.
		Version : function () {
			return "Universal Inventory System (<a href='https://github.com/HiEv/UInv'>UInv</a>) v0.9.7 by HiEv";  // Success
		},


		/* ------------------------------------------------------ */
		/*  END OF COPY-AND-PASTE SECTION FOR UPDATING UInv CODE  */
		/* --------------------------8<-------------------------- */


		// UInv Aliases:
		// =============

		// Add your own function aliases here.  Make sure they are not named the same as any of the existing functions.

		AddToBagValue : function (BagName, BagPropertyName, Amount) {
			return UInv.AddToBagPropertyValue(BagName, BagPropertyName, Amount);
		},

		AddToItemValue : function (BagName, ItemName, ItemPropertyName, Amount) {
			return UInv.AddToItemPropertyValue(BagName, ItemName, ItemPropertyName, Amount);
		},

		ArrayHasAllBagProperties : function (BagName, BagPropertyNameArray) {
			return UInv.BagHasAllProperties(BagName, BagPropertyNameArray);
		},

		ArrayHasAllItemProperties : function (BagName, ItemName, ItemPropertyNameArray) {
			return UInv.ItemHasAllProperties(BagName, ItemName, ItemPropertyNameArray);
		},

		BagArray : function () {
			return UInv.GetBagsArray();
		},

		BagCount : function () {
			return UInv.GetBagCount();
		},

		BagsExist : function (BagNameArray) {
			return UInv.BagExists(BagNameArray);
		},

		BagHasAnyBagTags : function (BagName, BagPropertyName, BagTagArray) {
			return UInv.BagHasAnyBagTag(BagName, BagPropertyName, BagTagArray);
		},

		BagHasAnyItemTags : function (BagName, ItemPropertyName, ItemTagArray) {
			return UInv.BagHasAnyItemTag(BagName, ItemPropertyName, ItemTagArray);
		},

		BagHasContainer : function (BagName) {
			return UInv.BagIsPocket(BagName);
		},

		BagHasProperties : function (BagName, BagPropertyNameArray) {
			return UInv.BagHasProperty(BagName, BagPropertyNameArray);
		},

		CopyBagProperties : function (SourceBagName, DestinationBagName, BagPropertyNameArray) {
			return UInv.CopyBagProperty(SourceBagName, DestinationBagName, BagPropertyNameArray);
		},

		GetBagArrayWithAllProperties : function (BagPropertyNameArray) {
			return UInv.GetBagsArrayWithAllProperties(BagPropertyNameArray);
		},

		GetBagValue : function (BagName, BagPropertyName) {
			return UInv.GetBagPropertyValue(BagName, BagPropertyName);
		},

		GetCellsItemName : function (BagName, Cell) {
			return UInv.GetItemWherePropertyEquals(BagName, "UInvCell", Cell);
		},

		GetHighestBagPropertyValue : function (BagPropertyName, BagNameArray) {
			return UInv.GetBagWithHighestPropertyValue(BagPropertyName, BagNameArray);
		},

		GetHighestBagValue : function (BagPropertyName, BagNameArray) {
			return UInv.GetBagWithHighestPropertyValue(BagPropertyName, BagNameArray);
		},

		GetHighestItemPropertyValue : function (BagName, ItemPropertyName) {
			return UInv.GetItemWithHighestPropertyValue(BagName, ItemPropertyName);
		},

		GetLowestBagPropertyValue : function (BagPropertyName, BagNameArray) {
			return UInv.GetBagWithLowestPropertyValue(BagPropertyName, BagNameArray);
		},

		GetLowestBagValue : function (BagPropertyName, BagNameArray) {
			return UInv.GetBagWithLowestPropertyValue(BagPropertyName, BagNameArray);
		},

		GetLowestItemPropertyValue : function (BagName, ItemPropertyName) {
			return UInv.GetItemWithLowestPropertyValue(BagName, ItemPropertyName);
		},

		GetItemQuantity : function (BagName, ItemName) {
			return UInv.BagHasItem(BagName, ItemName);
		},

		GetItemValue : function (BagName, ItemName, ItemPropertyName) {
			return UInv.GetItemPropertyValue(BagName, ItemName, ItemPropertyName);
		},

		HasItem : function (BagName, ItemName) {
			return UInv.BagHasItem(BagName, ItemName);
		},

		ItemHasAnyTags : function (BagName, ItemName, ItemPropertyName, ItemTagArray) {
			return UInv.ItemHasAnyTag(BagName, ItemName, ItemPropertyName, ItemTagArray);
		},

		ItemIsContainer : function (BagName, ItemName, PocketName) {
			return UInv.ItemHasPocket(BagName, ItemName, PocketName);
		},

		ItemQuantity : function (BagName, ItemName) {
			return UInv.BagHasItem(BagName, ItemName);
		},

		SetBagsPropertyValue : function (BagNameArray, BagPropertyName, Value) {
			return UInv.SetBagPropertyValue(BagNameArray, BagPropertyName, Value);
		},

		SetBagsTouched : function (BagNameArray) {
			return UInv.SetBagTouched(BagNameArray);
		},

		SetBagsUntouched : function (BagNameArray) {
			return UInv.SetBagUntouched(BagNameArray);
		},

		SetBagValue : function (BagName, BagPropertyName, Value) {
			return UInv.SetBagPropertyValue(BagName, BagPropertyName, Value);
		},

		SetItemsPropertyValues : function (BagName, ItemPropertyName, Value) {
			return UInv.SetItemsPropertyValue(BagName, ItemPropertyName, Value);
		},

		SetItemValue : function (BagName, ItemName, ItemPropertyName, Value) {
			return UInv.SetItemPropertyValue(BagName, ItemName, ItemPropertyName, Value);
		},

		UpdateItemProperties : function (BagName, ItemName, ValuesObject) {
			return UInv.SetItemPropertyValues(BagName, ItemName, ValuesObject);
		},

		// End of aliases.


		// UInv Developer Data Functions:
		// ==============================

		// BagData: This is where you set the default properties and/or
		//          items for the default bags.
		BagData : function (DefaultBagType, PropertiesOnly) {
			var BagProperties = {}, BagItems = [];
			switch(DefaultBagType) {

		/*  IMPORTANT!:
			Bag types must be unique strings in all lowercase.
			Bag types cannot be "-" (the minus sign) or "" (an empty string).
			Property names can be upper and/or lowercase strings.
			Property names with spaces in them must be inside quotes.
			Property names are case sensitive, so a property named "XYZ"
			is different from properties named "Xyz" or "xyz".
			Bag and property names cannot start with a number.
			An bag cannot have more than one property with the same name.
			Property values can be strings, numbers, booleans, or arrays.
			Objects and functions are unsupported property value types.
			Multiple successive case lines with no "break;" between them
			will be treated as different bags with the same properties.
			Quote marks inside strings need to have a backslash before
			them.  (e.g. "Bob said, \"Hello.\"")
			Backslashes will also need a backslash before them.

			New bags should be added in the following format:

			case "unique-lowercase-bag-name-string":
				BagProperties = {
						unique-property-name1-string : property-value1,
						unique-property-name2-string : property-value2,
						...
					};
				BagItems = [

						// String Method = 1 item of that type
						"item-name-string1",

						// Quantity Method = Quantity items of that type
						{ item-name-string2 : Quantity },  // Quantity must be an integer

						// Type Method = UInvQuantity items of type UInvDefaultItemType
						{ item-name-string3 : { UInvDefaultItemType : "item-type",  UInvQuantity : Quantity } },

						// Creation Method = UInvQuantity items of type UInvDefaultItemType
						{ item-name-string4 : { UInvQuantity : Quantity,  property-name1 : value1,  ... } },

						...
					];
					// Use the String Method for single items of a default type,
					// the Quantity Method for multiple items of a default type,
					// the Type Method for items whose type doesn't match the item name,
					// or the Creation Method to create items without a default type.
					// All items should be passed as a single array of items.
				break;  // This ends the current "case" statement.

			The BagProperties and BagItems lines are optional.  You can
			leave either of them out if you don't need to set the bag's
			properties or items, respectively.

			For a bag's items, you can add them a couple of ways.  Use the
			String Method (as shown above) for single items of a default type,
			the Quantity Method for multiple items of a default type, the
			Type Method for items whose type doesn't match the item name
			(UInvQuantity defaults to 1 if not included), or the Creation
			Method to create items without a default type.  If you combine the
			Type Method and Creation Method by having "UInvDefaultItemType"
			plus other properties, then it will use the default type and have
			the other properties override that type's default properties.

			Generally it's recommended that you create a default item instead
			of using the Creation Method for adding default items to bags,
			though it can be useful for adding items with no properties, or
			when used in combination with the Type Method.

			Item names must be formatted as described in the ItemData section.

			NOTE: If any of a bag's _properties_ are variable, then in
			BagProperties the property "UInvVariableType" has to be set to
			something (it doesn't matter what).  However, you do *NOT* need
			to add the "UInvVariableType" property if any of the _items_ that
			may be in the bag can vary.

			It's recommended that you list your bags alphabetically both
			to help avoid duplicating names and to make them easier to find
			if you need to modify them later.

			Example bags below can be removed.

		YOUR DEFAULT BAGS GO BELOW THIS LINE.  */

		// Start of example bags.

				case "backpack":
					BagProperties = { maxCarryWeight : 20 };  // This sets the "maxCarryWeight" property of the "backpack" type bag to 20.
					BagItems = [ "pants", "belt", { dagger : 2 } ];  // This adds 1 pants, 1 belt, and 2 dagger items to the backpack.  Single items do not need {} around them.
					break;  // This ends the current "case" statement.

				case "clothing":
					BagProperties = { description: "A pile of clothing." };
					BagItems = [
						// This adds 1 "shoes" (of type "shoes")
						"shoes",
						// This adds 4 "pants" (of type "pants")
						{ "pants" : 4 },
						// This adds 2 "black belt" (of type "belt")
						{ "black belt" : {
							UInvDefaultItemType : "belt",
							UInvQuantity : 2,
							// override default belt "description" property
							description : "A black belt." }
						},
						// This creates 3 "shirt" as described
						{ "shirt" : {
							UInvQuantity : 3,
							type : ["clothing"],
							singular : "a shirt",
							plural : "shirts",
							place : ["torso2"],
							size : 3,
							image : "icon_cloth_shirt1.png",
							description : "An ordinary white shirt." }
						}
					];
					break;

				case "treasure bag":
					BagProperties = {
						UInvVariableType : true,  // If a bag's *properties* are variable, like this one, then the UInvVariableType bag property has to be set to something (it doesn't matter what).
						quality : ["new", "average", "worn"].random()  // Picks a random bag quality level.
					};
					BagItems = [
						{ "gold coin" : random(2, 20) },  // Each bag randomly has 2 to 20 coins and a random item from the treasures bag item list.
						UInv.BagData("treasures").random()  // Adds 1 random treasure from the "treasures" type bag below in the next case statement.
					];
					break;

				case "treasures":  // This is used as a list of possible random treasures by "treasure bag" type bag above.
					BagItems = [ "pants", "belt", "dagger", "shortsword", "heavy mace", "rainbow potion" ];
					break;

				case "suit pocket":  // This bag is for an infinite loop test, since it will have a suit in each suit pocket.  Normally you should avoid such loops.
					BagProperties = { maxCarryWeight : 5 };
					BagItems = [ "suit" ];
					break;

		// End of example bags.

		// YOUR DEFAULT BAGS GO ABOVE THIS LINE.

				default:
					return undefined;  // Bag not found
			}
			if (PropertiesOnly) {
				return BagProperties;
			} else {
				return BagItems;
			}
		},


		// ItemData: This is where you set the default properties for the
		//           default items.
		ItemData : (function () {
			var Items = {};

		/*  IMPORTANT!:       --Static Items Information--
			Items with consistent default property values are "static items".
			Items with property values that may vary are "variable items".
			Item names must be unique strings in all lowercase.
			Item names cannot be "uinvtouched", "uinvproperties",
			"uinvdefaultbagtype", "uinvcontainer", "-" (the minus sign),
			or "" (an empty string), they're reserved for use by UInv.
			Property names can be upper and/or lowercase strings.
			Property names with spaces in them must be inside quotes.
			Property names are case sensitive, so a property named "XYZ"
			is different from properties named "Xyz" or "xyz".
			Item and property names cannot start with a number.
			An item cannot have more than one property with the same name.
			An item cannot have a property named "UInvQuantity" or
			"UInvDefaultItemType", they're reserved for use by UInv.
			Property values can be strings, numbers, booleans, or arrays.
			Objects and functions are unsupported property value types.
			Quote marks inside strings need to have a backslash before
			them.  (e.g. "Bob said, \"Hello.\"")
			Backslashes will also need a backslash before them.

			Static items should be added in the following format:

			Items.itemname = { property-name-string1 : property-value1,
							property-name-string2 : property-value2,
							etc...
							};

			"itemname" must be a unique, lowercase, alphanumberic string which
			cannot start with a number.  If it contains a space then it needs
			to be in this format:

			Items['item name'] = { property-name-string1 : property-value1,
								property-name-string2 : property-value2,
								etc...
								};

			If an item's properties are variable, then they should be set in
			the "variable items" section instead (see below).

			It's recommended that you list your items alphabetically both
			to help avoid duplicating names and to make them easier to find
			if you need to modify them later.

			Example items below can be removed.

		YOUR DEFAULT -STATIC ITEMS- GO BELOW THIS LINE.  */

		// Start of example static items.

		Items.letter = {
			name : "letter",
			type : "key item",
			singular : "a letter",
			plural : "letters",
			description : "it's a fucking letter"
		};
		
		Items["moondrop flower"] = {
			singular : "a Moondrop Flower",
			plural : "Moondrop Flowers",
			type : "Quest"
		};
				
		Items.potion = {
			name : "potion",
			type : "consumable",
			singular : "a potion",
			plural : "potions",
			description : "A healing potion."
		};

		
		// End of example static items.

		// YOUR DEFAULT -STATIC ITEMS- GO ABOVE THIS LINE.

			return function (DefaultItemType) {
				if (!UInv.isString(DefaultItemType)) {
					UInvError('ItemData failed. DefaultItemType is not a string.');  // Error
					return undefined;
				}
				var Item = undefined;  // jshint ignore:line
				switch(DefaultItemType) {

			/*  IMPORTANT!:       --Variable Items Information--
				Items with consistent default property values are "static items".
				Items with property values that may vary are "variable items".
				Item names, property names, and property values for variable
				items must follow the same rules as the static items above.

				If an item's property values are variable, then the property
				"UInvVariableType" has to be set to something (it doesn't
				matter what).

				Variable items should be added in the following format:

				case "itemname":
					// Other code may go here.
					Item = { property-name-string1 : property-value1,
							property-name-string2 : property-value2,
							... };
					break;  // This ends the current "case" statement.

				Example items below can be removed.

			YOUR DEFAULT -VARIABLE ITEMS- GO BELOW THIS LINE.  */

			// Start of example variable items.

					case "bow":  // Gives you a bow with 10 to 20 arrows.
						Item = { arrows: random(10, 20), type : ["weapon", "ranged", "piercing", "2-handed"], singular : "a bow", plural : "bows", size : 5, image : "bow.png", description : "A bow." };
						break;  // This ends the current "case" statement.

					case "rainbow potion":  // This produces a potion item of a random color.
						var color = ["red", "orange", "yellow", "green", "blue", "purple"].random();  // Randomly picks a color.
						var article = color === "orange" ? "an " : "a ";  // Sets the "article" variable to "a ", unless the color equals "orange", in that case it sets it to "an ".
						Item = {
							UInvVariableType : color,  // Because this item's property values can vary, the "UInvVariableType" property has to be set to something.
							type : ["potion"],
							singular : article + color + " potion",
							plural : color + " potions",
							size : 1,
							image : "potion" + color.toUpperFirst() + ".png",
							description : article.toUpperFirst() + color + " potion."
						};
						break;  // This ends the current "case" statement.

			// End of example variable items.

			// YOUR DEFAULT -VARIABLE ITEMS- GO ABOVE THIS LINE.

				}
				if (UInv.isUndefined(Item)) {  // If it's not a variable type...
					if (UInv.isProperty(Items, DefaultItemType)) {
						return clone(Items[DefaultItemType]);  // Static item
					} else {
						return undefined;  // Item not found
					}
				} else {  // If it *is* a variable type...
					if (!UInv.isProperty(Item, "UInvVariableType")) {  // Add UInvVariableType property if it's missing.
						Item.UInvVariableType = true;
					}
					return Item;  // Variable item
				}
			};
		})(),

		// OPTIONAL: You can list the names of your default bags here so
		//           you can find them by searching "UInv.BagList[index]".
		BagList: ["backpack", "clothes", "treasure bag", "treasures", "suit pocket"],

		// OPTIONAL: You can list the names of your default items here so
		//           you can find them by searching "UInv.ItemList[index]".
		ItemList: ["backpack", "belt", "bow", "dagger", "gold coin", "heavy mace", "pants", "rainbow potion", "shoes", "shortsword", "suit"]
	};
})();
window.UInv = new UInvObject();  // Create the UInv object

/* NOTE:
   It's recommended that you pass "UInv.Initialize" (below) the value of
   "UInv.ERROR_THROW_ERROR" and/or "UInv.ERROR_TO_CONSOLE" when testing your
   code.
*/
UInv.Initialize(UInv.ERROR_NONE);  // Readies UInv variables and events

/* Uncomment the line following this comment (remove the leading "// ")
   and set it to something else if you prefer a different manner of dealing
   with item collisions.
*/
// UInv.SetMergeItemMethod(UInv.MERGE_USE_ONLY_DESTINATION_PROPERTIES);

/*
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!!                                                             !!
	!!  REMINDER: If you're updating UInv you should only replace  !!
	!!  the code up to the "END OF COPY-AND-PASTE" marker above!   !!
	!!                                                             !!
	!!  DO NOT ACCIDENTALLY OVERWRITE YOUR DEFAULT BAGS & ITEMS!   !!
	!!                                                             !!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*/

/* -- End of Universal Inventory System (UInv) code -- */






















</script><tw-tag name="BadEnd" color="red"></tw-tag>,<tw-tag name="Bad-End" color="red"></tw-tag>,<tw-tag name="combat" color="gray"></tw-tag>,<tw-tag name="complete" color="blue"></tw-tag>,<tw-tag name="VICTORY!" color="gray"></tw-tag>,<tw-tag name="victory" color="green"></tw-tag><tw-passagedata pid="1" name="StoryInit" tags="" position="100,100" size="100,100">/* STAT BAR CONTROLS */
&lt;&lt;set $mhp to 10&gt;&gt;
&lt;&lt;set $hp to $mhp&gt;&gt;
&lt;&lt;set $damage to 0&gt;&gt;
&lt;&lt;set $mwill to 10&gt;&gt;
&lt;&lt;set $will to 10&gt;&gt;
&lt;&lt;set $arousal to 0&gt;&gt;

/* ITEMS */
&lt;&lt;ItemInit&gt;&gt;
&lt;&lt;set $inventoryLock to false&gt;&gt;

/* STAT CHECKING VARIABLES */
&lt;&lt;set $base_str to 5&gt;&gt;
&lt;&lt;set $str to $base_str&gt;&gt;
&lt;&lt;set $base_dex to 5&gt;&gt;
&lt;&lt;set $dex to $base_dex&gt;&gt;
&lt;&lt;set $base_int to 5&gt;&gt;
&lt;&lt;set $int to $base_int&gt;&gt;
&lt;&lt;set $base_res to 5&gt;&gt;
&lt;&lt;set $res to $base_res&gt;&gt;
&lt;&lt;set $totalPoints to 5&gt;&gt;
&lt;&lt;set $checkAgainst to 5&gt;&gt;
&lt;&lt;set $checkStat to &quot;str&quot;&gt;&gt;

/* NAME CONTROL */
&lt;&lt;set $name to &quot;Hero&quot;&gt;&gt;
&lt;&lt;set $SilviannaName to false&gt;&gt;

/* STORY VARIABLES */
&lt;&lt;set $ElfMaidenBattleClear to false&gt;&gt;
&lt;&lt;set $ElfMaidenVictory to &quot;none&quot;&gt;&gt;

/* NPC VARIABLES */
&lt;&lt;set $ElfMood to 0&gt;&gt;
&lt;&lt;set $ElfAffection to 0&gt;&gt;

/* EQUIPMENT VARIABLES */
&lt;&lt;set $weapon to true&gt;&gt;
&lt;&lt;set $pack to true&gt;&gt;
&lt;&lt;set $armour to false&gt;&gt;
&lt;&lt;set $shield to false&gt;&gt;
&lt;&lt;set $shirt to true&gt;&gt;
&lt;&lt;set $pants to true&gt;&gt;
&lt;&lt;set $naked to false&gt;&gt;

/* PLACE AND TIME VARIABLES */
&lt;&lt;set $location to &quot;Forest&quot;&gt;&gt;

/* BATTLE EVENTS */
&lt;&lt;set $BattleEvent to &quot;none&quot;&gt;&gt;
&lt;&lt;set $MonsterStatus to &quot;none&quot;&gt;&gt;
&lt;&lt;set $charmed to false&gt;&gt;
&lt;&lt;set $tempted to false&gt;&gt;
&lt;&lt;set $bound to false&gt;&gt;
&lt;&lt;set $vinebound to false&gt;&gt;
&lt;&lt;set $embrace to false&gt;&gt;
&lt;&lt;set $kissing to false&gt;&gt;
&lt;&lt;set $pinned to false&gt;&gt;
&lt;&lt;set $blowjob to false&gt;&gt;
&lt;&lt;set $paizuri to false&gt;&gt;
&lt;&lt;set $footjob to false&gt;&gt;
&lt;&lt;set $handjob to false&gt;&gt;
&lt;&lt;set $cowgirl to false&gt;&gt;
&lt;&lt;set $fucking to false&gt;&gt;
&lt;&lt;set $submission to false&gt;&gt;
&lt;&lt;set $ejaculation to 0&gt;&gt;
&lt;&lt;set $escape to 0&gt;&gt;
&lt;&lt;set $struggle to 0&gt;&gt;

/* FLOW VARIABLES */
&lt;&lt;set $return to &quot;none&quot;&gt;&gt;
&lt;&lt;set $totalejaculation to 0&gt;&gt;
&lt;&lt;set $h_scene to 0&gt;&gt;
&lt;&lt;set $game_over to &quot;none&quot;&gt;&gt;

/* DEMO VARIABLES */
&lt;&lt;if ndef $ClearedDemo&gt;&gt;
    &lt;&lt;set $ClearedDemo to 0&gt;&gt;
&lt;&lt;/if&gt;&gt;
</tw-passagedata><tw-passagedata pid="2" name="Elf Clearing 01" tags="return nobr" position="895,1103.6666666666667" size="100,100">&lt;&lt;if visited() &gt; 1 and hasVisited(&quot;Elf Maiden Talk&quot;)&gt;&gt;
	You return to the clearing where you last saw the moondrop flower.
	And where you met Silvianna. &lt;br&gt; &lt;br&gt;
	
	Sure enough, when you arrive, she&#39;s there once again, lounging
	on the forest floor and playing with the pink flowers dotting
	the clearing. &lt;br&gt; &lt;br&gt;
	
	At your approach, she jumps to her feet, a delighted smile lighting
	up her beautiful face. &lt;br&gt; &lt;br&gt;
	
	&quot;You&#39;re back!&quot; she squeals, calpping her hands together. &quot;I knew
	you&#39;d come back to play with me!&quot; Then, her
	smile fades into a look of hurt. &quot;Why did you run away? We were
	going to have so much fun.&quot; &lt;br&gt; &lt;br&gt;
	
	&quot;S-sorry,&quot; you mumble. Wait, this isn&#39;t the time to be apologizing.
	You have a job to do. &quot;Er, I&#39;m still here for the flower...&quot;
	
	Silvianna&#39;s frown deepens, &quot;You&#39;re not here to play?&quot; &lt;br&gt; &lt;br&gt;
	
	&lt;&lt;set $ElfMood -= 1&gt;&gt;
	
	Shit. If she gets angry there&#39;s not going to be an easy way out
	of this. There&#39;s no way she would let you run away like that time
	either. In that case, the only option is...
	
	[[To fight her off.-&gt;Elf Maiden Fight]]
	&lt;br&gt;
	[[To play with her until she&#39;s satisfied.-&gt;Elf Maiden Play]]
	
&lt;&lt;elseif visited() &gt;1&gt;&gt;
	You return to the clearing where you last saw the moondrop flower.
	And where you last saw the elf maiden residing there. &lt;br&gt; &lt;br&gt;
	
	Sure enough, when you arrive, she&#39;s there once again, lounging
	on the forest floor and playing with the pink flowers dotting
	the clearing. &lt;br&gt; &lt;br&gt;
	
	At your approach, she jumps to her feet, a delighted smile lighting
	up her beautiful face. &lt;br&gt; &lt;br&gt;
	
	&quot;Hey! You&#39;re the human from before,&quot; she exclaims. &quot;You came back
	to play!&quot; &lt;br&gt; &lt;br&gt;
	
	What to do now. You came all this way, so running away now would
	just be pointless.
	The elf maiden is off her guard at the moment, 
	so you could surprise her, but attacking an innocent maiden 
	wouldn&#39;t exactly be heroic. On the other hand,
	you could try to negotiate with her... &lt;br&gt; &lt;br&gt;

	[[Talk with her-&gt;Elf Maiden Talk]] 
	&lt;br&gt;
	[[Charge her while her guard is down!-&gt;Elf Maiden Surprise Attack]]
	
&lt;&lt;else&gt;&gt;
 
	You come to a clearing in the woods. &lt;br&gt; &lt;br&gt;

	Two things quickly catch your eye. 
	The first is a bright flash of blue in the center of the wide
	clearing: the moondrop flower you were tasked to find. &lt;br&gt; &lt;br&gt;

	The second is the beautiful, golden haired maiden
	lying sprawled on her side, idly plucking pink petals
	from one of the many flowers forming the bed of the clearing.
	She is barefoot, and near bare everywhere else as well,
	her only garment being a thin, translucent green dress that
	barely comes down past her hips, leaving most of her long,
	smooth legs completely open to your gaze. Above,
	her dress&#39; plunging neckline reveals a pair of round, creamy
	breasts uncovered just enough to tantalize without truly being
	bared for you. Her silky golden hair is adorned
	by numerous flowers woven through her braids.
	From her pointed ears, you identify her instantly as an elf. 
	&lt;br&gt; &lt;br&gt;
	
	The elf maiden raises her head in curiosity as you come
	to a halt, no doubt alerted to your presence by the crunch
	of your boots on the leaves of the forest floor.
	Catching sight of you, she instantly leaps to her feet,
	a delighted grin lighting up her face. &lt;br&gt; &lt;br&gt;

	&quot;Oh! A human!&quot; she squeals, clapping her hands together
	in delight. &quot;Did you come here to play?&quot; &lt;br&gt; &lt;br&gt;

	You blink in surprise and take a step back, shaking your head. 
	You&#39;ve heard some of the other village boys speak
	of running out into the forest to find elven lovers,
	and while the stories always did sound enticing,
	you have a job to do. &lt;br&gt; &lt;br&gt;

	You hesitate. The elf maiden is off her guard at the moment, 
	so you could surprise her, but attacking an innocent maiden 
	wouldn&#39;t exactly be heroic. On the other hand,
	you could try to negotiate with her... &lt;br&gt; &lt;br&gt;

	[[Talk with her.-&gt;Elf Maiden Talk]] 
	&lt;br&gt;
	[[Charge her while her guard is down!-&gt;Elf Maiden Surprise Attack]]
	&lt;br&gt;
	[[Run away!-&gt;Elf Maiden Run]]

&lt;&lt;/if&gt;&gt;
</tw-passagedata><tw-passagedata pid="3" name="StoryCaption" tags="" position="357,101" size="100,100">@@.left;

&lt;&lt;statusbar &quot;health-bar&quot; &quot;$mhp&quot; &quot;$hp&quot; &quot;$damage&quot;&gt;&gt; Health: $hp 
&lt;&lt;statusbar &quot;energy-bar&quot; &quot;$mwill&quot; &quot;$will&quot; &quot;$arousal&quot;&gt;&gt; Willpower: $will 

@@

&lt;br&gt;

&lt;&lt;Inventory_Button&gt;&gt; &lt;&lt;Status_Screen_Button&gt;&gt;</tw-passagedata><tw-passagedata pid="4" name="PassageHeader" tags="" position="487,100" size="100,100">&lt;&lt;silently&gt;&gt;

	&lt;&lt;if tags().includes(&quot;return&quot;)&gt;&gt; 
		&lt;&lt;set $return to passage()&gt;&gt; 
	&lt;&lt;/if&gt;&gt;
	
	&lt;&lt;if $naked&gt;&gt; 
		&lt;&lt;set $shirt to false&gt;&gt; &lt;&lt;set $pants to false&gt;&gt; 
	&lt;&lt;/if&gt;&gt;

	&lt;&lt;if not $shirt and not $pants&gt;&gt;
		&lt;&lt;set $naked to true&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	
	&lt;&lt;if tags().includes(&quot;combat&quot;)&gt;&gt;
		&lt;&lt;Combat&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	
	&lt;&lt;if tags().includes(&quot;inventory-lock&quot;)&gt;&gt;
		&lt;&lt;Inventory_Lock&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	
	&lt;&lt;overflow&gt;&gt;
	&lt;&lt;stat_overflow&gt;&gt;
	
	&lt;&lt;Stats&gt;&gt;
	
	&lt;&lt;set _mod to 0&gt;&gt;
		
&lt;&lt;/silently&gt;&gt;</tw-passagedata><tw-passagedata pid="5" name="StorySubtitle" tags="" position="618,102" size="100,100">~ by Orpheus the Traveler</tw-passagedata><tw-passagedata pid="6" name="Inventory" tags="nobr noreturn" position="99,350" size="100,100">You open up your inventory.
&lt;br&gt; &lt;br&gt;

You currently have &lt;&lt;=UInv.DisplayItemList(&quot;inventory&quot;, &quot;plural&quot;, &quot;nothing&quot;, &quot;,&quot;, &quot;and&quot;, &quot;singular&quot;)&gt;&gt;.

&lt;br&gt; &lt;br&gt; &lt;&lt;potion&gt;&gt;

&lt;&lt;Ending_List&gt;&gt;

&lt;br&gt; &lt;br&gt;&lt;&lt;button &#39;Return&#39; &gt;&gt; &lt;&lt;goto $return&gt;&gt; &lt;&lt;/button&gt;&gt;
</tw-passagedata><tw-passagedata pid="7" name="Test Stats" tags="" position="1530,242" size="100,100">&lt;&lt;linkreplace &quot;Make a strength check?&quot;&gt;&gt;
	&lt;&lt;Str_Roll&gt;&gt;
	&lt;&lt;if _strRoll&gt;&gt;
		Sooooo strong!
	&lt;&lt;else&gt;&gt;
		Get fucked.
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;\

&lt;&lt;linkreplace &quot;Make a dexterity check?&quot;&gt;&gt;
	&lt;&lt;Dex_Roll&gt;&gt;
	&lt;&lt;if _dexRoll&gt;&gt;
		Ohhh my. Sooo dextrous!
	&lt;&lt;else&gt;&gt;
		Get fucked.
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;\

&lt;&lt;linkreplace &quot;Make an intelligence check?&quot;&gt;&gt;
    &lt;&lt;Int_Roll&gt;&gt;
	&lt;&lt;if _intRoll&gt;&gt;
		r/iamverysmart
	&lt;&lt;else&gt;&gt;
		Get fucked.
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;\

&lt;&lt;linkreplace &quot;Make a resistance check?&quot;&gt;&gt;
   &lt;&lt;Res_Roll&gt;&gt;
   &lt;&lt;if _resRoll&gt;&gt;
		RESISTANCE!
	&lt;&lt;else&gt;&gt;
		Get fucked.
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;</tw-passagedata><tw-passagedata pid="8" name="Stat Widgets" tags="nobr widget" position="231,226" size="100,100">&lt;&lt;widget &quot;Stat_Check&quot;&gt;&gt;
	&lt;&lt;silently&gt;&gt;
		&lt;&lt;if $checkStat is &quot;str&quot;&gt;&gt;
			&lt;&lt;set _result to ($str + _mod)&gt;&gt;
		&lt;&lt;elseif $checkStat is &quot;dex&quot;&gt;&gt;
			&lt;&lt;set _result to ($dex + _mod)&gt;&gt;
		&lt;&lt;elseif $checkStat is &quot;int&quot;&gt;&gt;
			&lt;&lt;set _result to ($int + _mod)&gt;&gt;
		&lt;&lt;elseif $checkStat is &quot;res&quot;&gt;&gt;
			&lt;&lt;set _result to ($res + _mod)&gt;&gt;
		&lt;&lt;else&gt;&gt;
			ERROR! NO VALID STAT SELECTED!
		&lt;&lt;/if&gt;&gt;
			
		&lt;&lt;if _result &gt;= $checkAgainst&gt;&gt;
			Check PASSED!
			&lt;&lt;set _checkPass to true&gt;&gt;
		&lt;&lt;else&gt;&gt;
			Check FAILED!
			&lt;&lt;set _checkPass to false&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/silently&gt;&gt;	
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;Stat_Roll&quot;&gt;&gt;
	&lt;&lt;if $checkStat is &quot;str&quot;&gt;&gt;
		&lt;&lt;set _result to (((random(1,6)+random(1,6))/2)-3) + $str + _mod&gt;&gt;
	&lt;&lt;elseif $checkStat is &quot;dex&quot;&gt;&gt; 
		&lt;&lt;set _result to (((random(1,6)+random(1,6))/2)-3) + $dex + _mod&gt;&gt;
	&lt;&lt;elseif $checkStat is &quot;int&quot;&gt;&gt;
		&lt;&lt;set _result to (((random(1,6)+random(1,6))/2)-3) + $int + _mod&gt;&gt;
	&lt;&lt;elseif $checkStat is &quot;res&quot;&gt;&gt;
		&lt;&lt;set _result to (((random(1,6)+random(1,6))/2)-3) + $res + _mod&gt;&gt;
	&lt;&lt;else&gt;&gt;
		ERROR! NO VALID STAT SELECTED!
	&lt;&lt;/if&gt;&gt;
	
	&lt;&lt;if _result &gt;= $check&gt;&gt;
		Roll PASSED!
		&lt;&lt;set $check to true&gt;&gt;
	&lt;&lt;else&gt;&gt;
		Roll FAILED!
		&lt;&lt;set $check to false&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;

</tw-passagedata><tw-passagedata pid="9" name="Item Widgets" tags="widget nobr" position="359,348" size="100,100">&lt;&lt;widget &quot;potion&quot;&gt;&gt;
	&lt;&lt;if UInv.BagHasItem(&quot;inventory&quot;, &quot;potion&quot;)&gt;&gt;
		&lt;&lt;linkreplace &quot;Potion&quot;&gt;&gt;
			&lt;&lt;set $UseItem to &quot;potion&quot;&gt;&gt;
			&lt;&lt;goto &quot;Item Use&quot;&gt;&gt;
		&lt;&lt;/linkreplace&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;usepotion&quot;&gt;&gt;
	&lt;&lt;set UInv.DeleteItem(&quot;inventory&quot;, &quot;potion&quot;, 1)&gt;&gt;
	You drink the potion! &lt;br&gt; &lt;br&gt;
	&lt;&lt;set $hp += $mhp/2&gt;&gt; &lt;&lt;overflow&gt;&gt;
	You recovered some HP!
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;Ending_List&quot;&gt;&gt;
	&lt;&lt;if $ClearedDemo &gt; 0&gt;&gt;
		&lt;br&gt;
		&lt;&lt;linkreplace &quot;Ending List&quot;&gt;&gt;
			&lt;&lt;goto &quot;Ending List&quot;&gt;&gt;
		&lt;&lt;/linkreplace&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="10" name="Widgets" tags="widget nobr" position="98,233" size="100,100">&lt;&lt;widget &quot;Stats&quot;&gt;&gt;
		
		&lt;&lt;set $str = $base_str&gt;&gt;
			
		&lt;&lt;set $dex = $base_dex&gt;&gt;
	
		&lt;&lt;set $int = $base_int&gt;&gt;

	&lt;&lt;if $charmed&gt;&gt;
		&lt;&lt;set $res = ($base_res - 2)&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set $res = $base_res&gt;&gt;
	&lt;&lt;/if&gt;&gt;

&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;Inventory_Button&quot;&gt;&gt;

	&lt;&lt;button &#39;Inventory&#39;&gt;&gt;
		&lt;&lt;if _inventoryLock&gt;&gt;
			&lt;&lt;dialog&gt;&gt;
				You can&#39;t access the inventory right now!
			&lt;&lt;/dialog&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;goto &quot;Inventory&quot;&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/button&gt;&gt;

&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;Status_Screen_Button&quot;&gt;&gt;
	&lt;&lt;button &#39;Status&#39;&gt;&gt;
		&lt;&lt;dialog&gt;&gt;
			&lt;&lt;StatusScreen&gt;&gt;
		&lt;&lt;/dialog&gt;&gt;
	&lt;&lt;/button&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;typewriter&quot;&gt;&gt;

	&lt;span id=&quot;typewriter&quot;&gt;&lt;/span&gt;
	&lt;&lt;set _textArrayLength to 0&gt;&gt;
	&lt;&lt;repeat 0.3s&gt;&gt;
		&lt;&lt;if _textArrayLength &gt;= $args[0].length&gt;&gt;
			&lt;&lt;stop&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;append &quot;#typewriter&quot;&gt;&gt;
				$args[0][_textArrayLength]
			&lt;&lt;/append&gt;&gt;
			&lt;&lt;set _textArrayLength++&gt;&gt;
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/repeat&gt;&gt;

&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;overflow&quot;&gt;&gt;
	&lt;&lt;if $hp &lt; 0&gt;&gt; &lt;&lt;set $hp to 0&gt;&gt; &lt;&lt;/if&gt;&gt;
	&lt;&lt;if $hp &gt; $mhp&gt;&gt; &lt;&lt;set $hp to $mhp&gt;&gt; &lt;&lt;/if&gt;&gt;
	&lt;&lt;if $will &lt; 0&gt;&gt; &lt;&lt;set $will to 0&gt;&gt; &lt;&lt;/if&gt;&gt;
	&lt;&lt;if $will &gt; $mwill&gt;&gt; &lt;&lt;wet $will to $mwill&gt;&gt; &lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;stat_overflow&quot;&gt;&gt;
	&lt;&lt;if $str &lt; 3&gt;&gt; &lt;&lt;set $str to 3&gt;&gt; &lt;&lt;/if&gt;&gt;
	&lt;&lt;if $str &gt; 10&gt;&gt; &lt;&lt;set $str to 10&gt;&gt; &lt;&lt;/if&gt;&gt;
	&lt;&lt;if $dex &lt; 3&gt;&gt; &lt;&lt;set $dex to 3&gt;&gt; &lt;&lt;/if&gt;&gt;
	&lt;&lt;if $dex &gt; 10&gt;&gt; &lt;&lt;set $dex to 10&gt;&gt; &lt;&lt;/if&gt;&gt;
	&lt;&lt;if $int &lt; 3&gt;&gt; &lt;&lt;set $int to 3&gt;&gt; &lt;&lt;/if&gt;&gt;
	&lt;&lt;if $int &gt; 10&gt;&gt; &lt;&lt;set $int to 10&gt;&gt; &lt;&lt;/if&gt;&gt;
	&lt;&lt;if $res &lt; 3&gt;&gt; &lt;&lt;set $res to 3&gt;&gt; &lt;&lt;/if&gt;&gt;
	&lt;&lt;if $res &gt; 10&gt;&gt; &lt;&lt;set $res to 10&gt;&gt; &lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;Combat&quot;&gt;&gt;
	&lt;&lt;set _inventoryLock to true&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;Inventory_Lock&quot;&gt;&gt;
	&lt;&lt;set _inventoryLock to true&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;ejaculate&quot;&gt;&gt;
	&lt;&lt;set $ejaculation +=1&gt;&gt;
	&lt;&lt;set $totalejaculation +=1&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;Status_Reset&quot;&gt;&gt;
	&lt;&lt;set $BattleEvent to &quot;none&quot;&gt;&gt;
	&lt;&lt;set $MonsterStatus to &quot;none&quot;&gt;&gt;
	&lt;&lt;set $charmed to false&gt;&gt;
	&lt;&lt;set $tempted to false&gt;&gt;
	&lt;&lt;set $bound to false&gt;&gt;
	&lt;&lt;set $vinebound to false&gt;&gt;
	&lt;&lt;set $embrace to false&gt;&gt;
	&lt;&lt;set $kissing to false&gt;&gt;
	&lt;&lt;set $pinned to false&gt;&gt;
	&lt;&lt;set $blowjob to false&gt;&gt;
	&lt;&lt;set $paizuri to false&gt;&gt;
	&lt;&lt;set $footjob to false&gt;&gt;
	&lt;&lt;set $handjob to false&gt;&gt;
	&lt;&lt;set $cowgirl to false&gt;&gt;
	&lt;&lt;set $fucking to false&gt;&gt;
	&lt;&lt;set $submission to false&gt;&gt;
	&lt;&lt;set $ejaculation to 0&gt;&gt;
	&lt;&lt;set $escape to 0&gt;&gt;
	&lt;&lt;set $struggle to 0&gt;&gt;
	&lt;&lt;set $inventoryLock to false&gt;&gt;
	
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="11" name="Elf Maiden Talk" tags="combat complete" position="907,1420" size="100,100">&quot;Er...hello,&quot; you greet the elf maiden, hoping that she will be willing to listen to reason. &quot;My name is $name.&quot;

&quot;I&#39;m Silvianna!&quot; she says, bounding closer to you.\

&lt;&lt;set $SilviannaName to true&gt;&gt;\
&lt;&lt;set $ElfMood += 1&gt;&gt;\

Even though she seems harmeless enough, something about the glint in her bright, emerald green eyes makes you nervous. You take another step back.

Either oblivious or uncaring to your wariness, Silvianna steps closer, hands behind her back and leaning forward in a flirtatious manner than can&#39;t help but draw attention to her barely concealed breasts. 

She giggles as you jerk your eyes back from her chest to her face, obviously noting what you were looking at, &quot;I&#39;m glad you came to play, $name. It&#39;s been sooo long since any of the other girls from the village let me play with their humans!&quot;

Their humans? This is sounding more and more dangerous. You need to get this conversation back on track, &quot;I-I didn&#39;t come here for that!&quot;

Silvianna stops looking puzzled, &quot;Huh? You didn&#39;t come to play?&quot;

&quot;Er, no,&quot; you reply. &quot;I&#39;m...I&#39;m an adventurer. I was sent here to find a Moondrop flower.&quot; You gesture to the bright blue flower resting near the center of the glade.

&quot;Oh,&quot; the elf maiden frowns, clearly put off that she apparently isn&#39;t going to get to &#39;play&#39; with you. Then her eyes light up and she claps her hands together, &quot;Ooh! I know! I&#39;ll let you have the flower if you play with me for a bit!&quot;

&quot;You...you will?&quot; the offer doesn&#39;t seem to unreasonable, but you are concerned at what form this &#39;playing&#39; might take...

Silvianna nods her head excitedly, biting her lip and looking at with a sultry grin, &quot;That&#39;s right, just play with me for a bit and you&#39;ll get the silly little flower you came here for.&quot; Her pink tongue targets out to wet her lips slightly, leaving them glistening, &quot;I promise it will be really, //really// fun...&quot;

You gulp and try to make a decision. Despite your nervousness, you don&#39;t really see many other options...

[[Play with her.-&gt;Elf Maiden Play]]
[[Find some other way.-&gt;Elf Maiden Refuse Play]]
[[Take the flower by force!-&gt;Elf Maiden Surprise Attack 2]]
[[Run away.-&gt;Elf Maiden Run]]</tw-passagedata><tw-passagedata pid="12" name="Elf Maiden Surprise Attack" tags="combat complete" position="1058,1356" size="100,100">With a sudden roar, you raise your staff and charge at the elf maiden. She jumps back with a shriek of surprise.\ 

&lt;&lt;set $MonsterStatus to &quot;scared&quot;&gt;&gt;\

Good! She&#39;s out of your way now. You have a direct line to the flower you&#39;re
seeking. However, if you just take the flower, she may try to stop you...

[[Ignore the elf maiden and grab the flower-&gt;Elf Maiden Flower Grab]]
[[Attack the elf maiden-&gt;Elf Maiden Surprise Attack 2]]</tw-passagedata><tw-passagedata pid="13" name="Elf Maiden Flower Grab" tags="combat nobr complete" position="1086,1581" size="100,100">&lt;&lt;if $MonsterStatus is &quot;scared&quot;&gt;&gt;
	Taking advantage of her surprise, you quickly dash
	to the center of the
	clearing and snatch the flower you came for!
	
	&lt;&lt;set UInv.AddItem(&quot;inventory&quot;,&quot;Moondrop Flower&quot;)&gt;&gt;
	&lt;&lt;set $MonsterStatus to &quot;none&quot;&gt;&gt;
	&lt;br&gt; &lt;br&gt;
	
	You quickly turn and make a break for it, dashing off back into the
	woods... &lt;br&gt; &lt;br&gt;
	
	&lt;&lt;linkreplace &quot;Continue&quot;&gt;&gt;
		Only to feel a sudden slamming impact against your back and
		a pair of smooth arms wrap around your chest! &lt;br&gt; &lt;br&gt;
		
		&quot;Where do you think you&#39;re going?&quot; the elf maiden whispers 
		into your ear. &lt;br&gt; &lt;br&gt;
		
		You&#39;re so surprised that for a moment you can&#39;t respond.
		&lt;br&gt; &lt;br&gt;
		
		&quot;It&#39;s not nice to scare girls like that,&quot; she chides. &quot;You&#39;re
		a bad, bad boy. And around here, bad boys get //punished//.&quot;
		&lt;br&gt; &lt;br&gt;
		
		Oh shit. This is bad. You&#39;ve got to escape quickly. &lt;br&gt; &lt;br&gt;
		
		As if sensing your intent, the elf maiden&#39;s arms squeeze
		a little tighter around you, and she leans in until her lips
		are just brushing against your ear as she speaks, &quot;Buuuut,
		if you&#39;re a good boy, I might let you off easy.&quot; She giggles 
		and presses a soft kiss to your ear. &quot;I&#39;m Silvianna. Let&#39;s
		play awhile~.&quot; &lt;br&gt; &lt;br&gt;
		
		&lt;&lt;set $SilviannaName to true&gt;&gt;
		[[Continue-&gt;Elf Maiden Embrace]]
	&lt;&lt;/linkreplace&gt;&gt;
	
&lt;&lt;elseif $MonsterStatus is &quot;stunned&quot;&gt;&gt;
	Leaving the elf maiden lying injured on the ground, you dash over
	to the center of the clearing and pluck one of the Moondrop Flower
	blossoms from the ground. 
	
	&lt;&lt;set UInv.AddItem(&quot;inventory&quot;,&quot;Moondrop Flower&quot;)&gt;&gt;
	&lt;br&gt; &lt;br&gt;
	
	That&#39;s your quest complete, now all you have to do is get out of
	here. &lt;br&gt; &lt;br&gt;
	
	But as you turn to leave, a pained sob gives you pause. The elf
	maiden is still lying where you left her. Another pang of pity 
	shoots through you. If you leave now, you&#39;ll complete the quest
	without more trouble...but maybe it wouldn&#39;t hurt to help her
	first...
	
	[[Leave her be.-&gt;Elf Maiden Violent VICTORY]]
	&lt;br&gt;
	[[Help her.-&gt;Elf Maiden Merciful VICTORY]]

&lt;&lt;elseif $MonsterStatus is &quot;tripped&quot;&gt;&gt;
	Taking advantage of her fall, you quickly dash
	to the center of the
	clearing and snatch the flower you came for!
	&lt;br&gt; &lt;br&gt;
	
	&lt;&lt;set UInv.AddItem(&quot;inventory&quot;,&quot;Moondrop Flower&quot;)&gt;&gt;
	&lt;&lt;set $MonsterStatus to &quot;none&quot;&gt;&gt;
	&lt;&lt;set _mod to $escape&gt;&gt;
	&lt;&lt;set $checkStat to &quot;dex&quot;&gt;&gt;
	&lt;&lt;set $checkAgainst to 6&gt;&gt;
	
	You quickly turn and make a break for it, dashing off back into the
	woods... &lt;br&gt; &lt;br&gt;
	
	&lt;&lt;linkreplace &quot;Continue&quot;&gt;&gt;
		&lt;&lt;Check_Stat&gt;&gt;
		
		&lt;&lt;if _checkPass&gt;&gt;
			As you dash away, you hear Silvianna scrambling to her
			feet. You push yourself harder, running as fast as you&#39;ve
			ever run before, urgency lending you speed in your flight.
			&lt;br&gt; &lt;br&gt;
			
			&quot;Hey! Wait!&quot; Silvianna calls after you. &quot;Come back!&quot;
			&lt;br&gt; &lt;br&gt;
			
			You ignore her voice and rush on through the woods. 
			Eventually her voice fades 
			into the distance, and you finally slow down, panting
			heavily, both in exertion and relief.
			It was close, but you managed to get away!
			&lt;br&gt; &lt;br&gt;
			
			A sense of pride runs through you as you make your way
			back to the village. You managed to leave with the
			[[flower in hand-&gt;Elf Maiden Neutral VICTORY]]! 
			
		&lt;&lt;else&gt;&gt;
			Only to feel a sudden slamming impact against your back and
			a pair of smooth arms wrap around your chest! &lt;br&gt; &lt;br&gt;
		
			&quot;Where do you think you&#39;re going?&quot; the elf maiden whispers 
			into your ear. &lt;br&gt; &lt;br&gt;
		
			You&#39;re so surprised that for a moment you can&#39;t respond.
			&lt;br&gt; &lt;br&gt;
		
			&quot;It&#39;s not nice to make girls trip like that,&quot; she chides.
			&quot;You&#39;re
			a bad, bad boy. And around here, bad boys get
			//punished//.&quot;
			&lt;br&gt; &lt;br&gt;
		
			Oh shit. This is bad. You&#39;ve got to escape quickly.
			&lt;br&gt; &lt;br&gt;
		
			As if sensing your intent, the elf maiden&#39;s arms squeeze
			a little tighter around you,
			and she leans in until her lips	
			are just brushing against your ear as she speaks, &quot;Buuuut,
			if you&#39;re a good boy, I might let you off easy.&quot;
			She giggles 
			and presses a soft kiss to your ear. 
			&lt;&lt;if $SilviannaName is false&gt;&gt;
				&quot;I&#39;m Silvianna. Let&#39;s play awhile~.&quot;
				&lt;&lt;set $SilviannaName to true&gt;&gt;
			&lt;&lt;/if&gt;&gt;
			&lt;br&gt; &lt;br&gt;
			
			&lt;&lt;set $embrace to true&gt;&gt;
			
			[[Continue-&gt;Elf Maiden Embrace]]
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/linkreplace&gt;&gt;
	
&lt;&lt;elseif $MonsterStatus is &quot;anger&quot;&gt;&gt;	
	You can practically feel the anger radiating off her. This is bad.
	You need to grab the flower and get the hell out of here ASAP. 
	&lt;br&gt; &lt;br&gt;
	
	With that in mind, you pour everything you have into a mad dash 
	towards your prize!
	
	&lt;&lt;linkreplace &quot;Continue&quot;&gt;&gt;
		But you don&#39;t even make it halfway across the clearing before
		Silvianna slams into you, sending you crashing to the ground!
		&lt;br&gt; &lt;br&gt;
		
		You hit the ground hard, dazing you enough that you can&#39;t
		react before Silvianna walks over to your prone form and plants
		her heel in your crotch.
		&lt;br&gt; &lt;br&gt;
		
		&lt;&lt;set $MonsterStatus to &quot;none&quot;&gt;&gt;
		&lt;&lt;set $damage += 2&gt;&gt;
		
		You cry out in pain and squirm beneath her, only stopping when
		she digs in harder and give you a cruel smile.
		&lt;br&gt; &lt;br&gt;
		
		&quot;Now then, what should I do with you?&quot; she asks with a 
		fiendish giggle.
		&lt;br&gt; &lt;br&gt;
		
		Your heart races in fear. You&#39;re completely helpless
		[[under her heel-&gt;Elf Maiden Cruel Punishment]].
		
	&lt;&lt;/linkreplace&gt;&gt;
	
&lt;&lt;else&gt;&gt;
	You know it&#39;s risky to try to go for the flower
	when she&#39;s still in the 
	way, but it&#39;s a chance you&#39;ll have to take. 
	&lt;br&gt; &lt;br&gt;
	
	You take a deep breath and dash
	towards the center of the
	clearing...
	&lt;br&gt; &lt;br&gt;
	
	&lt;&lt;set _mod to $escape&gt;&gt;
	&lt;&lt;set $checkStat to &quot;dex&quot;&gt;&gt;
	&lt;&lt;set $checkAgainst to 5&gt;&gt;
	
	&lt;&lt;linkreplace &quot;Continue&quot;&gt;&gt;
		&lt;&lt;Stat_Check&gt;&gt;
		
		&lt;&lt;if _checkPass&gt;&gt;
			And manage to grab the Moondrop Flower! You quickly shove
			the flower in your pounch and turn to run away.
			&lt;br&gt; &lt;br&gt;
			
			&lt;&lt;set UInv.AddItem(&quot;inventory&quot;,&quot;Moondrop Flower&quot;)&gt;&gt;
			
			But just as you start to run, you feel a sudden
			slamming impact against your back and
			a pair of smooth arms wrap around your chest! &lt;br&gt; &lt;br&gt;
		
			&quot;Where do you think you&#39;re going?&quot; the elf maiden whispers 
			into your ear. &lt;br&gt; &lt;br&gt;
		
			Oh crap. You were so occupied with getting away that you
			left yourself open to her attack.
			&lt;br&gt; &lt;br&gt;
			
			Silvianna giggles and presses a soft kiss against your
			neck, &quot;Don&#39;t leave yet, darling. We can still have so
			much fun together...&quot;
			&lt;br&gt; &lt;br&gt;
			
			You got the flower, but now you&#39;re caught fast in
			[[Silvianna&#39;s embrace-&gt;Elf Maiden Embrace]]
			...
			
		&lt;&lt;else&gt;&gt;
			But just before you reach the flower, you stumble. It
			only slows you down for a second, but that instant is
			all it takes.
			&lt;br&gt;
			
			Before you can recover, you feel a sudden slamming impact
			against your back and a pair of smooth arms wrap around
			your chest.
			&lt;br&gt; &lt;br&gt;
			
			&quot;Where do you think you&#39;re going?&quot; the elf maiden whispers 
			into your ear. &lt;br&gt; &lt;br&gt;
		
			Oh crap. You left yourself completely open to attack.
			&lt;br&gt; &lt;br&gt;
			
			Silvianna giggles and presses a soft kiss against your
			neck, &quot;Don&#39;t leave yet, darling. We can still have so
			much fun together...&quot;
			&lt;br&gt; &lt;br&gt;
			
			You failed to get the flower, and 
			now you&#39;re caught fast in
			[[Silvianna&#39;s embrace-&gt;Elf Maiden Embrace]]
			...
			
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/linkreplace&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="14" name="Elf Maiden Surprise Attack 2" tags="combat complete nobr" position="1208,1431" size="100,100">You feel a twinge of regret that it had to come to this, but you&#39;re left with left choice. With a violent roar, you attack, swinging your staff at the elf maiden&#39;s unprotected head. &lt;br&gt; &lt;br&gt;

&lt;&lt;set $checkStat to &quot;str&quot;&gt;&gt;
&lt;&lt;set $checkAgainst to 6&gt;&gt;

&lt;&lt;if _checkPass&gt;&gt;
	&lt;&lt;set $MonsterStatus to &quot;stunned&quot;&gt;&gt;
	
	At the last second, she raises her arms to block your swing,
	but your blow is too strong. Your staff smashes into her,
	sending her falling to the ground with a cry of pain. &lt;br&gt; &lt;br&gt;
	
	She lays on the forest floor, clutching her head and sobbing
	pitifully. A twinge of pity shoots through you, but you
	push it aside. You did what had to be done. Now, you have a
	chance to get the flower you sought. &lt;br&gt; &lt;br&gt;
	
	Although...she is defenseless now...and she was so eager to
	play with you earlier... &lt;br&gt; &lt;br&gt;
	
	[[Take the flower and run!-&gt;Elf Maiden Flower Grab]]  
	&lt;br&gt;
	[[Take advantage of her.-&gt;ELf Maiden Rape Attempt]]
	
&lt;&lt;else&gt;&gt;
	To your shock, however, just before your oaken staff 
	connects with her head, she snatches it with
	lightning swift reflexes.
	&lt;br&gt; &lt;br&gt;

	For a split second, the shock on her face matches your own.
	Then, her emerald eyes narrow with contempt. &lt;br&gt; &lt;br&gt;

	&quot;Oh, so you&#39;re one of //those// humans?&quot; she sneers. 
	&quot;The kind who come looking for the wrong kind of trouble.&quot;
	&lt;br&gt; &lt;br&gt;

	&quot;Er...that&#39;s not-&quot; you start to say, but you&#39;re interrupted
	when she jerks the staff out of your hand with 
	shocking strength and slams a knee
	violently into your stomach. &lt;br&gt; &lt;br&gt;

	&lt;&lt;set $damage +=2&gt;&gt;\

	You fall to the ground, clutching your stomach and coughing
	painfully. She kicks you over and plants a foot on your chest,
	a cruel smile forming on her lips. &quot;You know, we //could//
	have had fun ogether if that&#39;s what you wanted.
	But, if you really want to play rough,
	I&#39;m more than happy to oblige.&quot; 
	&lt;br&gt; &lt;br&gt;

	You gulp as she stares down at you with eyes
	completely devoid of mercy. &lt;br&gt; &lt;br&gt;

	With a wicked gleam in her bright green eyes,
	the elf maiden slowly moves her foot from your chest
	to your groin.
	&lt;&lt;if not $SilviannaName&gt;&gt;
		&quot;My name is Silvianna. Moan it as I&#39;m punishing you.&quot;
	&lt;&lt;/if&gt;&gt; 
	&lt;br&gt; &lt;br&gt;

	[[Continue-&gt;Elf Maiden Cruel Punishment]]

&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="15" name="Elf Maiden Cruel Punishment" tags="combat nobr complete" position="1375,1441" size="100,100">You let out a sharp cry as Silvianna digs her heel into your crotch, giving you a rough, merciless footjob through your pants.

&lt;&lt;set $damage += 2&gt;&gt; &lt;&lt;set $arousal += 2&gt;&gt;
&lt;br&gt; &lt;br&gt;

At last, she eases up on the pressure, leaving your scream to die down to a whimper. To your horror, besides your pain you can feel an erection forming underneath her foot.

&lt;br&gt; &lt;br&gt;

The elf maiden&#39;s cruel laugh rings out in the clearing, &quot;Oh my gods! Did you actual get hard from that? I knew my feet were amazing, but I didn&#39;t think even human trash would actually like me stepping on their dicks!&quot;

&lt;br&gt; &lt;br&gt;

Your head spinning and tears filling your eyes from both the pain and humilation, a glimmer of consciousness whispers that now may be your only chance to escape...

&lt;br&gt; &lt;br&gt;

&lt;span id=&#39;choice&#39;&gt;

&lt;&lt;link &quot;Push her off of you!&quot;&gt;&gt;
	&lt;&lt;replace #choice&gt;&gt;
		&lt;&lt;set $checkStat to &quot;str&quot;&gt;&gt;
		&lt;&lt;set $checkAgainst to 6&gt;&gt;
		
		It&#39;s hard to gain any sort of leverage in a position like
		this, but
		you have to fight back with everything you&#39;ve got!
	
		&lt;br&gt; &lt;br&gt;
	
		With a sudden burst of strength, you seize Silvianna&#39;s leg
		and
		try to [[push her-&gt;Elf Maiden Footjob Struggle]] off of you!
	&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;

&lt;br&gt;

&lt;&lt;link &quot;Try to slip out from under her.&quot;&gt;&gt;
	&lt;&lt;replace #choice&gt;&gt;
		&lt;&lt;set $checkStat to &quot;dex&quot;&gt;&gt;
		&lt;&lt;set $checkAgainst to 5&gt;&gt;
		With the way she&#39;s standing, you might be able to unbalance her
		with some quick movements...
		&lt;br&gt; &lt;br&gt;
		You quickly push your hips up into her! It&#39;s only for a second,
		but you see her balance shift. Now&#39;s your chance!
		&lt;br&gt; &lt;br&gt;
		You try to
		[[squirm out from underneath her-&gt;Elf Maiden Footjob Struggle]]
		while you have the chance.
	&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;

&lt;br&gt;

&lt;&lt;link &quot;Lay back and take it&quot;&gt;&gt;
	&lt;&lt;replace #choice&gt;&gt;
		There&#39;s no point in resisting. It would be better
		just to submit
		to her...
		
		With those despairing thoughts filling your head, you lie
		motionless on the forest floor beneath your tormentor,
		[[submitting-&gt;Elf Maiden Footjob Submit]] to her completely.
	&lt;&lt;/replace&gt;&gt;
&lt;&lt;/link&gt;&gt;

&lt;/span&gt;</tw-passagedata><tw-passagedata pid="16" name="Elf Maiden Footjob Struggle" tags="combat nobr complete" position="1303,1668" size="100,100">&lt;&lt;if $checkStat is &quot;str&quot;&gt;&gt;
	You push with all your might...
	
	&lt;&lt;Stat_Check&gt;&gt;
	&lt;br&gt; &lt;br&gt;
	
	&lt;&lt;if _checkPass is true&gt;&gt;
		And manage to push Silvianna off of you!
		&lt;br&gt; &lt;br&gt;
		You quickly scramble to your feet as she cries out in anger.
		&lt;br&gt; &lt;br&gt;
		&quot;Hey! Get back here! I&#39;m not done playing with you yet!&quot; she
		cries.
		&lt;br&gt; &lt;br&gt; 
		You ignore her words and prepare yourself. You have a 
		chance to [[fight-&gt;Elf Maiden Fight]] back!
		
	&lt;&lt;else&gt;&gt;
		But Silvianna simply presses her heel harder into your groin,
		sending a shock of pain through your cock and draining your
		strength away.
		&lt;br&gt; &lt;br&gt;
		Silvianna laughs and presses down harder, making any further
		thought of struggle impossible, &quot;Aw, trying to escape already?
		I&#39;m not gonna let you!&quot;
		&lt;br&gt; &lt;br&gt;
		It&#39;s hopeless. You&#39;re completely stuck. Your last hope
		is to [[beg her to be gentle-&gt;Elf Maiden Footjob Gentle]].
		
	&lt;&lt;/if&gt;&gt;

&lt;&lt;elseif $checkStat is &quot;dex&quot;&gt;&gt;
	You try your best to squirm out from under Silvianna&#39;s heel...
	
	&lt;&lt;Stat_Check&gt;&gt;
	&lt;br&gt; &lt;br&gt;
	
	&lt;&lt;if _checkPass&gt;&gt;
		And manage to get enough leverage to roll out from under her!
		&lt;br&gt; &lt;br&gt;
		Silvianna cries out in disappointment as you roll to your
		feet, &quot;Hey! Get back here! I&#39;m not done playing with you yet!&quot;
		&lt;br&gt; &lt;br&gt;
		You ignore her words and prepare yourself. You have a chance
		to [[fight-&gt;Elf Maiden Fight]] back!
		
	&lt;&lt;else&gt;&gt;
		But you fail to gain any sort of leverage.
		&lt;br&gt;&lt;br&gt;
		Silvianna laughs and presses down harder, stopping your
		movements instantly, &quot;Aw, trying to escape already?
		I&#39;m not gonna let you!&quot;
		&lt;br&gt; &lt;br&gt;
		It&#39;s hopeless. You&#39;re completely stuck. Your last hope
		is to [[beg her to be gentle-&gt;Elf Maiden Footjob Gentle]].
		
	&lt;&lt;/if&gt;&gt;

&lt;&lt;/if&gt;&gt;
</tw-passagedata><tw-passagedata pid="17" name="Elf Maiden Footjob Submit" tags="combat complete" position="1449,1587" size="100,100">Silvianna giggles as she sees you make no moves to resist her, &quot;Not even trying to escape? Don&#39;t tell me you //like// it under my foot? Is that it? Did I catch myself a little masochist?&quot;

Rather than giving you a chance to respond, she instead grinds her foot against your crotch again, this time in a manner clearly meant to cause arousal rather than pain.\

&lt;&lt;set $arousal +=2&gt;&gt;\

&quot;Ah, that&#39;s much better,&quot; she smirks. &quot;Human trash like you deserves to be under the heel of a strong mistress.&quot;

You whimper as she squeezes her toes slightly to rub them against the head of your shaft.

&quot;Now then, since you&#39;re being so nice and submissive for me, I&#39;m going to give you a choice,&quot; the elf maiden says, her eyes glinting mischievously. &quot;Do you want me to treat that pathetic cock of yours gently, or do you want me to give you the punishment you deserve?&quot;

Your heart hammers as you look into her eyes, knowing that no third option is left for you...

[[Treat me gently...-&gt;Elf Maiden Footjob Gentle]]
[[Punish me...-&gt;Elf Maiden Footjob Rough]]</tw-passagedata><tw-passagedata pid="18" name="Elf Maiden Footjob Gentle" tags="combat complete nobr" position="1441,1748" size="100,100">&quot;P-please,&quot; you whisper. &quot;Be gentle...&quot; &lt;br&gt; &lt;br&gt;

&lt;&lt;if $ElfMood &lt; 0&gt;&gt;
	She cocks her head to the side as if considering, then smiles
	wickedly, &quot;Nope!&quot; &lt;br&gt; &lt;br&gt;
	
	Lifting her foot up, she stamps down hard, right on your raging, 
	pulsing erection. You scream, hands balling into impotent fists
	as she begins to grind her heel deeply against your cock,
	hard enough that it feels like she might bruise you. &lt;br&gt; &lt;br&gt;

	&lt;&lt;set $damage += 5&gt;&gt;
	&lt;&lt;set $arousal += 1&gt;&gt;
	
	And yet, despite your pain, you can&#39;t help but feel aroused,
	so much that even as you scream and writhe beneath her,
	you&#39;re also thrusting up, your cock desperate
	for every touch of her foot against it. &lt;br&gt; &lt;br&gt;

	&quot;You&#39;re actually twitching!&quot; she squeals in sadistic delight.
	&quot;I can feel your worthless, disgusting cock throb
	even while I&#39;m punishing it!&quot; &lt;br&gt; &lt;br&gt;

	You&#39;re too far gone to give a coherent reply.
	You can only continue to scream,
	not even sure yourself if what you want is for her to stop or 
	to [[finish you off-&gt;Elf Maiden Footjob Rough Finish]]...
	
&lt;&lt;else&gt;&gt;

	Silvianna giggles and flicks her bare toes against
	your aching bulge, &quot;Aw, alright little trash boy,
	since you&#39;re begging so sweetly I&#39;ll be gentle with you.&quot;
	&lt;br&gt; &lt;br&gt;

	With that, she resumes rubbing, her soft sole pressing
	against your length with just enough pressure to arouse
	you without causing pain. Her gentle footjob drains you of 
	strength, leaving you helpless beneath her foot
	as you lie back and submit to her ministrations. 
	&lt;br&gt; &lt;br&gt;
	
	A deep groan of arousal bursts from your chest, 
	and you helplessly begin to thrust your hips up 
	into her soft sole. &lt;br&gt; &lt;br&gt;

	&lt;&lt;set $arousal += 3&gt;&gt;

	&quot;Ah...that&#39;s a good look for you,&quot; Silvianna moans breathlessly,
	her face flushed with arousal. &quot;I always wanted
	my own personal human toy to play with like this...&quot;
	&lt;br&gt; &lt;br&gt;

	Being called her toy ought to frighten you,
	but instead it only arouses you further.
	Her delicate foot is so soft, so gentle 
	that you can&#39;t help but lose yourself in the pleasure
	she&#39;s giving you. Even through your pants,
	her footjob is better than anything you&#39;ve ever felt,
	and it won&#39;t be long until you&#39;re beyond
	the point of holding back...
	&lt;br&gt; &lt;br&gt;

	[[Let her finish you.-&gt;Elf Maiden Footjob Gentle Finish]]
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="19" name="Elf Maiden Footjob Rough" tags="combat complete" position="1571,1693" size="100,100">The words slip slowly from your trembling lips, &quot;P-punish...me.&quot;

Silvianna raises her eyebrows in surprise, &quot;Hm?&quot;

&quot;P-please,&quot; you wet your dry lips with your tongue and whimper out to her, &quot;please...punish me.&quot;

She bites her lip and digs in her heel, shooting a sharp shock of pain through you and forcing a pained whimper from your mouth.

&quot;Then beg for it like the trash you are,&quot; she hisses. 

&quot;Please...I&#39;m...I&#39;m trash,&quot; you moan, throwing away the last pitiful tatters of your pride. &quot;I&#39;m pathetic disgusting human garbage. I-I need to be punished by you.&quot;

Your torturer throws back her head, her laughter ringing through the clearing as clear and bright as a ringing bell. Then, lifting her foot up, she stamps down on your raging, pulsing erection. You scream, hands balling into impotent fists as she begins to grind her heel deeply against your cock, hard enough that it feels like she might bruise you.\

&lt;&lt;set $damage += 5&gt;&gt;\
&lt;&lt;set $arousal += 1&gt;&gt;\

And yet, despite your pain, you can&#39;t help but feel aroused, so much that even as you scream and writhe beneath her, you&#39;re also thrusting up, your cock desperate for every touch of her foot against it.

&quot;You&#39;re actually twitching!&quot; she squeals in sadistic delight. &quot;I can feel your worthless, disgusting cock throb even while I&#39;m punishing it!&quot; 

You&#39;re too far gone to give a coherent reply. You can only continue to scream, not even sure yourself if what you want is for her to stop or to [[finish you off-&gt;Elf Maiden Footjob Rough Finish]]...</tw-passagedata><tw-passagedata pid="20" name="Elf Maiden Footjob Gentle Finish" tags="Bad-End complete combat" position="1551,1898" size="100,100">&lt;&lt;set $arousal to $will&gt;&gt;\

\The pleasure is just too much to bear, you offer yourself to completely to her gentle footjob, moaning desperately as you thrust into her foot.

&quot;Oh yes,&quot; she breathes, eyes wide and burning with arousal. &quot;Cum for me, toy! Cum for me!&quot;

At her command, you explode under her foot, your seed gushing out into your pants as she rubs you harder, her rhythm pushing you to release spurt after spurt in admittance of your defeat. Your orgasm streches on far longer than it should, until finally your hips collapse and you rest completely spent on the forest floor.

&quot;Ooh, that looked like a lot,&quot; Silvianna says, licking her lips as she stares at the dark stain on your pants. &quot;Did it feel that good to cum from my foot? Pervert.&quot;

You can&#39;t even begin to respond, too lost in the afterglow to muster up any words.

The elf maiden prods your now flaccid penis with her toes, &quot;Well, don&#39;t worry, you&#39;re going to be feeling that good a lot more often from now on, little pet.&quot;

&quot;...huh?&quot; you manage to raise your head to reply, her words sending a small spark of alarm through you even in such a stupefied state.

Her smile turns cruel as she steps off of you, &quot;You&#39;re going to be my little cum slave from now on, so you can feel like this every. Single. Day.&quot;

Your eyes widen in horror, but there&#39;s not a thing you can do to stop it. You lost to Silvianna, and now you&#39;re \
&lt;&lt;link &quot;her slave forever&quot;&gt;&gt;\  
	&lt;&lt;set $game_over to &quot;Elf Maiden&quot;&gt;&gt;
	&lt;&lt;goto &quot;Game Over&quot;&gt;&gt; 
&lt;&lt;/link&gt;&gt;.

&lt;&lt;remember $FootjobGentleBadEnd to true&gt;&gt;</tw-passagedata><tw-passagedata pid="21" name="Game Over" tags="nobr inventory-lock" position="1222,100" size="100,100">&lt;&lt;if $game_over is &quot;Elf Maiden&quot;&gt;&gt;
	Having succumbed to Silvianna, you are taken back to her home
	and shared as a plaything for the whole village. Kept as her toy,
	you&#39;re raped every day by countless elves, though your true owner
	makes sure visits you the most.
	&lt;br&gt; &lt;br&gt;
	Even if you tried, there&#39;s no way to escape, and soon you&#39;re so 
	broken that you&#39;re not even sure you want to...
	&lt;br&gt; &lt;br&gt;
&lt;&lt;/if&gt;&gt;

&lt;&lt;if $game_over is &quot;Alraune&quot;&gt;&gt;
	Days pass by as you&#39;re kept inside the Alraune&#39;s bloom. She drains
	you ever day, your seed giving rise to new flowers, making her 
	garden stronger with your essence. Perhaps one day you&#39;ll even
	give rise to new Alarune, ones who will prey on travellers just
	like you. That&#39;s of no concern to you now. Nothing is. Your mind
	is empty, lost in the haze of your addiction to her sweet nectar
	and charming pollen.
	&lt;br&gt; &lt;br&gt;
	You&#39;ll live out the rest of your short life
	like this...until at last you&#39;re completely empty of energy
	and your body is absorbed into her as well...
&lt;&lt;/if&gt;&gt;

&lt;&lt;linkreplace &quot;Continue...&quot;&gt;&gt;
	&lt;&lt;typewriter &quot;GAME OVER&quot;&gt;&gt;
	&lt;br&gt; &lt;br&gt;
	&lt;&lt;timed 3s&gt;&gt;
		Load a save or restart using the sidebar to continue.
	&lt;&lt;/timed&gt;&gt;
	&lt;br&gt;
	&lt;&lt;timed 4s&gt;&gt;
		Or [[click here to end your game-&gt;Demo End]].
	&lt;&lt;/timed&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;</tw-passagedata><tw-passagedata pid="22" name="Demo End" tags="inventory-lock" position="1346,99" size="100,100">Congrats. That&#39;s the demo. Hope you enjoyed!
~Orpheus</tw-passagedata><tw-passagedata pid="23" name="Elf Maiden Footjob Rough Finish" tags="Bad-End complete combat" position="1681,1825" size="100,100">&lt;&lt;set $damage to $mhp&gt;&gt;\
&lt;&lt;set $arousal to $mwill&gt;&gt;\

\She pushes you further, grinding her heel even faster against your training erection, abusing you with a torturous union of pain and pleasure that grinds the last of your resistance to dust. 

&quot;Cum for me!&quot; she cries. &quot;Cum for me, you worthless trash! You disgusting piece of garbage! Cum your worthless brains out!&quot;

Your body reacts immediately to her command, so far gone that any disobedience is unthinkable. Your scream fills the air as a torrent of hot cum rushes from your aching, bruised cock, filling up your pants with wasted seed. The pleasure of orgasm joins with the pain as they both shudder through your body to leave you completely exhausted and helplessly.

Your ejaculation drags on, only finishing after the pleasure fades and the last drips of cum are wrung out by her abusive foot. You&#39;re left lying spread eagled on the forest floor, exhaustion resting in a heavy weight on your limbs. 

You whimper as she prods your pitifully abused cock with her foot and laughs, &quot;Is that all you&#39;ve got? Aw, I&#39;m going to have to train you a bit if you&#39;re going to survive long in the village.&quot;

Her words prompt you to raise your head slightly, though you&#39;re still exhausted that a pitiful whimper is all you can manage.

&quot;You heard me right,&quot; she smiles, kneel down over you. &quot;I&#39;m going to take you back to the village so you can be my little fucktoy. Mine and every other elf girl who I want to let play with you. How does that sound?&quot;

&quot;N...no...&quot; you moan. &quot;Please...&quot;

A mocking laugh is all the answer you get. Your heart sinks, all hope lost as you know you can&#39;t escape \
&lt;&lt;link &quot;your fate&quot;&gt;&gt;
	&lt;&lt;set $game_over to &quot;Elf Maiden&quot;&gt;&gt;\
	&lt;&lt;goto &quot;Game Over&quot;&gt;&gt;
&lt;&lt;/link&gt;&gt;.

&lt;&lt;remember $FootjobCruelBadEnd to true&gt;&gt;</tw-passagedata><tw-passagedata pid="24" name="Elf Maiden Play" tags="combat complete" position="752,1354" size="100,100">&quot;...if you&#39;ll give me the flower, I&#39;ll play with you,&quot; you finally say. &quot;Er, I mean...just for a little-&quot;\

&lt;&lt;set $ElfMood += 1&gt;&gt;\

Your words are cut off as Silvianna throw her arms around your neck with a squeal of delight. The next instant, her lips are pressed against yours in a deep, eager kiss that instantly drains your strength away.\

&lt;&lt;set $arousal += 1&gt;&gt;\

Her lips are soft as rose petals and taste as sweet as if they were dripping with honey. For a moment, you simply stand there in shock, letting her kiss you.

&quot;I&#39;m so happy,&quot; Silvianna whispers between kisses. Her tongue slips out to tease your lips, begging entrance inside. &quot;We&#39;re going to have //so// much fun together.&quot;

You don&#39;t even try to resist as she her tongue teases you again, instead parting your lips to let her kiss you deeper. Her hands run through your hair as she deepens the kiss and presses her body right up against you, so close that her barely covered hips rub right against the growing bulge in your pants.

At last she pulls away to smile up at you, lust burning in her bright green eyes.

&quot;There&#39;s so many ways we can play together,&quot; Silvianna whispers. She runs a slender, delicate hand down to your bulge and rubs slightly, &quot;I can play with you with my hands...&quot; She takes one of your own hands in hers, guiding it down to rest on the smooth curve of her ass, &quot;Or we can play with my ass...&quot; She stares deeply into your eyes and licks her lips seductively, &quot;Or I can give you a nice long //suck//...&quot;

You gulp deeply, heart pounding as your brain fills with fantasies of Silvianna pleasuring you in all those ways.

Silvianna giggles and presses another soft kiss to your lips, &quot;So, $name, how would you like to play?&quot;

[[Play with me using your hand...-&gt;Elf Maiden Handjob Play Intro]]
[[I want your ass...-&gt;Elf Maiden Ass Play Intro]]
[[Please suck me...-&gt;Elf Maiden Blowjob Play Intro]]</tw-passagedata><tw-passagedata pid="25" name="Elf Maiden Run" tags="combat nobr complete" position="1300,1103" size="100,100">You&#39;re not ready for this encounter right now. Better to retreat and 
come back later. &lt;br&gt; &lt;br&gt;

Following that train of thought, you turn around and run back into the 
forest.

&lt;&lt;if $SilviannaName&gt;&gt;
	&quot;Hey! Come back!&quot; Silvianna cries out. &quot;I promise playing together
	will be fun!&quot; &lt;br&gt; &lt;br&gt;
	
	Ignoring her words, you beat a decidedly unheroic retreat back
	into [[the forest-&gt;Forest]].
&lt;&lt;else&gt;&gt;
	&quot;Hey don&#39;t go!&quot; the elf maiden shouts after you. &lt;br&gt; &lt;br&gt;
	
	gnoring her words, you beat a decidedly unheroic retreat back
	into [[the forest-&gt;Forest]].
&lt;&lt;/if&gt;&gt;

</tw-passagedata><tw-passagedata pid="26" name="Item Use" tags="nobr noreturn" position="229,345" size="100,100">&lt;span id=&quot;use&quot;&gt;

	Use $UseItem?
	&lt;br&gt; &lt;br&gt;
	&lt;&lt;link &quot;Yes&quot;&gt;&gt;
		&lt;&lt;replace &#39;#use&#39;&gt;&gt;
			&lt;&lt;if $UseItem is &quot;potion&quot;&gt;&gt;
				&lt;&lt;usepotion&gt;&gt;
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	
	&lt;br&gt;
	
	&lt;&lt;link &quot;No&quot;&gt;&gt;
		&lt;&lt;if $inventoryLock&gt;&gt;
			&lt;&lt;goto $return&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;goto &quot;Inventory&quot;&gt;&gt;
		&lt;&lt;/else&gt;&gt;
	&lt;&lt;/link&gt;&gt;

&lt;/span&gt;

&lt;br&gt; &lt;br&gt;&lt;&lt;button &#39;Return&#39; &gt;&gt; &lt;&lt;goto $return&gt;&gt; &lt;&lt;/button&gt;&gt;</tw-passagedata><tw-passagedata pid="27" name="Elf Maiden Handjob Play" tags="nobr combat complete" position="456,1213" size="100,100">&lt;&lt;set $arousal += 2&gt;&gt;

&lt;&lt;if $will &lt;= 2&gt;&gt;
	She&#39;s brought you right to the edge, so close that coming back now
	is impossible.
	&lt;br&gt; &lt;br&gt;
	Your hips buck wildly, thrusting deeper into her eager grip as
	she pumps you furiously. The orgasm bursts out of you with a cry
	of ecstasy, your seed gushing out against her hand. She doesn&#39;t
	let up for a second, continuing to pump you as each pulse sends
	another rope of sticky cum spurting onto her silky skin.
	&lt;br&gt; &lt;br&gt;
	Silvianna smiles softly as you lay back and groan, so overcome
	with pleasure that your strength leaves your body, &quot;Wow, you came
	so much for me. Did my hand feel that good?&quot;
	&lt;br&gt; &lt;br&gt;
	You nod breathlessly, so dazed from the pleasure that you can&#39;t
	muster up any other response at the moment.
	&lt;br&gt; &lt;br&gt;
	&quot;I&#39;m glad,&quot; Silvianna giggles, kissing you as her strokes turn
	soft against your flaccid cock. &quot;Mmm, take a moment to recover,
	sweetie. We can [[play some more-&gt;Elf Maiden Play Finish]]
	when you&#39;re ready...&quot;
	
	&lt;&lt;set $arousal to $will&gt;&gt;
	&lt;&lt;set $damage += 5&gt;&gt;
	&lt;&lt;ejaculate&gt;&gt;
	&lt;&lt;set $ElfMood += 3&gt;&gt;
	
&lt;&lt;else&gt;&gt;
	&lt;&lt;switch visited()&gt;&gt;
		&lt;&lt;case 1&gt;&gt;
			Silvianna gently begins stroking your shaft, her smooth
			palm gliding across the hot skin of your cock. Her
			delicate fingers play as she rubs, teasing your sensitive
			head with delicate motions that are impossible to resist.
			&lt;br&gt; &lt;br&gt;
			You can&#39;t help but bite your lip and hold back a rising
			moan, already getting lost in her rhythm. She kisses you
			softly on the lips, the warm pressure stopping
			your thoughts
			in their tracks and leaving you unable to even think of 
			resistance. It all feels so good that you&#39;re quickly losing
			yourself to her touch...
			
		&lt;&lt;case 2&gt;&gt;
			Silvianna&#39;s soft, silky smooth hand rubs up and down,
			covering every inch of your sensitive, throbbing dick. 
			You moan into her lips as she kisses you, the combination 
			of her sweet lips and skillful hand leaving you completely
			immersed in ecstasy.
			&lt;br&gt; &lt;br&gt;
			&quot;Mmm...your so big and hard for me, darling,&quot; Silvianna
			giggles. &quot;And your lips are so soft. Isn&#39;t this fun? I
			told you I&#39;d make you feel good.&quot;
			&lt;br&gt; &lt;br&gt;
			You can only murmur softly in agreement between her kisses.
			Everything she&#39;s doing to you just feels so good...
			&lt;br&gt; &lt;br&gt;
			A small voice in the back of your mind whispers urgently
			that you need to stop this, that you&#39;re getting close to
			losing yourself completely.
			&lt;br&gt; &lt;br&gt;
			But it would be so easy to just let her continue toying
			with you...
			
		&lt;&lt;case 3&gt;&gt;
			Her tongue frantically explores your mouth, and you&#39;re 
			only too eager to respond, her kiss filling you with a
			molten hot pleasure that makes your cock throb even
			harder against her silky hand.
			&lt;br&gt; &lt;br&gt;
			Her nimble fingers play with your heavy balls, fondling
			them gently before moving back up to smear your emerging
			drips of precum all over the tip.
			&lt;br&gt; &lt;br&gt; 
			You can&#39;t hold back your moans anymore, letting them spill
			carelessly from your lips to be devoured by her hungry
			kiss. Your hips buck and thrust wildly into her, lost
			completely in her seductive, irresistible rhythm.
			&lt;br&gt; &lt;br&gt;
			You&#39;re right on the edge, so close to cumming that you know
			this is the last chance you have to resist her...

		&lt;&lt;default&gt;&gt;
			She rub you good.
			
	&lt;&lt;/switch&gt;&gt;
	
	&lt;br&gt; &lt;br&gt;
	
	[[Stop her-&gt;Elf Maiden Handjob Play Resist]]
	&lt;br&gt;
	&lt;&lt;if $will &gt; 4&gt;&gt;
		[[Let her stroke you...-&gt;Elf Maiden Handjob Play]]
	&lt;&lt;else&gt;&gt;
		[[Let her finish you...-&gt;Elf Maiden Handjob Play]]
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;



</tw-passagedata><tw-passagedata pid="28" name="Elf Maiden Ass Play" tags="combat nobr complete" position="486,1417" size="100,100">&lt;&lt;set $arousal += 2&gt;&gt;

&lt;&lt;if $will &lt;= 2&gt;&gt;
	You moan desperately as she grinds against you harder still,
	your hard, throbbing shaft enveloped in the softness of her
	ass. &lt;br&gt; &lt;br&gt;
	
	&quot;Cum for me,&quot; she moans, her ass insistant and relentless as she
	grinds against me. &quot;Come on, baby, cum all over me! I want your
	hot, filthy cum allll over my ass! &lt;br&gt; &lt;br&gt;
	
	Her lewd, filthy words send you over the edge. You grab tightly
	onto her hips as you cum, your seed bursting out in thick, sticky 
	ropes to paint her ass white. And just as you think you&#39;re finished
	she presses even harder aganst you, her ass milking out pulsing,
	spasming load from your cock. &lt;br&gt; &lt;br&gt;
	
	Completely overwhelmed and overstimulated, you fall to the forest
	floor. You stare up at her ass, eyes glued to the drips of your
	spent cum sliding down her rounded skin. &lt;br&gt; &lt;br&gt;
	
	Silvianna gives her ass
	another shake and giggles, &quot;Ooooh, you came sooo much for me,
	baby.&quot; 
	Looking you dead in the eye, she reaches a slender finger back
	to her ass and scoops up a bit of your cum, bringing it back to
	her mouth to suck clean, &quot;I can&#39;t wait to see what 
	[[more you have-&gt;Elf Maiden Play Finish]] for me~.
	
	&lt;&lt;set $arousal to $will&gt;&gt;
	&lt;&lt;set $damage += 5&gt;&gt;
	&lt;&lt;ejaculate&gt;&gt;
	&lt;&lt;set $ElfMood += 3&gt;&gt;
	
&lt;&lt;else&gt;&gt;
	&lt;&lt;switch visited()&gt;&gt;
		&lt;&lt;case 1&gt;&gt;
			She starts off slow, rolling her hips in gentle, soft
			movements that settle into relaxed, steady rhythm. 
			She hums softly as she does so, setting a sweet music
			as she shakes and rubs against
			you. The hem of her dress brushes against the tip of
			your dick with every roll of her hips, the gentle tease
			of the silky fabric a delightful contrast to the hot
			flesh of her ass. &lt;br&gt; &lt;br&gt;
			
			Your breathing grows heavier as you gradually sink into
			her rhythm, your cock hardening against her soft,
			full cheeks. It would feel so good to let go of your 
			hesitance and slip deeper into her sensual dance...
			
		&lt;&lt;case 2&gt;&gt;
			Silvianna reaches up behind her and carresses your cheek
			guiding you down to meet her in a deep, lingering kiss.
			At the same time, she presses harder against you, forcing
			out a soft groan of pleasure from your lips, a groan she
			eagerly devours, leaving you breatless and gasping 
			between kisses. &lt;br&gt; &lt;br&gt;
			
			&quot;Don&#39;t fight it,&quot; she whispers. &quot;Don&#39;t resist, darling.
			Just enjoy it. Enjoy the feeling of my soft, plump ass
			rubbing riiight up against your thick, hard...oh goddess
			it&#39;s so hard...throbbing cock!&quot; &lt;br&gt; &lt;br&gt;
			
			Her tempting whispers lead you gently, inexorably deeper
			under her blissful spell, the same magic that her ass is
			casting on you with every smooth roll of her hips. &lt;br&gt;
			&lt;br&gt;
			
			It&#39;s becoming more and more tempting just to sink deeper
			into the pleasure she&#39;s giving you...
			
		&lt;&lt;case 3&gt;&gt;
			Her full, mesmerizingly soft cheeks engulf your cock in
			a cloud of pleasure like a thick, warm blanket. A similar 
			cloud descends on your thoughts, coating them in a warm
			pink haze that blots away everything else. &lt;br&gt; &lt;br&gt;
			
			&quot;Ahhh...&quot; she sweetly sighs. &quot;It feels soooo nice, doesn&#39;t
			it? I bet you want to feel more than just my ass, don&#39;t
			you?&quot; &lt;br&gt; &lt;br&gt;
			
			Without waiting for reply, she gently takes your hands
			in hers and guides them up
			to her breasts. Your hands are only too happy to accept
			the offering, acting on their own without any imput from
			your pleasure drenched brain. Your fingers sink into the
			fullness of her breasts, feeling their shape yield to you
			as they fill up your entire hand. The double assault of her
			breasts and her ass is far too much for your
			pleasure-drunk brain to bear. &lt;br&gt; &lt;br&gt;
			
			You&#39;re so close that you know only a few more seconds may
			be enough to finish you off...
		&lt;&lt;default&gt;&gt;
			Her ass good.
	&lt;&lt;/switch&gt;&gt;
	
	&lt;br&gt; &lt;br&gt;
	
	[[Stop her-&gt;Elf Maiden Ass Play Resist]]
	&lt;br&gt;
	&lt;&lt;if $will &gt; 4&gt;&gt;
		[[Let her continue...-&gt;Elf Maiden Ass Play]]
	&lt;&lt;else&gt;&gt;
		[[Let her finish you...-&gt;Elf Maiden Ass Play]]
	&lt;&lt;/if&gt;&gt;
	
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="29" name="Elf Maiden Blowjob Play" tags="combat complete nobr" position="563,1557" size="100,100">&lt;&lt;set $arousal += 2&gt;&gt;

&lt;&lt;set $arousal += 2&gt;&gt;

&lt;&lt;if $will &lt;= 2&gt;&gt;
	Sensing your surrender, Silvianna abandons her slow, steady 
	rhythm and takes you the deepest yet. Faster, deeper, she pushes 
	you to your absolute limit, filling you with so much pleasure
	that you&#39;re about to burst. &lt;br&gt; &lt;br&gt;
	
	Her hands clench into the muscles of our ass, trapping deep within
	her sweetness as you finally explode with a desperate moan of
	surrender, shooting your load deep
	her ravenous mouth. She only sucks harder, slurping down every
	drop of your
	seed that you offer to her with absolute devotion. She only stops
	when you&#39;re drained completely dry, having emptied you of every
	precious drop. &lt;br&gt; &lt;br&gt;
	
	She pulls away with a soft //pop// of her lips, leaving a string
	of sticky saliva between her lips and your cock. She slowly licks
	her cum-soaked lips and swallows deeply, her face a picture
	of pure rapture. &lt;br&gt; &lt;br&gt;

	Your knees buckle and you sink down to the forest floor, so
	overwhelmed by the afterglow of her intoxicating pleasure that
	you can barely think. &lt;br&gt; &lt;br&gt;
	
	Silvianna giggles and crawls up beside you, bringing her flushed,
	ecstatic face close to yours, &quot;You taste sooo wonderful, baby.
	Mmm...just take a second to rest. Then...we can
	[[play some more-&gt;Elf Maiden Play Finish]]
	
	&lt;&lt;set $arousal to $will&gt;&gt;
	&lt;&lt;set $damage += 5&gt;&gt;
	&lt;&lt;ejaculate&gt;&gt;
	&lt;&lt;set $ElfMood += 3&gt;&gt;
	
&lt;&lt;else&gt;&gt;
	&lt;&lt;switch visited()&gt;&gt;
		&lt;&lt;case 1&gt;&gt;
			Her tongue slowly circles your head as she softly sucks,
			her rhythm so slow and gentle that it relaxes you
			completely. Her soft lips press against the tip in a 
			tender kiss before she slides back down to envelope 
			your whole head in the warmth and wetness of her
			sweet mouth. &lt;br&gt; &lt;br&gt;
			
			Your heartbeat quickens and your breathing gets heavy
			as she sucks, every second sending a wave of pleasure
			pulsing through you. Her eyes lock with yours, holding
			you spellbound, unable to look away even if you wanted
			to. &lt;br&gt; &lt;br&gt;
			
			The temptation to just relax and let her pleasure you
			is almost unbearable...
			
		&lt;&lt;case 2&gt;&gt;
			Silvianna slowly kisses her way down your shaft, the 
			touch of her lips send a surge of burning pleasure
			through you with every sweet press. Her lips trace a line
			all the way down your cock to your heavy balls, her lips
			opening up to suck each one like the sweetest candy. &lt;br&gt;
			&lt;br&gt;
			
			Then, she covers the full length of your cock in a single
			long, lustful lick, bringing her back up to the top so
			she can take you fully into her mouth. Her cheeks tighten
			as her sweet suction pulls you in and wraps you deeper
			in the warm, wet depths of her mouth, and a shudder
			of pleasure runs through you from head to toe. &lt;br&gt; &lt;br&gt;
			
			A voice in the back of your mind warns you of the danger
			of your situation, but her mouth just feels so good...
			
		&lt;&lt;case 3&gt;&gt;
			The whole clearing fills with the sound of Silvianna&#39;s
			wet, lascivious slurps and lewd moans as she takes 
			you deeper in. She sucks you in
			a slow, steady rhythm, one that destroys all resistance and
			ravages your mind with pleasure. &lt;br&gt; &lt;br&gt;
			
			Your hips move on their own, falling into her rhythm and
			pushing deeper into the honey soaked sweetness of her 
			mouth. The moans spill carelessly from your mouth,
			each one encouraging Silvianna to suck you deeper into her
			ruinous pleasure.  &lt;br&gt; &lt;br&gt;
			
			The pleasure rising up within you is becoming impossible to
			deny, and you know that if you don&#39;t pull away now there&#39;s
			no way you&#39;ll be able to resist emptying yourself into her
			hungry mouth...
			
		&lt;&lt;default&gt;&gt;
			She suck you good.
	&lt;&lt;/switch&gt;&gt;
	
	&lt;br&gt; &lt;br&gt;
	
	[[Stop her-&gt;Elf Maiden Blowjob Play Resist]]
	&lt;br&gt;
	&lt;&lt;if $will &gt; 4&gt;&gt;
		[[Let her suck you...-&gt;Elf Maiden Blowjob Play]]
	&lt;&lt;else&gt;&gt;
		[[Let her finish you...-&gt;Elf Maiden Blowjob Play]]
	&lt;&lt;/if&gt;&gt;
	
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="30" name="Elf Maiden Handjob Play Intro" tags="nobr combat complete" position="599,1199" size="100,100">&lt;&lt;set $arousal += 1&gt;&gt;

&lt;&lt;if $naked&gt;&gt;
	&quot;I...I want to feel your hand,&quot; you gasp. &lt;br&gt; &lt;br&gt;
	
	Silvianna smiles and gently kisses you on the lips, &quot;Good choice.&quot;
	She brings her lips up to your ear and breathes, &quot;Because I want
	to feel your cock.&quot; &lt;br&gt; &lt;br&gt;
	
	Silvianna gently moves you up against a nearby tree so you&#39;re
	laying with your back resting against it, then she drapes her
	body against yours, cuddling close with her head on your shoulder
	and her hand in your lap. &lt;br&gt; &lt;br&gt;
	
	She kisses you deeply on the lips before
	[[curling her fingers around your shaft-&gt;Elf Maiden Handjob Play]]
	, &quot;I&#39;m going to make you feel so good, darling...&quot;
	
&lt;&lt;else&gt;&gt;
	&quot;Your...hand,&quot; you gasp. &quot;I-I want you to play with me using your
	hand...&quot; &lt;br&gt; &lt;br&gt;
	
	Silvianna smiles and gives you another soft kiss on the lips,
	&quot;Then let&#39;s get you out of those clothes, darling. &lt;br&gt; &lt;br&gt;
	
	Hands trembling, you shed your shirt and pants and discard them
	on the forest floor. Silvianna coos as you undress, planting
	soft kisses on your chest and shoulders and gently grazing her
	delicate fingers across your sensitive skin. She kisses your lips
	as she takes your staff and satchel away to leave them beyond
	your reach, her lips so sweet that even completely disarmed you
	don&#39;t feel any fear at all. &lt;br&gt; &lt;br&gt;
	
	She takes your hand and leads you to a nearby tree,
	sitting you down
	with your back to it while she lays beside you, her head resting on
	your shoulder and her hand in your lap. &lt;br&gt; &lt;br&gt;
	
	She kisses you deeply on the lips before
	[[curling her fingers around your shaft-&gt;Elf Maiden Handjob Play]]
	, &quot;I&#39;m going to make you feel so good, darling...&quot;
	
	&lt;&lt;set $naked&gt;&gt;
	&lt;&lt;set $weapon to false&gt;&gt; 
	
&lt;&lt;/if&gt;&gt;\</tw-passagedata><tw-passagedata pid="31" name="Elf Maiden Ass Play Intro" tags="combat nobr complete" position="595,1318" size="100,100">&lt;&lt;set $arousal += 1&gt;&gt;

&lt;&lt;if $naked&gt;&gt;
	You stare at the elf maiden&#39;s amble bottom, &quot;I...I want your ass.&quot;
	&lt;br&gt; &lt;br&gt;
	
	Silvianna giggles and turns around, giving her hips a wiggle
	to emphasize her ass, &quot;Goood choice! Well, if you want it, come
	and get it!&quot; &lt;br&gt; &lt;br&gt;
	
	Trembling, you walk up to her and embrace her from behind. You
	gasp as she lifts up her skirt to reveal her naked ass, then
	presses
	it right up against your erect cock. &lt;br&gt; &lt;br&gt;
	
	Silvianna sighs and nuzzles against your shoulder, &quot;Mmm, your big,
	hard cock feels sooo good pressing up against me. I&#39;m gonna make
	you
	feel good too... &lt;br&gt; &lt;br&gt;
	
	You let out a low groan as she begins to
	[[rub her ass-&gt;Elf Maiden Ass Play]]
	right up against you...
	
&lt;&lt;else&gt;&gt;
	You gulp and stare at the elf maiden&#39;s amble bottom, &quot;I...I want
	your ass.&quot; &lt;br&gt; &lt;br&gt;
	
	Silvianna giggles and turns around, giving her hips a wiggle and
	lifting up her dress to show off her naked ass, &quot;Goood choice!
	Well, come on then!&quot; &lt;br&gt; &lt;br&gt;
	
	But when you step forward, she giggles and dances away,
	&quot;Nah-ah-ah! You&#39;re not really going to try to take me with your
	clothes still on, are you?&quot; &lt;br&gt; &lt;br&gt;
	
	You blush deeply, but another enticing wiggle of her shapely
	ass spurs you to action. With trembling hands, you shed your
	clothes and let them fall to the forest floor. &lt;br&gt; &lt;br&gt;
	
	Silvianna bites her, staring appreciatively and your erect, eager
	cock, &quot;Ooh, you really //do// want me!&quot; She walks toward you with
	lust in her eyes, &quot;I&#39;ll give you what you want then, baby.&quot; 
	&lt;br&gt; &lt;br&gt;
	
	You gasp as she presses up against you, her soft,
	squeezable ass right up against your engorged cock. That gasp
	turns into a low groan of pleasure as she begins to
	[[rub her ass-&gt;Elf Maiden Ass Play]]
	right up against you...
	
	&lt;&lt;set $naked&gt;&gt;
	&lt;&lt;set $weapon to false&gt;&gt; 
	
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="32" name="Elf Maiden Blowjob Play Intro" tags="combat nobr complete" position="692,1499" size="100,100">&lt;&lt;set $arousal += 1&gt;&gt;

&lt;&lt;if $naked&gt;&gt;
	Your gaze lingers on her full, luscious lips, &quot;Please...I want
	you to suck me.&quot; &lt;br&gt; &lt;br&gt;
	
	Silvianna&#39;s eyes light up with excitement as she eagerly licks her
	lips and kneels down in front of you, &quot;Ohhh, yes! I&#39;ll suck every
	inch of your delicious cock!&quot; &lt;br&gt; &lt;br&gt;
	
	Your breath quickens as you stand before her and guide your cock
	nearer to her waiting mouth. The sight of such a beautiful girl
	on her knees before you has you fully erect and almost unbearably
	ready for her. &lt;br&gt; &lt;br&gt;
	
	&quot;Mmm...&quot; she leans in close and opens up wide... &lt;br&gt; &lt;br&gt;
	
	And then her velvet lips wrap around your cock and she begins
	to [[suck-&gt;Elf Maiden Blowjob Play]].
	
&lt;&lt;else&gt;&gt;
	Your gaze lingers on her full, luscious lips, &quot;Please...I want you
	to suck me.&quot; &lt;br&gt; &lt;br&gt;
	
	Silvianna&#39;s eyes light up in excitement as she eagerly licks her
	lips, &quot;Good choice, baby! Let&#39;s get you out of those pants...&quot;
	&lt;br&gt; &lt;br&gt;
	
	With trembling hands, you strip away your clothes and let them
	fall to the forest floor. The thought of her full, soft lips
	wrapped around your cock has you rock hard already, and as
	Silvianna kneels down in front of you, you arousal only
	increases. &lt;br&gt; &lt;br&gt;
	
	&quot;Mmm...&quot; Silvianna leans in and traces a finger down your cock.
	&quot;You have such a nice, thick cock. I can&#39;t wait to taste it...&quot;
	&lt;br&gt; &lt;br&gt;
	
	Your eyes widen as her luscious lips open wide...
	
	And she takes your cock
	[[into her mouth-&gt;Elf Maiden Blowjob Play]]. 

	&lt;&lt;set $naked&gt;&gt;
	&lt;&lt;set $weapon to false&gt;&gt; 
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="33" name="Elf Maiden Handjob Play Resist" tags="nobr combat complete" position="305,1263" size="100,100">You try to resist the pleasure of her &lt;&lt;print either(&quot;comforting handjob&quot;, &quot;seductive caress&quot;, &quot;intoxicating handjob&quot;, &quot;gentle hands&quot;, &quot;loving handjob&quot;)&gt;&gt;...

&lt;&lt;set _mod to $struggle&gt;&gt;
&lt;&lt;set $ElfMood -= 1&gt;&gt;
&lt;&lt;set $checkStat to &quot;res&quot;&gt;&gt;
&lt;&lt;set $checkAgainst to 7&gt;&gt;

&lt;br&gt; &lt;br&gt;

&lt;&lt;linkreplace &quot;Resist&quot;&gt;&gt;
	&lt;&lt;Stat_Check&gt;&gt;
	
	&lt;&lt;if _checkPass&gt;&gt;
		And you manage to pull away from her gentle grip!
		&lt;br&gt; &lt;br&gt;
		You push Silvianna away and jump to your feet
		with a wild yell, &quot;That&#39;s enough!&quot;
		&lt;br&gt; &lt;br&gt;
		A flash of anger crosses the elf maiden&#39;s face before turning
		into an adorable pout, &quot;Aw, I was just getting to the good
		part!
		Come on, let me play with you some more.&quot; She deepens her
		pout, showing off her full, luscious lips to you, &quot;Don&#39;t you
		want more kisses?&quot;
		&lt;br&gt; &lt;br&gt;
		As tempting as her lips are, you shake your head and take
		a deep breath. You have a chance
		to act now...
		&lt;br&gt; &lt;br&gt;
		&lt;&lt;set $struggle to 0&gt;&gt;
		You prepare yourself to [[fight-&gt;Elf Maiden Fight]] back.
		
	&lt;&lt;else&gt;&gt;
		&lt;&lt;switch visited()&gt;&gt;
			&lt;&lt;case 1&gt;&gt;
				But the smooth caress of her hands saps away your will,
				leaving you submissive and compliant
				in her loving grip.
				&lt;br&gt; &lt;br&gt;
				&quot;Don&#39;t resist,&quot; she coos, her pink lips brushing
				against your ear. &quot;Just let me make you feel good...&quot;
								
			&lt;&lt;case 2&gt;&gt;
				But as you start to pull away, you traps you in a 
				deep, tender kiss, her tongue darting in to ensnare
				you deeper. Her sweet saliva fills your head with a 
				blissful haze, and you quickly forget why you were
				trying to stop her...
				
			&lt;&lt;case 3&gt;&gt;
				But her hand squeeze tightly around your balls as
				you try to move, sending a brief spasm of pain
				intermixed with the pleasure she&#39;s giving you.
				&lt;br&gt; &lt;br&gt;
				&quot;Don&#39;t try to go,&quot; Silvianna smiles, far too innocent
				an expression for someone who has you most tender, 
				intimate part in her grip. &quot;There&#39;s so much more
				fun we can have...&quot;
				&lt;br&gt; &lt;br&gt;
				She resumes stroking you, at the same time planting
				tender kisses on your neck, and you know the chance
				to resist is past.
				
		&lt;&lt;/switch&gt;&gt;
		
		&lt;br&gt; &lt;br&gt;
		&lt;&lt;set $struggle += 1&gt;&gt;
		
		Overcome by pleasure, you relax in her grip as her stroking
		[[continues-&gt;Elf Maiden Handjob Play]].
		
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;</tw-passagedata><tw-passagedata pid="34" name="Elf Maiden Play Finish" tags="combat nobr complete Bad-End" position="261,1443" size="100,100">&lt;&lt;if $ejaculation &gt; 1&gt;&gt;
	You groan softly as you lay prone and helpless on the ground, the
	afterglow still leaving your body ravished by pleasure. A pink
	haze covers your vision. &lt;br&gt; &lt;br&gt;
	
	Silvianna curls up beside you, nuzzling you and kissing you 
	softly, each tender press of her lips sending another wave of
	sweet, numbing bliss washing over your pleasure-stricken form.
	&lt;br&gt; &lt;br&gt;
	
	Long after the pleasure should have passed, you&#39;re still unable
	to move, the second orgasm having been even more powerful than the
	first. The voice of reason that should be keeping you safe and 
	warning you against falling into temptation is nothing more than
	a faint buzz now, so weak against the desire filling you up that
	it&#39;s all but worthless. &lt;br&gt; &lt;br&gt;
	
	At last, Silvianna speak, her voice a gentle melody in your ears,
	&quot;Mmm...ready to play some more, lover?&quot; &lt;br&gt; &lt;br&gt;
	
	You can only groan softly, too weak to even voice affirmation, much
	less dissent. &lt;br&gt; &lt;br&gt;
	
	She giggles in response, &quot;Awww, are you too weak still? Humans
	really are weak, huh? That&#39;s ok; it&#39;s kind of cute. Hmmm...well, if
	we can&#39;t play more here, I&#39;ll just have to take you back home with 
	me. Then we can play all we want...whenever we want. I&#39;ll even let
	the other girls play with you too. We&#39;ll play with you until
	you forget you&#39;re anything but a toy for me. Doesn&#39;t that
	sound nice?&quot; &lt;br&gt; &lt;br&gt;
	
	Another longing moan is the only response you&#39;re capable of.
	
	&quot;Come on then,&quot; she says, smiling as she helps you to your feet.
	
	You stumble and sway as she leads you, unable to register anything
	besides the girl leading you by the hand
	&lt;&lt;link &quot;to your new home&quot;&gt;&gt;
		&lt;&lt;set $game_over to &quot;Elf Maiden&quot;&gt;&gt;
		&lt;&lt;goto &quot;Game Over&quot;&gt;&gt; 
	&lt;&lt;/link&gt;&gt;...
	
	&lt;&lt;remember $PlayBadEnd to true&gt;&gt;
	
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $will = 5&gt;&gt;
	You lay for a while on the soft, mossy bed of the clearing, 
	Silvianna curled up beside you, nuzzling you and kissing your
	cheek and neck while she waits for you to recover.
	&lt;br&gt; &lt;br&gt;
	At last, you feel recovered enough to sit up.
	&lt;br&gt; &lt;br&gt;
	&quot;Feeling better?&quot; Silvianna asks.
	&lt;br&gt; &lt;br&gt;
	&quot;Y-yeah,&quot; you say, the deep pleasure-induced exhaustion slowly
	fading from your limbs.
	&lt;br&gt; &lt;br&gt;
	&quot;Good!&quot; Silvianna beams at your, eyes lighting up with excitement,
	&quot;Then we can play again!&quot;
	&lt;br&gt; &lt;br&gt;
	You hesitate. You really shouldn&#39;t keep doing this, but maybe
	just a bit longer wouldn&#39;t hurt...
	&lt;br&gt; &lt;br&gt;
	&quot;Come on,&quot; she urges. &quot;There&#39;s so many ways we can play
	together...&quot;
	&lt;br&gt; &lt;br&gt;
	
	&lt;&lt;if not visited(&quot;Elf Maiden Handjob Play&quot;)&gt;&gt;
		[[Hand play...-&gt;Elf Maiden Handjob Play Intro]]
	&lt;&lt;/if&gt;&gt;
	&lt;br&gt;
	&lt;&lt;if not visited(&quot;Elf Maiden Ass Play&quot;)&gt;&gt;
		[[You want her ass...-&gt;Elf Maiden Ass Play Intro]]
	&lt;&lt;/if&gt;&gt;
	&lt;br&gt;
	&lt;&lt;if not visited(&quot;Elf Maiden Blowjob Play&quot;)&gt;&gt;
		[[Her mouth is so inviting...-&gt;Elf Maiden Blowjob Play Intro]]
	&lt;&lt;/if&gt;&gt;
	&lt;br&gt;
	[[You&#39;re finished playing.-&gt;Elf Maiden Play Finish 2]]
	
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="35" name="Elf Maiden Play Finish 2" tags="nobr complete combat" position="200,1621" size="100,100">&quot;N-no,&quot; you gasp. &quot;I&#39;m...I&#39;m done.&quot;

&lt;br&gt; &lt;br&gt;

Silvianna frowns, &quot;Done? You don&#39;t want to play anymore?&quot;

&lt;br&gt; &lt;br&gt;

&quot;That&#39;s right,&quot; you nod. &quot;You...you said it would only be for a little
bit, and then I could have the flower.&quot;

&lt;br&gt; &lt;br&gt;

Silvianna bites her lip and pouts, &quot;Hmph. I guess I did say that...&quot;

&lt;br&gt; &lt;br&gt;

For a long while, she goes quiet as if deep in thought, your heart 
hammers. You&#39;re beginning to worry she might not let you go so easily...

&lt;br&gt; &lt;br&gt;
&lt;&lt;linkreplace &quot;Continue&quot;&gt;&gt;

&lt;&lt;if $ElfMood &gt;= 4&gt;&gt;
	But to your relief, at last she sighs and rolls away from you,
	&quot;I guess you //did// play with me like I asked. Alright,
	fine. Take the stupid flower. I&#39;m a lot 
	more fun than flowers though.&quot;
	
	&lt;br&gt; &lt;br&gt;
	
	You sigh in relief. It looks like you&#39;ve managed to emerge from
	your encounter relatiely unscathed. You rise to your feet,
	gathering your clothes
	and walking to the center of the clearing. You pluck the Moondrop
	flower from where it rests and take a second to admire it. On the
	outside, the petals are a deep blue, but the inside has a bright,
	almost silvery sheen. You place the flower in your pouch and turn 
	away, filled with a mixture of relief and pride that you managed
	to complete your quest.
	
	&lt;&lt;set UInv.AddItem(&quot;inventory&quot;,&quot;Moondrop Flower&quot;)&gt;&gt;
	&lt;br&gt; &lt;br&gt;
	
	When you turn around you find Silvianna sitting with her arms
	folded and her back to you, clearly still sulking.
	
	[[Try to comfort the elf maiden.-&gt;Elf Maiden Sulk]]
	&lt;br&gt;
	[[Leave without another word.-&gt;Elf Maiden Play VICTORY]]
	
&lt;&lt;else&gt;&gt;
	Sure enough, the very mext thing she does is tackle you,
	pinning you
	down on the forest floor.
	
	&lt;br&gt; &lt;br&gt;
	
	&quot;Ah!&quot; You cry out.
	
	&lt;br&gt; &lt;br&gt;
	
	Silvianna grins down at you, her emerald eyes twinkling with 
	mischief, &quot;I changed my mind, too bad! I&#39;m not //nearly// done
	playing with you yet. Had you been a good boy and let me play with
	you nicely, I would have let you go, you just kept struggling!
	So, now I&#39;m going to have to make you my toy~.
	
	&lt;br&gt; &lt;br&gt;
	
	You struggle in her grip, your mind racing. It looks like
	negotiations are off. You&#39;ll have to escape this somehow. Even
	if [[pinned down and naked-&gt;Elf Maiden Pinned]]
	like this escape seems impossible...
	
&lt;&lt;/if&gt;&gt;\

&lt;&lt;/linkreplace&gt;&gt;</tw-passagedata><tw-passagedata pid="36" name="Elf Maiden Ass Play Resist" tags="combat complete" position="373,1552" size="100,100">You try to resist the pleasure of her &lt;&lt;print either(&quot;pillowy&quot;, &quot;soft, full&quot;, &quot;intoxicating&quot;, &quot;heavenly&quot;, &quot;grinding&quot;)&gt;&gt; ass...

&lt;&lt;set _mod to $struggle&gt;&gt;
&lt;&lt;set $ElfMood -= 1&gt;&gt;
&lt;&lt;set $checkStat to &quot;res&quot;&gt;&gt;
&lt;&lt;set $checkAgainst to 7&gt;&gt;

&lt;br&gt; &lt;br&gt;

&lt;&lt;linkreplace &quot;Resist&quot;&gt;&gt;
	&lt;&lt;Stat_Check&gt;&gt;
	
	&lt;&lt;if _checkPass&gt;&gt;
		And you manange to push her away from you, freeing yourself
		of her ass&#39; sinister tempation!
		&lt;br&gt; &lt;br&gt;
		A flash of anger crosses the elf maiden&#39;s face before turning
		into an adorable pout, &quot;Aw, I was just getting to the good
		part!
		Come on, let me play with you some more.&quot; She turns around 
		and gives you a little wiggle of her cute butt, &quot;Don&#39;t you
		want to play with my ass?&quot;
		&lt;br&gt; &lt;br&gt;
		As tempting as it is, you remain firm. You shake your head
		decisively and take a deep breath. You have a chance
		to act now...
		&lt;br&gt; &lt;br&gt;
		&lt;&lt;set $struggle to 0&gt;&gt;
		You prepare yourself to [[fight-&gt;Elf Maiden Fight]] back.
		
	&lt;&lt;else&gt;&gt;
		&lt;&lt;switch visited()&gt;&gt;
			&lt;&lt;case 1&gt;&gt;
				But as you try to push her away, she grinds her
				ass harder against your cock, forcing a deep groan
				of lust from your lips and draining away your abiltity
				to push her away...
				&lt;br&gt; &lt;br&gt;
				Silianna glances behind her and smiles as she presses
				against you, &quot;You don&#39;t //really/ want to leave my
				ass yet, do you, baby? Just let me play with you a
				little longer...&quot;
								
			&lt;&lt;case 2&gt;&gt;
				 But as you start to push her away, she lets out a 
				 lustful
				 moan and presses deeper into your body, her soft
				 ass cheeks molding perfectly around your aching
				 cock.
				 &lt;br&gt; &lt;br&gt;
				 The sensation feels so good that you lose all strength
				 to resist.
				
			&lt;&lt;case 3&gt;&gt;
				But as she grinds and rubs her gorgeous ass against
				your cock, you instead find yourself holding on
				to her hips to encourage her rhythm. You just
				can&#39;t resist her...
				
		&lt;&lt;/switch&gt;&gt;
		
		&lt;br&gt; &lt;br&gt;
		&lt;&lt;set $struggle += 1&gt;&gt;
		
		Overcome by pleasure, you relax and let her
		[[continue-&gt;Elf Maiden Ass Play]] grinding her ass against
		you...
		
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;</tw-passagedata><tw-passagedata pid="37" name="Elf Maiden Blowjob Play Resist" tags="combat complete" position="459,1671" size="100,100">You try to resist the pleasure of her &lt;&lt;print either(&quot;warm, wet mouth&quot;, &quot;soft, full lips&quot;, &quot;intoxicating mouth&quot;, &quot;heavenly mouth&quot;, &quot;sucking mouth&quot;)&gt;&gt;...

&lt;&lt;set _mod to $struggle&gt;&gt;
&lt;&lt;set $checkStat to &quot;res&quot;&gt;&gt;
&lt;&lt;set $checkAgainst to 7&gt;&gt;
&lt;&lt;set $ElfMood -= 1&gt;&gt;

&lt;br&gt; &lt;br&gt;

&lt;&lt;linkreplace &quot;Resist&quot;&gt;&gt;
	&lt;&lt;Stat_Check&gt;&gt;
	
	&lt;&lt;if _checkPass&gt;&gt;
		And manage to push her hungry mouth away from your cock!
		&lt;br&gt; &lt;br&gt;
		
		A flash of anger crosses the elf maiden&#39;s face before turning
		into an adorable pout as she rises to her feet
		, &quot;Aw, I was just getting to the good
		part!
		Come on, let me play with you some more.&quot; She opens up her
		mouth and sticks her tongue out invitingly, &quot;Pleeease? I&#39;m
		so hungry for your cum...&quot;
		&lt;br&gt; &lt;br&gt;
		
		As tempting as it is, you shake your head
		and take a deep breath. You have a chance
		to act now...
		&lt;br&gt; &lt;br&gt;
		
		&lt;&lt;set $struggle to 0&gt;&gt;
		
		You prepare yourself to [[fight-&gt;Elf Maiden Fight]] back.
		
	&lt;&lt;else&gt;&gt;
		&lt;&lt;switch visited()&gt;&gt;
			&lt;&lt;case 1&gt;&gt;
				But as you go to push her away, Silvianna plants a
				sweet, tender kiss on your tip and looks up
				at you with pleading eyes.
				&lt;br&gt; &lt;br&gt;
				
				Maybe just a little more wouldn&#39;t hurt...
								
			&lt;&lt;case 2&gt;&gt;
				But before you can move, Silvianna nuzzles
				up against you and lets out a soft moan of pleasure,
				and instead of pushing her way, you find yourself 
				stroking her silky hair instead.
				
			&lt;&lt;case 3&gt;&gt;
				But as you try to move away, her hands clutch into 
				your ass and pull in closer, forcing you deeper into
				her mouth.
				&lt;br&gt; &lt;br&gt;
				
				You moan in ecstasy, your hips automatically thrusting
				to her rhythm, all thought of resistance forgotten.
				
		&lt;&lt;/switch&gt;&gt;
		
		&lt;br&gt; &lt;br&gt;
		&lt;&lt;set $struggle += 1&gt;&gt;
		
		Overcome by pleasure, you relax and let her 
		[[continue-&gt;Elf Maiden Blowjob Play]] to suck you
		off...
		
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;</tw-passagedata><tw-passagedata pid="38" name="Elf Maiden Sulk" tags="complete" position="64,1519" size="100,100">Fully clothed and flower in hand, you walk up to the elf maiden&#39;s side, &quot;Er...I&#39;m sorry if I offended you.&quot;

Silvianna just //hmphs// and remains turned away, &quot;Why don&#39;t you take your stupid flower and leave if it&#39;s more important to you than I am.&quot;

&quot;Well...it&#39;s not that it&#39;s more important,&quot; you say, scratching your cheek. &quot;It&#39;s just my job so...&quot;

Silvianna&#39;s pointed ears perk up, &quot;So...you //do// like me better then?&quot;

&quot;Huh? Better than a flower?&quot; you frown in confusion. &quot;Well, sure, I mean, I don&#39;t really know you but-&quot;

You&#39;re cut off by Silvianna whirling around and mashing her lips to yours.

&quot;I knew it!&quot; she exclaims excitedly, parting from your lips for a second that leaves you gasping. &quot;I knew you liked me!&quot;

In your bewilderment, you can only stand there blinking as she rains kisses on your face. At last she pulls back, smiling up at you with her arms curled around your neck.

&quot;Come on, play with me some more,&quot; Silvianna pleads. &quot;Pleeease, I know you like me, so you must want to.&quot;

You cock twitches as she presses up against you, but you manage to keep your mind on the task at hand, &quot;Sorry, but I still have to deliver the flower. It&#39;s my job so...&quot;

&quot;Aw...ok, fine,&quot; Silvianna pouts. &quot;But you&#39;ll come back and play with me again, won&#39;t you?&quot;

You can&#39;t deny that the prospect does sound enticing. As difficult as this girl is to deal with, a soft, tender elf maiden this eager to fuck is not something you can turn down likely.

&quot;I&#39;ll...I&#39;ll try to,&quot; you finally reply.

&quot;Ok! I&#39;ll be waiting,&quot; Silvianna give you a last, deep kiss goodbye, then steps away, waving to you as you [[depart-&gt;Elf Maiden Play VICTORY]], leaving the clearing behind.</tw-passagedata><tw-passagedata pid="39" name="Elf Maiden Play VICTORY" tags="nobr victory complete" position="66,1834" size="100,100">&lt;&lt;if hasVisited(&quot;Elf Maiden Sulk&quot;)&gt;&gt;
	&lt;&lt;set $karma += 1&gt;&gt;
	&lt;&lt;Status_Reset&gt;&gt;
	&lt;&lt;set $ElfMaidenBattleClear to true&gt;&gt;
	&lt;&lt;remember $ElfLoverEnding to true&gt;&gt;
	&lt;&lt;remember $ClearedDemo += 1&gt;&gt;

	Congratulations! You got the &quot;Elf Lover&quot; ending of this demo!
	Sex is its own reward.
	&lt;br&gt; &lt;br&gt;
	Thank you for playing! &lt;br&gt;
	Now go find the other good (and bad!) ends!
	
&lt;&lt;else&gt;&gt;
	&lt;&lt;Status_Reset&gt;&gt;
	&lt;&lt;set $ElfMaidenBattleClear to true&gt;&gt;
	&lt;&lt;remember $LoveAndLeaveEnding to true&gt;&gt;
	&lt;&lt;remember $ClearedDemo += 1&gt;&gt;
	
	Congratulations! You got the &quot;Love Her and Leave Her&quot; ending of this
	demo. Ya fuckboy. 
	&lt;br&gt; &lt;br&gt;
	Thank you for playing! &lt;br&gt;
	Now go find the other good (and bad) ends!
	
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="40" name="Items Initial" tags="widget" position="484,349" size="100,100">&lt;&lt;widget &quot;ItemInit&quot;&gt;&gt;

&lt;&lt;set UInv.CreateBag(&quot;inventory&quot;)&gt;&gt;
&lt;&lt;set UInv.AddItem(&quot;inventory&quot;, &quot;letter&quot;)&gt;&gt;
&lt;&lt;set UInv.AddItem(&quot;inventory&quot;, &quot;potion&quot;, 2)&gt;&gt;
&lt;&lt;set $g to 50&gt;&gt;

&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="41" name="Elf Maiden Pinned" tags="combat nobr complete" position="401,1807" size="100,100">&lt;&lt;if visited() is 1&gt;&gt;
	&lt;&lt;set $damage += 2&gt;&gt;

	Holding you pinned to the ground, Silvianna teasingly begins to
	grind her hips into yours. You gasp at the sensation,
	the feeling of her rubbing against your
	&lt;&lt;if not $pants&gt;&gt; bare &lt;&lt;else&gt;&gt; covered &lt;&lt;/if&gt;&gt; 
	crotch enough to make you squirm helplessly from the pleasure. 
	&lt;br&gt; &lt;br&gt;
	
	Her eyes lock with yours, a devious glint in their emerald depths.
	&quot;You&#39;re getting so hard for me~,&quot; she giggles. &quot;Mmm...does it feel 
	that good when I rub you?&quot;
	&lt;br&gt; &lt;br&gt;
	
	You bite your lip and hold back a moan, struggling desperately to
	avoid giving her an indication of just how much you&#39;re enjoying
	the feeling of her grind against your hardening
	&lt;&lt;if not $pants&gt;&gt; cock &lt;&lt;else&gt;&gt; bulge &lt;&lt;/if&gt;&gt;.
	&lt;br&gt; &lt;br&gt;
	
	You know you should try to push her off, but it feels so good...
	&lt;br&gt; &lt;br&gt;
	
	[[Struggle against her.-&gt;Elf Maiden Pinned Struggle]]
	&lt;br&gt;
	[[Let her grind against you.-&gt;Elf Maiden Pinned]] 
	
&lt;&lt;elseif $naked&gt;&gt;
	&lt;&lt;set $damage += 3&gt;&gt;
	
	Held firmly trapped underneath her, you&#39;re unable to resist as
	Silvianna leans down to capture your lips in a sweet, tender 
	kiss. She holds the contact for a few seconds, just savouring the
	pressure. Then, her tongue darts out to beg entrance into your 
	mouth. You feebly resist for a few seconds before at last
	submitting, letting her force open your lips and invade your mouth
	with her tongue.
	&lt;br&gt; &lt;br&gt;
	
	You can&#39;t help but moan into the kiss, letting her eager, violate
	your sensitive mouth. She grinds frantically against your bare
	cock, sliding the tending dripping folds of her pussy along your
	length.
	&lt;br&gt; &lt;br&gt;
	
	At last, she breaks the kiss, leaving you gasping for air, but at 
	the same time longing for her to kiss you again. You gaze up 
	at you, your eyes glazed over in pleasure and thoughts dyed pink
	from the pleasure of her embrace. 
	&lt;br&gt; &lt;br&gt;
	
	Silvianna pants deeply, her cheeks flushed and eyes burning with
	lust, &quot;Your cock feels so //good//, darling. I want more. I want
	it inside me. I want to fill me up.&quot;
	&lt;br&gt; &lt;br&gt;
	
	Her words send a shiver through you. If you don&#39;t resist her know,
	you might not be able to at all. But it would feel so good to just
	give in...
	
	[[Struggle against her.-&gt;Elf Maiden Pinned Struggle]]
	&lt;br&gt;
	[[Let her take you in...-&gt;Elf Maiden Cowgirl]] 
	
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $damage += 3&gt;&gt;
	
	Held firmly trapped underneath her, you&#39;re unable to resist as
	Silvianna leans down to capture your lips in a sweet, tender 
	kiss. She holds the contact for a few seconds, just savouring the
	pressure. Then, her tongue darts out to beg entrance into your 
	mouth. You feebly resist for a few seconds before at last
	submitting, letting her force open your lips and invade your mouth
	with her tongue.
	&lt;br&gt; &lt;br&gt;
	
	You can&#39;t help but moan into the kiss, letting her eager, violate
	your sensitive mouth. She grinds frantically against your bulge,
	the sensation making you trapped and constrained within your pants.
	&lt;br&gt; &lt;br&gt;
	
	At last, she breaks the kiss, leaving you gasping for air, but at 
	the same time longing for her to kiss you again. You gaze up 
	at you, your eyes glazed over in pleasure and thoughts dyed pink
	from the pleasure of her embrace. 
	&lt;br&gt; &lt;br&gt;
	
	Silvianna pants deeply, her cheeks flushed and eyes burning with
	lust, &quot;I want more, darling. I want to //fuck// you.&quot;
	&lt;br&gt; &lt;br&gt;
	
	Her words send a shiver through you. If you don&#39;t resist her know,
	you might not be able to at all. But it would feel so good to just
	give in...
	
	[[Struggle against her.-&gt;Elf Maiden Pinned Struggle]]
	&lt;br&gt;
	[[Let her take you in...-&gt;Elf Maiden Cowgirl]] 
	
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="42" name="Elf Maiden Refuse Play" tags="combat complete" position="898,1556" size="100,100">You shake your head. There&#39;s no way you can agree to that. Even if she doesn&#39;t seem to have ill-intent, she&#39;s a monster girl, and doing that sort of a thing with a monster is the surest way for an adventurer to meet their end.

&quot;That&#39;s not something I can do,&quot; you say.

Silvianna&#39;s smile turns to a frown. You can tell she&#39;s angry, but her full, pouty lips and innocent eyes just make her look more adorable, &quot;Hmph! And I thought you were nice.&quot;\

&lt;&lt;set $ElfMood -= 1&gt;&gt;\

&quot;Er, maybe we can work something else out?&quot; you offer.

The elf maiden completely ignores your words, instead approaching you as her frown turns into a smile once again...this one far more sinister than before, &quot;If you don&#39;t want to play...I&#39;ll just have to make you want it!&quot;

You back away slowly, &quot;H-hey, surely we can still talk about this-&quot;

&quot;Talking is boring,&quot; Silvianna stalks closer to you. &quot;Let&#39;s have some fun!&quot;

Looks like there&#39;s no other way. Despite her innocent appearance, this girl really is a predator at the core. 

You prepare yourself to [[fight-&gt;Elf Maiden Fight]].
</tw-passagedata><tw-passagedata pid="43" name="Elf Maiden Fight" tags="combat nobr complete" position="804,1723" size="100,100">&lt;&lt;if $MonsterStatus is &quot;anger&quot;&gt;&gt;
	You can practically feel an aura of anger radiating from her. This
	could be dangerous...
	&lt;br&gt; &lt;br&gt;

&lt;&lt;elseif $MonsterStatus is &quot;tripped&quot;&gt;&gt;
	She&#39;s on the ground, trying to recover. Now&#39;s your chance!
	&lt;br&gt; &lt;br&gt;

&lt;&lt;else&gt;&gt;
	You&#39;ve got a chance to act now.
	&lt;br&gt; &lt;br&gt;
&lt;&lt;/if&gt;&gt;

What should you do?
&lt;br&gt; &lt;br&gt;

[[Attack!-&gt;Elf Maiden Attack]]
&lt;br&gt;
[[Make your escape!-&gt;Elf Maiden Escape]]
&lt;br&gt;
&lt;&lt;if not UInv.BagHasItem(&quot;inventory&quot;, &quot;Moondrop Flower&quot;)&gt;&gt;
	[[Go for the flower!-&gt;Elf Maiden Flower Grab]]
	&lt;br&gt;
&lt;&lt;/if&gt;&gt;
[[Wait and see what she does...-&gt;Elf Maiden Wait]]
</tw-passagedata><tw-passagedata pid="44" name="TEST" tags="nobr" position="1401,246" size="100,100">&lt;&lt;set $checkAgainst to 6&gt;&gt;
&lt;&lt;set _mod to 1&gt;&gt;

&lt;&lt;linkreplace &quot;Check Stat&quot;&gt;&gt;
	&lt;&lt;Stat_Check&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;</tw-passagedata><tw-passagedata pid="45" name="Start" tags="nobr" position="1045,441" size="100,100">&lt;&lt;if $ClearedDemo &gt; 0 &gt;&gt;
	Welcome back! You&#39;ve cleared this demo &lt;&lt;print $ClearedDemo&gt;&gt;
	times! To see the endings you&#39;ve unlocked so far, go to the
	Inventory and click on the Ending List.
	&lt;br&gt; &lt;br&gt;
	Now then, let&#39;s get started!
&lt;&lt;else&gt;&gt;
	Welcome to this world of monsters. A place beyond your wildest 		dreams... or your darkest nightmares!
&lt;&lt;/if&gt;&gt;

&lt;br&gt; &lt;br&gt;
What is your name? 

&lt;&lt;textbox &quot;$name&quot; &quot;Hero&quot;  autofocus&gt;&gt;
&lt;&lt;button &quot;Enter&quot;&gt;&gt;
	&lt;&lt;replace &quot;#name&quot;&gt;&gt;
		$name, you have been chosen.
		&lt;br&gt; &lt;br&gt;
		
		Now, would you like to:
		&lt;br&gt; &lt;br&gt;
		
		[[Customize your character-&gt;Choose Strength]]
		&lt;br&gt;
		[[Begin your adventure.-&gt;Begin Adventure]]
		
	&lt;&lt;/replace&gt;&gt;
&lt;&lt;/button&gt;&gt;

&lt;br&gt; &lt;br&gt;
&lt;span id=&quot;name&quot;&gt;

&lt;/span&gt;</tw-passagedata><tw-passagedata pid="46" name="Status Screen Widgets" tags="widget nobr" position="229,473" size="100,100">&lt;&lt;widget &quot;Stats_Description&quot;&gt;&gt;
	&lt;&lt;Strength_Description&gt;&gt; &lt;br&gt;
	&lt;&lt;Dexterity_Description&gt;&gt; &lt;br&gt;
	&lt;&lt;Intelligence_Description&gt;&gt; &lt;br&gt;
	&lt;&lt;Resistance_Description&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;Strength_Description&quot;&gt;&gt;
	&lt;&lt;if $str is 3&gt;&gt;
		You&#39;re weak as a child, easy prey for even the most harmless
		of monsters.
	&lt;&lt;elseif $str is 4&gt;&gt;
		You have below average strength. Be wary of getting into 
		tussles.
	&lt;&lt;elseif $str is 5&gt;&gt;
		You have average strength, though you&#39;re still weaker than many
		monster girls.
	&lt;&lt;elseif $str is 6&gt;&gt;
		You have above average strength. You fit enough to fight off
		most weak monster girls. Just don&#39;t wrestle with minotaurs.
	&lt;&lt;elseif $str is 7&gt;&gt;
		You&#39;re quite strong, and have noticed ladies giving your
		muscles admiring looks. You&#39;re certainly strong enough to 
		handle most monsters you&#39;ll meet.
	&lt;&lt;elseif $str is 8&gt;&gt;
		Ladies gaze upon your muscles with lust and men with envy.
		You&#39;re stronger even than most monsters.
	&lt;&lt;elseif $str is 9&gt;&gt;
		You&#39;re basically a mountain of pure muscle, easily near the
		peak of human strength. You should have no problem fighting
		off all but the strongest of monsters.
	&lt;&lt;elseif $str is 10&gt;&gt;
		Your strength is godlike, letting you pull off feats of legend.
		However, some monsters may be stronger still...
	&lt;&lt;else&gt;&gt;
		You strength is whack, yo.
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;Dexterity_Description&quot;&gt;&gt;
	&lt;&lt;if $dex is 3&gt;&gt;
		You&#39;re incredibly clumsy, and often trip over your own feet.
		You&#39;d have trouble running from even the slowest of monster
		girls.
	&lt;&lt;elseif $dex is 4&gt;&gt;
		Slower and clumsier than the average adventurer, you&#39;re prone
		to getting into trouble. Most monster girls will easily be
		able to catch you.
	&lt;&lt;elseif $dex is 5&gt;&gt;
		Your neither fast, nor slow. Neither skilled, nor unskilled.
		You basically scream &quot;average&quot;. You may be able to handle
		slower or clumsier monster girls.
	&lt;&lt;elseif $dex is 6&gt;&gt;
		You&#39;re fairly confident in your skills and body control.
		You should be able to escape from the average monster girl.
	&lt;&lt;elseif $dex is 7&gt;&gt;
		Far swifter and dextrous than the average adventurer, your
		skill is enough to handle most monsters you&#39;ll meet.
	&lt;&lt;elseif $dex is 8&gt;&gt;
		With a dancer&#39;s grace and a pianists dexterity, you could awe
		entire crowds with your feats. Few monsters could capture one
		as swift as you.
	&lt;&lt;elseif $dex is 9&gt;&gt;
		Your grace and skill are unparalelled, letting you trick, evade
		and escape from all but the most dangerous of monsters.
	&lt;&lt;elseif $dex is 10&gt;&gt;
		With blinding swiftness of foot and deftness of hand, your
		skills would be the envy of the gods themselves. Even that may
		not be enough to escape from some monsters however...
	&lt;&lt;else&gt;&gt;
		You dex is whack, yo.
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;Intelligence_Description&quot;&gt;&gt;
	&lt;&lt;if $int is 3&gt;&gt;
		You&#39;re dumb as rocks. It&#39;s a wonder you can tie your own shoes.
	&lt;&lt;elseif $int is 4&gt;&gt;
		You&#39;re decidedly below average intelligence. You&#39;ll fall for
		even obvious tricks and traps.
	&lt;&lt;elseif $int is 5&gt;&gt;
		You&#39;re of about average intelligence. You&#39;re not dumb, but 
		less obvious solutions will likely go over your head.
	&lt;&lt;elseif $int is 6&gt;&gt;
		Your intuition and cunning are above average. You can see
		through most tricks and certainly notice things others won&#39;t.
	&lt;&lt;elseif $int is 7&gt;&gt;
		Your wit and intellect are enough to deceive or pursuade most
		monster girls to your ends.
	&lt;&lt;elseif $int is 8&gt;&gt;
		Your mind dances circles around others&#39;, and your silver
		tongue can charm even the most stone-hearted. In a battle of
		wits or words, you&#39;re sure to come on top against all but the
		most keen of mind.
	&lt;&lt;elseif $int is 9&gt;&gt;
		If intelligence is the new sexy, then you&#39;re a god of lust. 
		Nothing escapes your penetrating mind and your words have the
		power to bend others to your will.
	&lt;&lt;elseif $int is 10&gt;&gt;
		Your genius is so vast, even the deepest mysteries of the
		universe are within your reach. Some monsters might outmatch
		even your enlightened mind, however...
	&lt;&lt;else&gt;&gt;
		Ooooh, you smart.
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;Resistance_Description&quot;&gt;&gt;
	&lt;&lt;if $res is 3&gt;&gt;
		Your will is weak enough that even the most banal of monsters
		could break it. Why did you think fighting sex monsters was a
		good idea?
	&lt;&lt;elseif $res is 4&gt;&gt;
		Your will is weak and pliable, making you easy prey for the
		kind of monsters that stalk this world...
	&lt;&lt;elseif $res is 5&gt;&gt;
		You have average resistance to monsters&#39; temptation. Hopefully
		that will be enough to survive in a world like this...
	&lt;&lt;elseif $res is 6&gt;&gt;
		Your will is more than enough to resist the temptations
		of weak monsters, though you should still be wary of what
		the stronger and more seductive demons could do to you...
	&lt;&lt;elseif $res is 7&gt;&gt;
		You have a mastery of your lust that few can match. Your will 
		is enough to withstand most monsters, though you should still
		take caution against the charms of the most alluring 
		temptresses.
	&lt;&lt;elseif $res is 8&gt;&gt;
		You&#39;re strong enough to resist nearly any earthly temptation.
		If only the unearthly weren&#39;t so common among monsters...
	&lt;&lt;elseif $res is 9&gt;&gt;
		Monsters&#39; temptation is no match for your iron will. Only the
		most seductive of temptations could even hope to shake you.
	&lt;&lt;elseif $res is 10&gt;&gt;
		Even the most enlightened of saints
		would take inspiration from the
		strength of your will. However, even a will as strong as 
		yours may not be enough against the temptations of the
		darkest of monsters...
	&lt;&lt;else&gt;&gt;
		VIVA LA RESISTANCE!
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/widget&gt;&gt;

&lt;&lt;widget &quot;Stats_Display&quot;&gt;&gt;
	&lt;table style=&quot;width:20%&quot;&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:left&quot;&gt;Strength:&lt;/td&gt;
			&lt;td style=&quot;text-align:right&quot;&gt;$str&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:left&quot;&gt;Dexterity:&lt;/td&gt;
			&lt;td style=&quot;text-align:right&quot;&gt;$dex&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:left&quot;&gt;Intelligence:&lt;/td&gt;
			&lt;td style=&quot;text-align:right&quot;&gt;$int&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td style=&quot;text-align:left&quot;&gt;Resistance:&lt;/td&gt;
			&lt;td style=&quot;text-align:right&quot;&gt;$res&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="47" name="Status Screen" tags="nobr noreturn widget" position="98,471" size="100,100">&lt;&lt;widget &quot;StatusScreen&quot;&gt;&gt;

	&lt;hr&gt;

	&lt;&lt;Stats_Description&gt;&gt;

	&lt;br&gt;
	
	&lt;hr&gt;
	
&lt;&lt;/widget&gt;&gt;</tw-passagedata><tw-passagedata pid="48" name="StoryAuthor" tags="nobr" position="226,100" size="100,100">&lt;&lt;silently&gt;&gt;
	Literally just here if I want to adjust spacing in the sidebar lol
&lt;&lt;/silently&gt;&gt;
</tw-passagedata><tw-passagedata pid="49" name="Forest" tags="nobr save" position="1193,801" size="100,100">You walk through the forest. It&#39;s a bight, sunny day. Happy flowers are blooming. Seems like a great day to get fucked in the woods. &lt;br&gt; &lt;br&gt;

You come to a fork in the road.
&lt;&lt;if hasVisited(&quot;Elf Clearing 01&quot;)&gt;&gt;
	The path on the right leads back to the clearing where you
	found the Moondrop Flower.
&lt;&lt;else&gt;&gt;\
	The path on the right seems to lead deeper into the forest.
	You can see signs that someone has been down that path recently...
&lt;&lt;/if&gt;&gt;
&lt;&lt;if visited(&quot;Alraune Garden&quot;) &gt; 0&gt;&gt;
	The path on the left leads back to the Alraune&#39;s garden.
&lt;&lt;else&gt;&gt;
	The path on the left seems to lead away to the west. There&#39;a a
	strange scent wafting from the path. A sweet scent like flowers...
&lt;&lt;/if&gt;&gt;
&lt;br&gt; &lt;br&gt;

Which will you choose? &lt;br&gt; &lt;br&gt;

&lt;&lt;if hasVisited(&quot;Elf Clearing 01&quot;)&gt;&gt; 
	[[Go to the Moondrop Clearing-&gt;Elf Clearing 01]]
&lt;&lt;else&gt;&gt;
	[[Take the right path.-&gt;Elf Clearing 01]]
&lt;&lt;/if&gt;&gt;
&lt;br&gt;
&lt;&lt;linkappend &quot;Go back.&quot;&gt;&gt;

	You decide to turn back. Except you don&#39;t,
	because you&#39;re not a pussy. Pick a path, dammit.
&lt;&lt;/linkappend&gt;&gt;</tw-passagedata><tw-passagedata pid="50" name="Elf Maiden Embrace" tags="combat nobr complete" position="1097,1873" size="100,100">&lt;&lt;if not $naked and visited() is 1&gt;&gt;
	&lt;&lt;set $damage += 2&gt;&gt;
	
	Silvianna giggles and squeezes you a bit tighter, her lips
	pressing soft kisses against your ear.
	&lt;br&gt; &lt;br&gt;
	
	&quot;Isn&#39;t this nice?&quot; she whispers. &quot;Mmm...you&#39;re nice and warm.
	Hugging like this feels good, doesn&#39;t it?&quot;
	&lt;br&gt; &lt;br&gt;
	
	Well, you can&#39;t deny it //does// feel kind of nice, but this
	is still dangerous. 	
	Right now, she&#39;s
	doing little more than teasing you, but if you let her continue
	it could become problematic very, very quickly.&lt;br&gt; &lt;br&gt;
	
	What should you do? &lt;br&gt; &lt;br&gt;
	
	[[Let her embrace you...-&gt;Elf Maiden Embrace]]
	&lt;br&gt;
	[[Struggle against her-&gt;Elf Maiden Embrace Struggle]] 
	
&lt;&lt;elseif $hp &lt; 3&gt;&gt;
	&lt;&lt;set $hp to 0&gt;&gt;
		
	Sensing your submission, Silvianna redoubles her pace, her hand
	pumping furiously at your cock. You give yourself completely to 
	her rhythm, your hips thrust frantically into her hand, every
	stroke bringing you closer to the release you seek. 
	&lt;br&gt; &lt;br&gt;
	
	&quot;Oh...oh yes! That&#39;s it, baby!&quot; she urges you on. &quot;Cum for me!
	Cum for me, darling!&quot;
	&lt;br&gt; &lt;br&gt;
	
	You&#39;re only too happy to give into to her sweet words and embrace
	the pleasure filling your mind. Your seed spills out in thick
	white ropes, spraying onto the forest floor as her hand continues
	to pump orgasmic pleasure into you.
	&lt;br&gt; &lt;br&gt;
	
	Silvianna doesn&#39;t let up for a second, making sure to drain you
	of every last drop of your seed. When she&#39;s finished, you&#39;re so
	drained of pleasure you can barely stand. Your mind swirls in
	delirious bliss. 
	&lt;br&gt; &lt;br&gt;
	
	You know there&#39;s no coming back now. You&#39;ve completely
	[[submitted to her pleasure-&gt;Elf Maiden Handjob Finish]].
	
&lt;&lt;elseif $naked&gt;&gt;
	&lt;&lt;set $damage += 3&gt;&gt;
	
	Her hand glides along your shaft, the smooth friction of her palm
	bringing pleasure with every stroke. Her slow, gentle handjob
	drains away your resistance, leaving you compliant and submissive
	in her arms, so drunk on pleasure that you&#39;re content to let her
	play with you to her heart&#39;s content. 
	&lt;br&gt; &lt;br&gt;
	
	&quot;You have such a nice cock,&quot; she giggles. &quot;And you&#39;re so thick and
	hard for me~.&quot; She presses a gentle kiss to your cheek. &quot;This is
	soooo much better than trying to struggle, isn&#39;t it?&quot;
	&lt;br&gt; &lt;br&gt;
	
	You nod dumbly, barely registering her question amidst the
	sea of bliss you&#39;re floating in.
	&lt;br&gt; &lt;br&gt;
	
	&quot;That&#39;s right,&quot; she continues. &quot;There&#39;s no need to fight back. Just
	let me play with you...&quot;
	&lt;br&gt; &lt;br&gt;
	
	You&#39;re longing for nothing mroe to do exactly what she asks, but
	a part of you is still holding back, whispering that if you give in
	now, there&#39;s no coming back...
	&lt;br&gt; &lt;br&gt;
	
	[[Give in to her...-&gt;Elf Maiden Embrace]] 
	&lt;br&gt;
	[[You have to fight back...-&gt;Elf Maiden Embrace Struggle]]
	
&lt;&lt;elseif not $shirt&gt;&gt;
	&lt;&lt;set $damage += 2&gt;&gt;
	
	Silvianna slowly explores your chest, her slender fingers tracing
	the lines of your muscles. She gives a soft giggle of approval
	and nestles closer against you. &lt;br&gt; &lt;br&gt;
	
	&quot;You have a nice chest,&quot; she says. &quot;Mmm...and nice broad shoulders.
	I found myself a really handsome toy~.&quot;
	&lt;br&gt; &lt;br&gt;
	
	Your face flushes a deep red, though you&#39;re not quite sure whether
	in embarassment and nervousness at her
	calling you her &quot;toy&quot; or in pleasure from her compliments. This is
	really, really dangerous. Your head is getting fuzzy with each kiss
	against your neck, and her touch seems to arouse you more and more
	with every teasing caress. &lt;br&gt; &lt;br&gt;
	
	And then, her hands find their way to your pants. Before you can
	stop her, she yanks down, baring your aching erection to the world.
	&lt;br&gt; &lt;br&gt;
	
	That shocks you out of your blissful reverie. You&#39;re in trouble
	now. You let your guard down, and now she has you completely 
	naked. If you don&#39;t struggle now, there might not be any going
	back... &lt;br&gt; &lt;br&gt;
	
	&lt;&lt;set $naked to true&gt;&gt;
	
	
	[[Maybe a little longer wouldn&#39;t hurt...-&gt;Elf Maiden Embrace]]&lt;br&gt;
	[[Get away from her!-&gt;Elf Maiden Embrace Struggle]] 
	
	
&lt;&lt;else&gt;&gt;
	&lt;&lt;set $damage += 2&gt;&gt;
	
	Silvianna snuggles closer, the swell of her breasts present against
	your back. Her breath is hot in your ear, her lips burning your
	skin with every kiss she presses to your neck. &lt;br&gt; &lt;br&gt;
	
	&quot;Mmm.... //*kiss*// //*kiss*// Oh... //*kiss*// I want to feel you
	more,&quot; she whispers, her pleading voice thick with a lust that
	sends a shiver running through you. &lt;br&gt; &lt;br&gt;
	
	Her hands slip under your shirt and begin to snake their way up
	your chest. You squirm in her grasp, but despite your struggles
	it doesn&#39;t take her long to tear your shirt away and cast it aside.
	&lt;br&gt; &lt;br&gt;
	
	You flinch as her smooth arms curl around your bare chest. This
	is rapidly getting more dangerous. Though you may have an
	opportunity now that she&#39;s more concerned with giggling as she
	feels your muscles than actually holding onto you...
	&lt;br&gt; &lt;br&gt;
	
	&lt;&lt;set $shirt to false&gt;&gt;
	
	[[Stay in her embrace.-&gt;Elf Maiden Embrace]] 
	&lt;br&gt;
	[[Try to struggle free.-&gt;Elf Maiden Embrace Struggle]]
	
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="51" name="Elf Maiden Pinned Struggle" tags="combat complete nobr" position="614,1750" size="100,100">You try to free yourself from where she has you pinned...

&lt;&lt;set _mod to $struggle&gt;&gt;
&lt;&lt;set $checkStat to &quot;str&quot;&gt;&gt;
&lt;&lt;set $checkAgainst to 7&gt;&gt;
&lt;&lt;set $ElfMood -= 1&gt;&gt;

&lt;br&gt; &lt;br&gt;

&lt;&lt;linkreplace &quot;Struggle&quot;&gt;&gt;
	&lt;&lt;Stat_Check&gt;&gt;
	
	&lt;&lt;if _checkPass&gt;&gt;
		You struggle with all your might, and with a burst of strength
		you manage to throw her off of you!
		
		&quot;Ah!&quot; she screams in surprise &quot;H-hey! Don&#39;t struggle!&quot;
		
		Ignoring her words, you scramble to your feet. You managed to
		get away from her. Now,	it&#39;s time to
		[[fight-&gt;Elf Maiden Fight]]
		back!
		
	&lt;&lt;else&gt;&gt;
		&lt;&lt;if $will lte 5&gt;&gt;
			But as you try to struggle, she pushes her hips down to 
			grind against yours. You mean deeply as her hips roll
			against your aching erection, so aroused by the pressure
			of her body on your own that all your strength
			disappears. &lt;br&gt; &lt;br&gt;
			
			She moans as she rubs against you, her motions becoming
			more and more frantic, &quot;Oh...oh goddess...I want your
			cock so bad!&quot; &lt;br&gt; &lt;br&gt;
			
			She
			&lt;&lt;if not $naked&gt;&gt;
				practically rips your pants away, leaving you 
				completely vulnerable to her. Licking her lips,
				she
			&lt;&lt;/if&gt;&gt;
			stares hungrily at your erect, throbbing cock and 
			positions herself over you, legs spread and ready
			to receive you.			
			
			&lt;br&gt; &lt;br&gt;
			&lt;&lt;set $struggle += 1&gt;&gt;
			
			Unable to escape, you let your muscles go slack as she
			slowly descends and
			[[takes you inside-&gt;Elf Maiden Cowgirl]]
			her.
			
			&lt;&lt;set $cowgirl to true&gt;&gt;
			
		&lt;&lt;else&gt;&gt;
			But as you try to struggle, she dives down and traps you
			in a sweet, intoxicating kiss that drains away 
			your strength to nothing. &lt;br&gt; &lt;br&gt;
			
			She takes a moment to savour the kiss, letting her 
			tongue entwine with yours. When she at last pulls away,
			a long string of saliva still connects her mouth to yours.
			&lt;br&gt; &lt;br&gt;
			
			&quot;I won&#39;t let you go,&quot; she whispers, her eyes burning with
			lust as she looks down on you.
			
			&lt;br&gt; &lt;br&gt;
			&lt;&lt;set $struggle += 1&gt;&gt;
			
			Unable to escape, you relax and let her 
			[[continue-&gt;Elf Maiden Pinned]] to have her way 
			with you...
		
		&lt;&lt;/if&gt;&gt;		
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;</tw-passagedata><tw-passagedata pid="52" name="Elf Maiden Embrace Struggle" tags="combat nobr complete" position="1011,1746" size="100,100">You struggle to break free from &lt;&lt;print either(&quot;her sweet embrace&quot;, &quot;her smooth arms curled around you&quot;, &quot;her snug embrace&quot;)&gt;&gt;... &lt;br&gt; &lt;br&gt;

&lt;&lt;set _mod to $struggle&gt;&gt;
&lt;&lt;set $checkStat to &quot;str&quot;&gt;&gt;
&lt;&lt;set $checkAgainst to 7&gt;&gt;
&lt;&lt;set $ElfMood -= 1&gt;&gt;

&lt;&lt;linkreplace &quot;Struggle&quot;&gt;&gt;
	&lt;&lt;Stat_Check&gt;&gt;
	
	&lt;&lt;if _checkPass&gt;&gt;
		And you manage to break away! &lt;br&gt; &lt;br&gt;
		
		&quot;Ah! Hey!&quot; She exclaims as you push her away. &quot;Come on, didn&#39;t
		you like my hug? I&#39;m not done feeling you.&quot; &lt;br&gt; &lt;br&gt;
		
		You shake your head as she opens her arms up to offer another
		embrace. At your rejection, her frown deepens. &lt;br&gt; &lt;br&gt;
		
		&quot;Fine then,&quot; she snarls. &quot;If you want to fight back, //then//
		//let&#39;s fight//! &lt;br&gt; &lt;br&gt;
		
		&lt;&lt;set $struggle to 0&gt;&gt;
		Her words send chills down your spine, but you push
		aside your fear and prepare your
		[[next move-&gt;Elf Maiden Fight]].

	&lt;&lt;else&gt;&gt;
		&lt;&lt;if $hp lte 2&gt;&gt;
			But the promise of release is just too much to bear.
			You&#39;re so enamored with her touch that you can&#39;t
			bear to pull away. &lt;br&gt; &lt;br&gt;
			
			Moaning deeply, you submit to her touch and let her
			[[finish you-&gt;Elf Maiden Embrace]]. 
			&lt;br&gt; &lt;br&gt;
		
		&lt;&lt;elseif $naked&gt;&gt;
			But as she gentle strokes your cock, you can&#39;t bring
			yourself to pull away. &lt;br&gt; &lt;br&gt;
			
			She giggles in your ear as you relax into her embrace,
			&quot;That&#39;s right, darling, just let me stroke you. Up and
			down...up and down...&quot; &lt;br&gt; &lt;br&gt;
			
			You groan in pleasure as her smoothly pumping palm sends
			pleasure pulsing through you. &lt;br&gt; &lt;br&gt;
			
			Unable to resist, you melt into her embrace and let her
			[[stroke you-&gt;Elf Maiden Embrace]]. 
			
		&lt;&lt;elseif not $pants&gt;&gt;
			But as you try to pull away, she wraps her hand around
			your cock and gives firm but gentle squeeze, and you
			find yourself unable to break away. &lt;br&gt; &lt;br&gt;
			
			&quot;Don&#39;t leave now,&quot; she breathes, her soft, lust-filled 
			voice sending tingles down your spine. &quot;We&#39;re just
			getting to the good part.&quot; &lt;br&gt; &lt;br&gt;
			
			You gasp as her hand lovingly strokes your thick, hardened
			cock. Unable to escape, you can&#39;t do anything excep
			relax and
			[[accept her embrace-&gt;Elf Maiden Embrace]]. 
			
		&lt;&lt;elseif not $shirt&gt;&gt;
			But Silvianna clings too tightly for you to escape!
			&lt;br&gt; &lt;br&gt;
			
			&quot;Don&#39;t struggle,&quot; she pleads. &quot;Doesn&#39;t it feel good to
			be hugged?&quot; &lt;br&gt; &lt;br&gt;
			
			You gasp as she snuggles closer against you, the tightness
			of her breasts pressing against your back. She teases your
			nipples and plants soft kisses on your neck. &lt;br&gt; &lt;br&gt;
			
			&quot;Just let me hold you a little longer,&quot; she says. &lt;br&gt; &lt;br&gt;
			
			Despite yourself, you can&#39;t help but submit to her words,
			relaxing back into 
			[[her soft embrace-&gt;Elf Maiden Embrace]].
			
		&lt;&lt;else&gt;&gt;
			But as you try to struggle, she ony clings tighter to
			you. You can&#39;t break free of her smooth arms. &lt;br&gt; &lt;br&gt;
			
			&quot;Don&#39;t go away,&quot; she says, nuzzling against your neck.
			&quot;I promise I&#39;ll make you feel good.&quot; &lt;br&gt; &lt;br&gt;
			
			She presses soft kisses against your neck, leading up to
			your cheek. Even as you squirm, you can&#39;t deny how good
			her lips feel on your skin, each kiss burning like a 
			sweet brand against you. &lt;br&gt; &lt;br&gt;
			
			You can&#39;t help but submit to
			[[her embrace-&gt;Elf Maiden Embrace]] 
			for just a little longer...
			
		&lt;&lt;/if&gt;&gt;
		
		&lt;&lt;set $struggle += 1&gt;&gt;
	
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;</tw-passagedata><tw-passagedata pid="53" name="Elf Maiden Attack" tags="combat nobr complete" position="779,1951" size="100,100">It&#39;s time to attack! You raise your staff up and swing with a wild yell!
&lt;br&gt; &lt;br&gt;

&lt;&lt;set $checkStat to &quot;dex&quot;&gt;&gt;
&lt;&lt;set $checkAgainst to 6&gt;&gt;
&lt;&lt;set $ElfMood -= 1&gt;&gt;

&lt;&lt;linkreplace &quot;Strike&quot;&gt;&gt;
	&lt;&lt;Stat_Check&gt;&gt;
	
	&lt;&lt;if $MonsterStatus is &quot;anger&quot;&gt;&gt;
		But before you can attack, Silvianna charges forward and slams
		into you! Your staff flies out of your hands as she tackles you
		to the ground, pinning you down and looking down at you with
		wicked grin. &lt;br&gt; &lt;br&gt;
		
		&quot;There&#39;s no escape now, darling,&quot; she says. &quot;I&#39;m going to 
		have my way with you...&quot; &lt;br&gt; &lt;br&gt;
		
		&lt;&lt;set $MonsterStatus to &quot;normal&quot;&gt;&gt;
		
		This is bad. She&#39;s got you completely 
		[[pinned-&gt;Elf Maiden Pinned]] and at her mercy...
	
	&lt;&lt;elseif _checkPass&gt;&gt;
		She tries to dodge, but you&#39;re too quick for her, and your
		staff connects with her body. It&#39;s only a glancing blow, but
		it&#39;s enough to stagger her. She won&#39;t be able to dodge a
		follow up! &lt;br&gt; &lt;br&gt; 
		
		&lt;&lt;set $checkStat to &quot;str&quot;&gt;&gt;
		&lt;&lt;set $checkAgainst to 6&gt;&gt;
		
		&lt;&lt;linkreplace &quot;Strike Again!&quot;	
			&lt;&lt;Stat_Check&gt;&gt;
				&lt;&lt;if _checkPass&gt;&gt;
					You swing for her head with all your might...
					&lt;br&gt; &lt;br&gt;
					
					At the last second, she raises her arms to block,
					but your strike is too strong. Your staff
					slams against her head, sending her to the
					ground with a cry of pain. &lt;br&gt; &lt;br&gt;
					
					She lays on the forest floor, clutching her head
					and sobbing pitifully. You feel a twinge of 
					pity, but you push it aside. You did what
					needed to be done. &lt;br&gt; &lt;br&gt;
					
					You have a chance to act now...as long as you
					don&#39;t waste it. &lt;br&gt; &lt;br&gt;
					
					&lt;&lt;set $MonsterStatus to &quot;stunned&quot;&gt;&gt;
					
					[[Continue-&gt;Elf Maiden Fight]]
					
				&lt;&lt;else&gt;&gt;
					You swing for her head... &lt;br&gt; &lt;br&gt;
					
					But just before your strike connects, she throws
					up her hands and catches your staff in midair!
					&lt;br&gt; &lt;br&gt;
					
					You freeze, too shocked that she was able to
					catch your strike to move. &lt;br&gt; &lt;br&gt;
					
					&quot;Whew, that was close,&quot; she says, her smile slowly
					returning. &quot;You&#39;re not bad for a human! Still too
					weak to fight off an elf though~. &lt;br&gt; &lt;br&gt;
					
					In an instant, she yanks your staff away and tosses
					it carelessly over her shoulder. Shit. You were
					so close, but now you don&#39;t even have a weapon 
					anymore. You grit your teeth and back away, trying
					to put distance between you before her inevitable
					counterattack. &lt;br&gt; &lt;br&gt;
					
					Sure enough, she quickly
					[[charges forward-&gt;Elf Maiden Tackle]]
					to attack!
					
					&lt;&lt;set $weapon to false&gt;&gt;
					
				&lt;&lt;/if&gt;&gt;
		&lt;&lt;/linkreplace&gt;&gt;
		
	&lt;&lt;else&gt;&gt;
		But Silvianna dodges to the side, and your attack sails by her
		harmlessly! &lt;br&gt; &lt;br&gt;
		
		With a laugh, she slaps your staff out of your hands, sending
		it rolling away, &quot;Come on, clumsy humans like you couldn&#39;t
		hope to hit a graceful wood elf like me!&quot;
		&lt;br&gt; &lt;br&gt;
		
		You grit your teeth and back away, trying to put distance
		between you before
		her inevitable counterattack. &lt;br&gt; &lt;br&gt;
		
		Sure enough, she quickly [[charges forward-&gt;Elf Maiden Tackle]]
		to attack!
		
		&lt;&lt;set $weapon to false&gt;&gt;
		
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;</tw-passagedata><tw-passagedata pid="54" name="Elf Maiden Escape" tags="combat nobr complete" position="920,1904" size="100,100">&lt;&lt;if UInv.BagHasItem(&quot;inventory&quot;, &quot;Moondrop Flower&quot;)&gt;&gt;
	You got the flower. Time to get out of here.
	&lt;&lt;if $MonsterStatus is &quot;anger&quot;&gt;&gt; Especially given how angry she looks... &lt;&lt;/if&gt;&gt;
	&lt;br&gt; &lt;br&gt;
	
	You turn around and run back into the forest.
	&lt;br&gt; &lt;br&gt;
	
	&lt;&lt;set _mod to $escape&gt;&gt;
	&lt;&lt;set $checkStat to &quot;dex&quot;&gt;&gt;
		
	&lt;&lt;if $MonsterStatus is &quot;stunned&quot; or $MonsterStatus is &quot;tripped&quot;&gt;&gt;
		&lt;&lt;set $checkAgainst to 4&gt;&gt;
	&lt;&lt;else&gt;&gt;
		&lt;&lt;set $checkAgainst to 6&gt;&gt;
	&lt;&lt;/if&gt;&gt;

	&lt;&lt;set $ElfMood -= 1&gt;&gt;

	&lt;&lt;linkreplace &quot;Escape&quot;&gt;&gt;
		&lt;&lt;Stat_Check&gt;&gt;
	
		&lt;&lt;if _checkPass
			&lt;&lt;set $escape to 0&gt;&gt;
			
			&quot;Hey, come back!&quot; Silvianna calls after you. &lt;br&gt; &lt;br&gt;
		
			You ignore her voice and run faster, adrenaline giving you
			the speed even to outrun the elf maiden pursuing you.
			&lt;br&gt; &lt;br&gt;
			
			You dash through the forest, and eventually her voice fades 			into the distance, and you finally slow down, panting
			heavily, both in exertion and relief.
			It was close, but you managed
			to [[escape-&gt;Elf Maiden Escape Success]].
		
		&lt;&lt;else&gt;&gt;
			&lt;&lt;set $escape += 1&gt;&gt;
			But as you reach the edge of the clearing,
			your foot catches
			on a tree root, sending you stumbling to the ground!
			&lt;br&gt; &lt;br&gt;
		
			You quickly catch yourself
			and scramble back to your feet, but
			in the next instant,
			you feel an impact agasint your back and
			a pair of smooth arms curl around you.
			&lt;br&gt; &lt;br&gt;
		
			&quot;Going somewhere?&quot; Silvianna whispers sweetly. &lt;br&gt; &lt;br&gt;
			You struggle in vain against her. You lost your chance to 
			escape, and now you&#39;re trapped in her
			[[embrace-&gt;Elf Maiden Embrace]]... 
	
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/linkreplace&gt;&gt;
	
&lt;&lt;else&gt;&gt;
	
	&lt;&lt;if $MonsterStatus is &quot;anger&quot;&gt;&gt;
		The aura of anger swirling around her sends a chill through 		you.
		Screw this. No flower is worth this much trouble. Time to make
		a strategic withdrawal. &lt;br&gt; &lt;br&gt;
	
		But the instant you turn to run away, Silvianna slams into your
		back, her arms wrapping around you in a tight hug. You gasp and
		struggle, but you can&#39;t make any headway against her vicelike
		embrace. &lt;br&gt; &lt;br&gt;
	
		&quot;Got you,&quot; Silvianna giggles, her voice more playful than angry
		once again. &quot;Now time to have some fun~.&quot;
		&lt;br&gt; &lt;br&gt;
	
		Your attempted escape was a complete failure. Now you&#39;re caught 		in
		Silvianna&#39;s [[iron grip-&gt;Elf Maiden Embrace]].
	
	&lt;&lt;else&gt;&gt;
		Even if you didn&#39;t manage to retrieve the flower, you need to
		get out of here. Time to make a strategic withdrawal.
		&lt;br&gt; &lt;br&gt;
	
		You turn around and run back into the forest.
		&lt;br&gt; &lt;br&gt;
	
		&lt;&lt;set _mod to $escape&gt;&gt;
		&lt;&lt;set $checkStat to &quot;dex&quot;&gt;&gt;
		
		&lt;&lt;if $MonsterStatus is &quot;stunned&quot; or $MonsterStatus is &quot;tripped&quot;&gt;&gt;
			&lt;&lt;set $checkAgainst to 4&gt;&gt;
		&lt;&lt;else&gt;&gt;
			&lt;&lt;set $checkAgainst to 6&gt;&gt;
		&lt;&lt;/if&gt;&gt;

		&lt;&lt;set $ElfMood -= 1&gt;&gt;

		&lt;&lt;linkreplace &quot;Escape&quot;&gt;&gt;
			&lt;&lt;Stat_Check&gt;&gt;
		
			&lt;&lt;if _checkPass
				&lt;&lt;set $escape to 0&gt;&gt;
			
				&quot;Hey, come back!&quot; Silvianna calls after you. &lt;br&gt; &lt;br&gt;
		
				You ignore her voice and run faster, adrenaline giving you
				the speed even to outrun the elf maiden pursuing you.
				&lt;br&gt; &lt;br&gt;
			
				You dash through the forest, and eventually her voice fades 			into the distance, and you finally slow down, panting
				heavily, both in exertion and relief.
				It was close, but you managed
				to [[escape-&gt;Elf Maiden Escape Success]].
		
			&lt;&lt;else&gt;&gt;
				&lt;&lt;set $escape += 1&gt;&gt;
				But as you reach the edge of the clearing,
				your foot catches
				on a tree root, sending you stumbling to the ground!
				&lt;br&gt; &lt;br&gt;
		
				You quickly catch yourself
				and scramble back to your feet, but
				in the next instant,
				you feel an impact agasint your back and
				a pair of smooth arms curl around you.
				&lt;br&gt; &lt;br&gt;
		
				&quot;Going somewhere?&quot; Silvianna whispers sweetly. &lt;br&gt; &lt;br&gt;
		
				You struggle in vain against her. You lost your chance to 
				escape, and now you&#39;re trapped in her
				[[embrace-&gt;Elf Maiden Embrace]]... 
	
			&lt;&lt;/if&gt;&gt;
		&lt;&lt;/linkreplace&gt;&gt;
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="55" name="Elf Maiden Wait" tags="combat nobr complete" position="623,1915" size="100,100">&lt;&lt;if $MonsterStatus is &quot;stunned&quot;&gt;&gt;
	You could have taken advantage of her injured state, but instead 
	you step back and wait. After a moment, her sobbing ceases, and she
	slowly rises to her feet. &lt;br&gt; &lt;br&gt;
	
	Her smile returns, but her eyes remain cold, &quot;Teeheehee, so you
	wanted to play rough? You might regret that...&quot; &lt;br&gt; &lt;br&gt;
	
	You&#39;ve wasted the best chance you had, and now you can practically
	feel an aura of smoldering rage around her. 
	You instinctively know this fight is going to be 
	harder here on out... &lt;br&gt; &lt;br&gt;
	
	&lt;&lt;set $MonsterStatus to &quot;anger&quot;&gt;&gt;
	
	[[Continue-&gt;Elf Maiden Fight]]
	
&lt;&lt;elseif $MonsterStatus is &quot;anger&quot;&gt;&gt;
	With how angry she is right now, try to make a move of your own
	isn&#39;t an option. You&#39;ll have to wait and see what she does first.
	&lt;br&gt; &lt;br&gt;
	
	Seeing you wait, Silvianna giggles and licks her lips, her eyes
	still burning with anger, &quot;Good boy, just wait right there and
	let me take you...&quot;
	
	[[Continue-&gt;Elf Maiden Tackle]] 
	
&lt;&lt;elseif $MonsterStatus is &quot;tripped&quot;&gt;&gt;
	You could have taken advantage of her tripping, but instead you
	step back and wait. &lt;br&gt; &lt;br&gt;
	
	In seconds, Silvianna bounces back to her feet, giggling as she
	brushes forest debris from her dress, &quot;You&#39;re pretty quick for a
	human! But I won&#39;t let you get away this time, cutie~&quot; &lt;br&gt; &lt;br&gt;
	
	You ready yourself as she prepares to
	[[attack-&gt;Elf Maiden Tackle]] 
	once again.

&lt;&lt;else&gt;&gt;
	You&#39;d best wait and see what she does. Until she shows an opening,
	it would be foolish to try to make another move. &lt;br&gt; &lt;br&gt;
	
	Silvianna bounces on the balls up her feet as she stalks you, 
	giggling softly, &quot;Here I come, cutie!&quot; &lt;br&gt; &lt;br&gt;
	
	[[Continue-&gt;Elf Maiden Tackle]]
&lt;&lt;/if&gt;&gt;

</tw-passagedata><tw-passagedata pid="56" name="ELf Maiden Rape Attempt" tags="combat complete" position="1315,1293" size="100,100">You lick your lips and stare at her defenseless form. She was so eaer for this earlier...so there&#39;s nothing wrong with giving her what she wanted.

You drop your staff and stride over to her, grabbing her wrists and climbing on top of her. She attempts a futile struggle, but you easily pin her down.

Your heart pounds as you stare at her. Her eyes are wide with fear and beginning to puff with tears, and a thin stream of blood trickles down her head from the wound you dealt her, but those small flaws do little to
mar her beauty.

&quot;N-no...please,&quot; she whispers.

You stop, her pleading voice too much to ignore. What the hell are you doing? This isn&#39;t something a hero should be doing...

That small hesitation is all she needs. Before you can react, her knee jerks up sharply, slamming right into your groin. The pain shatters your strength, and you crumple immediately, falling to the forest floor clutching your injured manhood.

The next thing you know, a bare foot slams down on your chest. You stare up into the elf maiden&#39;s cruel, disgusted eyes.

&quot;So you&#39;re one of //those// humans,&quot; she hisses. &quot;The kind of trash that comes thinking we elves are helpless prey for you to hunt. Guess what, trash? //You&#39;re// the prey.&quot;

You whimper in reply, too weakened to protest.

&quot;You know, if you were a nice human, we could have had fun together,&quot; she says. &quot;But if you want to play rough, I&#39;m more than happy to oblige.&quot;

You gulp as she stares down at you with eyes completely devoid of mercy. With a wicked gleam in her bright green eyes, the elf maiden slowly moves her foot from your chest to your groin. \
	&lt;&lt;if not $SilviannaName&gt;&gt;\
		&quot;My name is Silvianna. Moan it as I&#39;m punishing you, filth.&quot;\
	&lt;&lt;/if&gt;&gt;\

&lt;&lt;set $ElfMood -= 3&gt;&gt;

[[Continue-&gt;Elf Maiden Cruel Punishment]]</tw-passagedata><tw-passagedata pid="57" name="Elf Maiden Cowgirl" tags="combat nobr Bad-End complete" position="297,2015" size="100,100">&lt;&lt;set $arousal += 3&gt;&gt;

&lt;&lt;if $will lte 3&gt;&gt;
	You lose yourself to the feeling of her sex, abandoning all
	resistance in the face of the pleasure that&#39;s overwhelming you.
	&lt;br&gt; &lt;br&gt;
	
	Your hips thrust desperately, penetrating the the deepest depths
	of her soaking cunt as she rides you. Her hands intertwine with 
	yours, keeping her steady as she bounces up and down.
	&lt;br&gt; &lt;br&gt;
	
	Her ragged, desperate screams fill your ears, her mouth hanging
	open and eyes rolling back as she abandons all reason to pour
	herself into the single task of fucking you senseless, a task 
	you&#39;re all too willing to participate in. 
	&lt;br&gt; &lt;br&gt;
	
	&quot;Fuck! Oh fuck yes! Oh goddess!&quot; She screams, her voice losing
	all coherence, but proclaiming her pleasure more eloquently than
	ever. &quot;It&#39;s so good! IT&#39;S SO FUCKING GOOD! Cum for me, baby! Fill
	me up, darling! Cum for me! Cum for me!&quot;
	&lt;br&gt; &lt;br&gt;
	
	You couldn&#39;t have resisted her a second, even if you weren&#39;t
	already longing to do exactly as she asks. Ecstasy washes over you,
	leaving you writhing in pleasure as you blast your load into her
	waiting pussy, every pulsing release another wave of pleasure
	beyond anything else. 
	&lt;br&gt; &lt;br&gt;
	
	The orgasm seems to go on and on, pleasure wracking your body to
	leave you stripped of all strength. You can&#39;t stop it. You&#39;re far
	beyond //wanting// to stop it. You can only submit as she fucks
	you until she&#39;s satisfied...
	&lt;br&gt; &lt;br&gt;
	
	&lt;&lt;linkreplace &quot;Continue&quot;&gt;&gt;
		At last, her rhythm slows and she comes to a rest. She pants 
		heavily, her face flushed and eyes wide as she stares at you.
		&lt;br&gt; &lt;br&gt;
		
		&quot;Oh...oh darling,&quot; she whispers, her words slurred as she 
		comes down from the orgasmic high. &quot;That was so, sooooo good.&quot;
		&lt;br&gt; &lt;br&gt;
		
		You can only nod in agreement and feebly moan, too spent to
		offer a proper response.
		&lt;br&gt; &lt;br&gt;
		
		&quot;Mmm... Oh darling...&quot; she slowly leans down to plant a deep,
		lingering kiss on your lips. &quot;You&#39;re going to make such a 
		good pet...&quot;
		&lt;br&gt; &lt;br&gt;
		
		...pet?
		&lt;br&gt; &lt;br&gt;
		
		A small remaining piece of fragile rationality remaining within
		you knows that should be a big warning flag, but instead of 
		fear, all you feel is excitement.
		&lt;br&gt; &lt;br&gt;
		
		She caresses your face lovingly, &quot;That&#39;s right, darling. 
		I&#39;m going to take you back to the village with me.
		Then we can play all we want...whenever we want. I&#39;ll even let
		the other girls play with you too. We&#39;ll play with you until
		you forget you&#39;re anything but a toy for me. Doesn&#39;t that
		sound nice?&quot; &lt;br&gt; &lt;br&gt;
	
		Another longing moan is the only response you&#39;re capable of.
	
		&quot;Come on then,&quot; she says,
		smiling as she helps you to your feet.
	
		You stumble and sway as she leads you,
		unable to register anything
		besides the girl leading you by the hand
		&lt;&lt;link &quot;to your new home&quot;&gt;&gt;
			&lt;&lt;set $game_over to &quot;Elf Maiden&quot;&gt;&gt;
			&lt;&lt;goto &quot;Game Over&quot;&gt;&gt; 
		&lt;&lt;/link&gt;&gt;...
		
	&lt;&lt;/linkreplace&gt;&gt;
	
	&lt;&lt;remember $CowgirlBadEnd to true&gt;&gt;
	
&lt;&lt;elseif not $naked&gt;&gt;
	You don&#39;t resist as she strips you, casting your clothes aside to
	leave you naked and vulnerable to her. She stares at your bared,
	throbbing cock with hungry eyes as she lowers herself down.
	&lt;br&gt; &lt;br&gt;
	
	&lt;&lt;set $naked to true&gt;&gt;
	
	Your pleasured moans merge with hers as she takes you in, her
	eager pussy swallowing your cock whole. Her walls press in, 
	surrounding you in a comfortable tightness that sends your brain
	spinning in pleasure. 
	&lt;br&gt; &lt;br&gt;
	
	&quot;Ah... Ahh//hhh//hhh...~&quot; she moans as she begins to slide up and
	down, her pussy&#39;s slick folds molding to your shape with every 
	motion. &quot;Oh fuck...oh yes...&quot; 
	&lt;br&gt; &lt;br&gt;
	
	Her moans fill your ears as she rides you. You&#39;re rapidly losing
	yourself to the pleasure as every bounce brings you closer and
	closer
	to the edge of ecstasy...
	&lt;br&gt; &lt;br&gt;

	[[Let her ride you.-&gt;Elf Maiden Cowgirl]]
	&lt;br&gt;
	[[You have to resist...-&gt;Elf Maiden Cowgirl Struggle]]

&lt;&lt;else&gt;&gt;
	Your pleasured moans merge with hers as she takes you in, her
	eager pussy swallowing your cock whole. Her walls press in, 
	surrounding you in a comfortable tightness that sends your brain
	spinning in pleasure. 
	&lt;br&gt; &lt;br&gt;
	
	&quot;Ah... Ahh//hhh//hhh...~&quot; she moans as she begins to slide up and
	down, her pussy&#39;s slick folds molding to your shape with every 
	motion. &quot;Oh fuck...oh yes...&quot; 
	&lt;br&gt; &lt;br&gt;
	
	Her moans fill your ears as she rides you. You&#39;re rapidly losing
	yourself to the pleasure as every bounce brings you closer and 
	closer
	to the edge of ecstasy...
	&lt;br&gt; &lt;br&gt;

	[[Let her ride you.-&gt;Elf Maiden Cowgirl]]
	&lt;br&gt;
	[[You have to resist...-&gt;Elf Maiden Cowgirl Struggle]]

&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="58" name="Elf Maiden Cowgirl Struggle" tags="combat complete" position="475,1953" size="100,100">You try to free yourself from her &lt;&lt;print either(&quot;tight, irresitible pussy&quot;, &quot;warm, wet pussy&quot;, &quot;soaking pussy&quot;, &quot;heavenly sex&quot;)&gt;&gt;...

&lt;&lt;set _mod to $struggle&gt;&gt;
&lt;&lt;set $checkStat to &quot;str&quot;&gt;&gt;
&lt;&lt;set $checkAgainst to 7&gt;&gt;
&lt;&lt;set $ElfMood -= 1&gt;&gt;

&lt;br&gt; &lt;br&gt;

&lt;&lt;linkreplace &quot;Struggle&quot;&gt;&gt;
	&lt;&lt;Stat_Check&gt;&gt;
	
	&lt;&lt;if _checkPass&gt;&gt;
		You struggle with all your might, and with a burst of strength
		you manage to throw her off of you!
		
		&quot;Ah!&quot; she screams in surprise &quot;H-hey! Don&#39;t struggle!&quot;
		
		Ignoring her words, you scramble to your feet. That was far,
		far to close, but you somehow managed to survive.
		Now, it&#39;s time to
		[[fight-&gt;Elf Maiden Fight]]
		back!
	
	&lt;&lt;else&gt;&gt;
		But no matter how hard you try, you can&#39;t pull away from her!
		&lt;br&gt; &lt;br&gt;
		
		Your struggles end when she slams her hips down, taking you
		deeper still. Her warm, wet flesh engulfs your aching cock
		completely, sending a surge of overwhelming pleasure that
		robs you of any resistance you had left. &lt;br&gt; &lt;br&gt;
		
		You can&#39;t stop it anymore. You can only lay back and let her
		[[fuck you into submission-&gt;Elf Maiden Cowgirl]].
	&lt;&lt;/if&gt;&gt;
&lt;&lt;/linkreplace&gt;&gt;</tw-passagedata><tw-passagedata pid="59" name="Elf Maiden Violent VICTORY" tags="nobr victory complete" position="1311,2072" size="100,100">&lt;&lt;set $karma -= 1&gt;&gt;
&lt;&lt;Status_Reset&gt;&gt;
&lt;&lt;set $ElfMaidenBattleClear to true&gt;&gt;
&lt;&lt;remember $ViolenceEnding to true&gt;&gt;
&lt;&lt;remember $ClearedDemo += 1&gt;&gt;

Congratulations! You got the &quot;Violence&quot; ending of this demo! You&#39;re kind of a terrible person.
&lt;br&gt; &lt;br&gt;

Thank you for playing! &lt;br&gt;
Now go find the other good (and bad!) ends!</tw-passagedata><tw-passagedata pid="60" name="Elf Maiden Merciful VICTORY" tags="nobr victory complete" position="1445,2004" size="100,100">&lt;&lt;set $karma += 1&gt;&gt;
&lt;&lt;Status_Reset&gt;&gt;
&lt;&lt;set $ElfMaidenBattleClear to true&gt;&gt;
&lt;&lt;remember $MercifulEnding to true&gt;&gt;
&lt;&lt;remember $ClearedDemo += 1&gt;&gt;

Congratulations! You got the &quot;Merciful&quot; ending of this demo! Aren&#39;t you a nice person?
&lt;br&gt; &lt;br&gt;

Thank you for playing! &lt;br&gt;
Now go find the other good (and bad!) ends!</tw-passagedata><tw-passagedata pid="61" name="Elf Maiden Escape Success" tags="nobr complete" position="872,2105" size="100,100">&lt;&lt;remember $EscapedEnding to true&gt;&gt;

You escaped! Nice job, pussy. &lt;br&gt;
Now go find the actual good (and bad!) endings!</tw-passagedata><tw-passagedata pid="62" name="Elf Maiden Tackle" tags="combat complete nobr" position="624,2063" size="100,100">&lt;&lt;if $MonsterStatus is &quot;anger&quot;&gt;&gt;
	Suddenly, she attacks! Charging at you full force, you don&#39;t even
	get a chance to react. She slams into your chest, sending you
	crashing to the ground. She plants herself on top of you, straddling
	you and looking down. You look of anger is gone, replaced by a
	smug grin. &lt;br&gt; &lt;br&gt;
	
	&quot;Got you,&quot; she smirks. &quot;You&#39;re not getting away now~. &lt;br&gt; &lt;br&gt;
	
	&lt;&lt;set $MonsterStatus to &quot;none&quot;&gt;&gt;
	&lt;&lt;set $pinned to true&gt;&gt;
	&lt;&lt;set $damage += 2&gt;&gt;
	
	She has you completely 
	[[pinned-&gt;Elf Maiden Pinned]]. 
	It&#39;s going to be difficult to get
	away.
	
&lt;&lt;else&gt;&gt;
	Silvianna licks her lips as she stalks towards you. You can tell
	she&#39;s getting ready to pounce... &lt;br&gt; &lt;br&gt;
	
	&lt;&lt;set _attack to either(&quot;left&quot;,&quot;right&quot;)&gt;&gt;
	
	You try to read her attack... &lt;br&gt; &lt;br&gt;
	
	&lt;&lt;if $int &gt; 5&gt;&gt;
		&lt;&lt;if _attack is &quot;left&quot;&gt;&gt;
			She slowly moves to your right side. But you can see her
			other leg tensing up. It&#39;s a feint! You&#39;re certain she&#39;s
			going to attack from the left!
			
		&lt;&lt;elseif _attack is &quot;right&quot;&gt;&gt;
			She slowly moves to your left side. But you can see her
			other leg tensing up. It&#39;s a feint! You&#39;re certain she&#39;s
			going to attack from the right side!
			
		&lt;&lt;/if&gt;&gt;
		
	&lt;&lt;elseif $int &lt; 4&gt;&gt;
		But you can&#39;t read her moves at all...
		
	&lt;&lt;else&gt;&gt;
		&lt;&lt;if _attack is &quot;left&quot;&gt;&gt;
			She slowly moves to your right side. It looks like that&#39;s
			where she&#39;s going to attack from...
			
		&lt;&lt;elseif _attack is &quot;right&quot;&gt;&gt;
			She slowly moves to your left side. It looks like that&#39;s
			where she&#39;s going to attack from...
			
		&lt;&lt;/if&gt;&gt;
	&lt;&lt;/if&gt;&gt;
	&lt;br&gt; &lt;br&gt;
	
	You only have a second to decide which way to dodge.
	&lt;br&gt; &lt;br&gt;
	
	&lt;span id=&#39;dodge&#39;&gt;
		&lt;&lt;link &quot;Dodge to the left!&quot;&gt;&gt;
			&lt;&lt;replace #dodge&gt;&gt;
				At the last second, you dodge to the left...
				&lt;br&gt; &lt;br&gt;
				
				&lt;&lt;if _attack is &quot;left&quot;&gt;&gt;
					And run right into her attack! You completely
					fell for her feint! &lt;br&gt; &lt;br&gt;
					
					You fall down with a cry. She smiles down at you
					from where she&#39;s perched, straddling you over
					the forest bed. &lt;br&gt; &lt;br&gt;
					
					&quot;Got you~,&quot; she giggled. &lt;br&gt; &lt;br&gt;
					
					&lt;&lt;set $pinned to true&gt;&gt;
					&lt;&lt;set $damage += 2&gt;&gt;
					
					This is bad. 
					She has you completely
					[[pinned-&gt;Elf Maiden Pinned]]...
					
				&lt;&lt;elseif _attack is &quot;right&quot;&gt;&gt;
					And avoid her attack completely! She gasps in
					surprise as you smoothly evade her. She sails by
					you, so committed to her attack that she trips
					and falls in an undignified heap. &lt;br&gt; &lt;br&gt;
					
					&lt;&lt;set $MonsterStatus to &quot;tripped&quot;&gt;&gt;
					Now&#39;s your chance to act! &lt;br&gt; &lt;br&gt;
					
					[[Continue-&gt;Elf Maiden Fight]] 
					
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		
		&lt;br&gt;
		
		&lt;&lt;link &quot;Dodge to the right!&quot;&gt;&gt;
			&lt;&lt;replace #dodge&gt;&gt;
				At the last second, you dodge to the right...
				&lt;br&gt; &lt;br&gt;
				
				&lt;&lt;if _attack is &quot;left&quot;&gt;&gt;
					And avoid her attack completely! She gasps in
					surprise as you smoothly evade her. She sails by
					you, so committed to her attack that she trips
					and falls in an undignified heap. &lt;br&gt; &lt;br&gt;
					
					&lt;&lt;set $MonsterStatus to &quot;tripped&quot;&gt;&gt;
					Now&#39;s your chance to act! &lt;br&gt; &lt;br&gt;
					
					[[Continue-&gt;Elf Maiden Fight]] 
					
				&lt;&lt;elseif _attack is &quot;right&quot;&gt;&gt;
					And run right into her attack! You completely
					fell for her feint! &lt;br&gt; &lt;br&gt;
					
					You fall down with a cry. She smiles down at you
					from where she&#39;s perched, straddling you over
					the forest bed. &lt;br&gt; &lt;br&gt;
					
					&quot;Got you~,&quot; she giggled. &lt;br&gt; &lt;br&gt;
					
					&lt;&lt;set $pinned to true&gt;&gt;
					&lt;&lt;set $damage += 2&gt;&gt;
					
					This is bad. 
					She has you completely
					[[pinned-&gt;Elf Maiden Pinned]]...
					
				&lt;&lt;/if&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		
	&lt;/span&gt;
	
&lt;&lt;/if&gt;&gt;</tw-passagedata><tw-passagedata pid="63" name="Elf Maiden Neutral VICTORY" tags="victory nobr complete" position="1172,2008" size="100,100">&lt;&lt;Status_Reset&gt;&gt;
&lt;&lt;set $ElfMaidenBattleClear to true&gt;&gt;
&lt;&lt;remember $NormalEnding to true&gt;&gt;
&lt;&lt;remember $ClearedDemo += 1&gt;&gt;

Congratulations! You got the &quot;Normal&quot; ending of this demo! Cool.
&lt;br&gt; &lt;br&gt;

Thank you for playing! &lt;br&gt;
Now go find the other good (and bad!) ends!</tw-passagedata><tw-passagedata pid="64" name="Elf Maiden Handjob Finish" tags="nobr complete Bad-End inventory-lock" position="1016,2080" size="100,100">Your strength completely spent, you sink to the ground, only Silvianna&#39;s support saving you from a painful fall.	

You groan softly as you lay prone and helpless on the forest floor, the
afterglow still leaving your body ravished by pleasure. A pink
haze covers your vision. Silvianna rests your head in her lap, softly stroking your hair where you lay. You sigh and relax, her thighs the perfect pillow for your exhausted, pleasure-drunk head. &lt;br&gt; &lt;br&gt;

Long after the pleasure should have passed, you&#39;re still unable
to move. The voice of reason that should be keeping you safe and 
warning you against falling into temptation is nothing more than
a faint buzz now, so weak against the desire filling you up that
it&#39;s all but worthless. &lt;br&gt; &lt;br&gt;
	
At last, Silvianna speak, her voice a gentle melody in your ears,
&quot;Mmm...ready to play some more, lover?&quot; &lt;br&gt; &lt;br&gt;
	
You can only groan softly, too weak to even voice affirmation, much
less dissent. &lt;br&gt; &lt;br&gt;
	
She giggles in response, &quot;Awww, are you too weak still? Humans
really are weak, huh? That&#39;s ok; it&#39;s kind of cute. Hmmm...well, if
we can&#39;t play more here, I&#39;ll just have to take you back home with 
me. Then we can play all we want...whenever we want. I&#39;ll even let
the other girls play with you too. We&#39;ll play with you until
you forget you&#39;re anything but a toy for me. Doesn&#39;t that
sound nice?&quot; &lt;br&gt; &lt;br&gt;
	
Another longing moan is the only response you&#39;re capable of.
	
&quot;Come on then,&quot; she says, smiling as she helps you to your feet.
	
You stumble and sway as she leads you, unable to register anything
besides the girl leading you by the hand
&lt;&lt;link &quot;to your new home&quot;&gt;&gt;
	&lt;&lt;set $game_over to &quot;Elf Maiden&quot;&gt;&gt;
	&lt;&lt;goto &quot;Game Over&quot;&gt;&gt; 
&lt;&lt;/link&gt;&gt;...

&lt;&lt;remember $HandjobBadEnd to true&gt;&gt;</tw-passagedata><tw-passagedata pid="65" name="Ending List" tags="nobr noreturn" position="1501,103" size="100,100">__&#39;&#39;Good Ends&#39;&#39;__
&lt;br&gt;

&lt;&lt;if $NormalEnding&gt;&gt;
	Normal End CLEAR!
&lt;&lt;else&gt;&gt;
	@@color:red; Normal End @@
&lt;&lt;/if&gt;&gt;
&lt;br&gt;

&lt;&lt;if $MercifulEnding&gt;&gt;
	Merciful End CLEAR!
&lt;&lt;else&gt;&gt;
	@@color:red; Merciful End @@
&lt;&lt;/if&gt;&gt;
&lt;br&gt;

&lt;&lt;if $ViolenceEnding&gt;&gt;
	Violence Ending CLEAR!
&lt;&lt;else&gt;&gt;
	@@color:red; Violence End @@
&lt;&lt;/if&gt;&gt;
&lt;br&gt; 

&lt;&lt;if $LoveAndLeaveEnding&gt;&gt; 
	Love Her and Leave Her End CLEAR! 
&lt;&lt;else&gt;&gt;
	@@color:red; Love Her and Leave Her End @@
&lt;&lt;/if&gt;&gt;
&lt;br&gt;

&lt;&lt;if $ElfLoverEnding&gt;&gt; 
	Elf Lover End CLEAR! 
&lt;&lt;else&gt;&gt;
	@@color:red; Elf Lover End @@
&lt;&lt;/if&gt;&gt;
&lt;br&gt;

&lt;br&gt;
__&#39;&#39;Neutral End&#39;&#39;__
&lt;br&gt;

&lt;&lt;if $EscapedEnding&gt;&gt; 
	Escaped Ending CLEAR! 
&lt;&lt;else&gt;&gt;
	@@color:red; Escaped Ending @@
&lt;&lt;/if&gt;&gt;
&lt;br&gt;

&lt;br&gt;
__&#39;&#39;Bad Ends&#39;&#39;__
&lt;br&gt;

&lt;&lt;if $PlayBadEnd&gt;&gt;
	Elf&#39;s Toy Bad End CLEAR!
&lt;&lt;else&gt;&gt;
	@@color:red; Elf&#39;s Toy Bad End@@
&lt;&lt;/if&gt;&gt;
&lt;br&gt;

&lt;&lt;if $CowgirlBadEnd&gt;&gt;
	Cowgirl Bad End CLEAR!
&lt;&lt;else&gt;&gt;
	@@color:red; Cowgirl Bad End @@
&lt;&lt;/if&gt;&gt;
&lt;br&gt;

&lt;&lt;if $HandjobBadEnd&gt;&gt;
	Handjob Bad End CLEAR!
&lt;&lt;else&gt;&gt;
	@@color:red; Handjob Bad End @@
&lt;&lt;/if&gt;&gt;
&lt;br&gt;

&lt;&lt;if $FootjobGentleBadEnd&gt;&gt;
	Footjob Bad End - Gentle CLEAR!
&lt;&lt;else&gt;&gt;
	@@color:red; Footjob Bad End - Gentle @@
&lt;&lt;/if&gt;&gt;
&lt;br&gt;

&lt;&lt;if $FootjobCruelBadEnd&gt;&gt;
	Footjob Bad End - Cruel CLEAR!
&lt;&lt;else&gt;&gt;
	@@color:red; Footjob Bad End - Cruel @@
&lt;&lt;/if&gt;&gt;
&lt;br&gt;

&lt;br&gt;
&lt;&lt;button &#39;Return&#39; &gt;&gt; &lt;&lt;goto $return&gt;&gt; &lt;&lt;/button&gt;&gt;</tw-passagedata><tw-passagedata pid="66" name="FORGET ENDINGS" tags="nobr" position="1651,100" size="100,100">/* Plug this into the Story Init OR just run this passage to erase all data history and start the demo completely clean and untainted. */

Your memories of the past fade into nothingness...

&lt;&lt;forget $ClearedDemo&gt;&gt;

&lt;&lt;forget $NormalEnding&gt;&gt;
&lt;&lt;forget $MercifulEnding&gt;&gt;
&lt;&lt;forget $ViolenceEnding&gt;&gt;
&lt;&lt;forget $LoveAndLeaveEnding&gt;&gt;
&lt;&lt;forget $ElfLoverEnding&gt;&gt;

&lt;&lt;forget $EscapedEnding&gt;&gt;

&lt;&lt;forget $PlayBadEnd&gt;&gt;
&lt;&lt;forget $CowgirlBadEnd&gt;&gt;
&lt;&lt;forget $HandjobBadEnd&gt;&gt;
&lt;&lt;forget $FootjobGentleBadEnd&gt;&gt;
&lt;&lt;forget $FootjobCruelBadEnd&gt;&gt;</tw-passagedata><tw-passagedata pid="67" name="OldStart" tags="nobr" position="1271,245" size="100,100">&lt;&lt;if $ClearedDemo &gt; 0 &gt;&gt;
	Welcome back! You&#39;ve cleared this demo &lt;&lt;print $ClearedDemo&gt;&gt;
	times! To see the endings you&#39;ve unlocked so far, go to the
	Inventory and click on the Ending List.
	&lt;br&gt; &lt;br&gt;
	Now then, let&#39;s get started!
&lt;&lt;else&gt;&gt;
	Welcome to this world of monsters. A place beyond your wildest 		dreams... or your darkest nightmares!
&lt;&lt;/if&gt;&gt;

&lt;br&gt; &lt;br&gt;
What is your name? 

&lt;&lt;textbox &quot;$name&quot; &quot;Hero&quot;  autofocus&gt;&gt;
&lt;&lt;button &quot;Enter&quot;&gt;&gt;
	&lt;&lt;replace &quot;#name&quot;&gt;&gt;
		$name, you have been chosen.
		&lt;br&gt; &lt;br&gt;
		
		Now then, time to choose your stats! &lt;br&gt;
		Note: minimum is 3, max is 7. &lt;br&gt; &lt;br&gt;
		
		Strength:
		&lt;&lt;link &quot;[+]&quot;&gt;&gt;
    		&lt;&lt;if $totalPoints gt 0 and $base_str lt 7&gt;&gt;
				&lt;&lt;set $base_str++&gt;&gt;
    			&lt;&lt;set $totalPoints--&gt;&gt;
    			&lt;&lt;replace &quot;#strengthStat&quot;&gt;&gt;
					&lt;&lt;print $base_str&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
      			&lt;&lt;replace &quot;#pointsStat&quot;&gt;&gt;
					&lt;&lt;print $totalPoints&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
    		&lt;&lt;/if&gt;&gt;
		&lt;&lt;/link&gt;&gt; 
		
		&lt;&lt;link &quot;[-]&quot;&gt;&gt;
    		&lt;&lt;if $base_str gt 3&gt;&gt;
    			&lt;&lt;set $base_str--&gt;&gt;
      			&lt;&lt;set $totalPoints++&gt;&gt;
    			&lt;&lt;replace &quot;#strengthStat&quot;&gt;&gt;
					&lt;&lt;print $base_str&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
        		&lt;&lt;replace &quot;#pointsStat&quot;&gt;&gt;
					&lt;&lt;print $totalPoints&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
    		&lt;&lt;/if&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		
		&lt;br&gt;
		
		Dexterity: 
		&lt;&lt;link &quot;[+]&quot;&gt;&gt;
    		&lt;&lt;if $totalPoints gt 0 and $base_dex lt 7&gt;&gt;
      			&lt;&lt;set $base_dex++&gt;&gt;
      			&lt;&lt;set $totalPoints--&gt;&gt;
      			&lt;&lt;replace &quot;#dexterityStat&quot;&gt;&gt;
					&lt;&lt;print $base_dex&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
      			&lt;&lt;replace &quot;#pointsStat&quot;&gt;&gt;
					&lt;&lt;print $totalPoints&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
    		&lt;&lt;/if&gt;&gt;
		&lt;&lt;/link&gt;&gt; 
		
		&lt;&lt;link &quot;[-]&quot;&gt;&gt;
    		&lt;&lt;if $base_dex gt 3&gt;&gt;
    			&lt;&lt;set $base_dex--&gt;&gt;
      			&lt;&lt;set $totalPoints++&gt;&gt;
      			&lt;&lt;replace &quot;#dexterityStat&quot;&gt;&gt;
					&lt;&lt;print $base_dex&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
      			&lt;&lt;replace &quot;#pointsStat&quot;&gt;&gt;
					&lt;&lt;print $totalPoints&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
    		&lt;&lt;/if&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		
		&lt;br&gt;
		
		Intelligence: 
		&lt;&lt;link &quot;[+]&quot;&gt;&gt;
    		&lt;&lt;if $totalPoints gt 0 and $base_int lt 7&gt;&gt;
      			&lt;&lt;set $base_int++&gt;&gt;
      			&lt;&lt;set $totalPoints--&gt;&gt;
      			&lt;&lt;replace &quot;#intelligenceStat&quot;&gt;&gt;
					&lt;&lt;print $base_int&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
      			&lt;&lt;replace &quot;#pointsStat&quot;&gt;&gt;
					&lt;&lt;print $totalPoints&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
    		&lt;&lt;/if&gt;&gt;
		&lt;&lt;/link&gt;&gt; 
		
		&lt;&lt;link &quot;[-]&quot;&gt;&gt;
    		&lt;&lt;if $base_int gt 3&gt;&gt;
    			&lt;&lt;set $base_int--&gt;&gt;
      			&lt;&lt;set $totalPoints++&gt;&gt;
      			&lt;&lt;replace &quot;#intelligenceStat&quot;&gt;&gt;
					&lt;&lt;print $base_int&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
      			&lt;&lt;replace &quot;#pointsStat&quot;&gt;&gt;
					&lt;&lt;print $totalPoints&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
    		&lt;&lt;/if&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		
		&lt;br&gt;
		
		Resistance: 
		&lt;&lt;link &quot;[+]&quot;&gt;&gt;
    		&lt;&lt;if $totalPoints &gt; 0 and $base_res &lt; 7&gt;&gt;
      			&lt;&lt;set $base_res++&gt;&gt;
      			&lt;&lt;set $totalPoints--&gt;&gt;
      			&lt;&lt;replace &quot;#resistanceStat&quot;&gt;&gt;
					&lt;&lt;print $base_res&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
      			&lt;&lt;replace &quot;#pointsStat&quot;&gt;&gt;
					&lt;&lt;print $totalPoints&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
    		&lt;&lt;/if&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		
		&lt;&lt;link &quot;[-]&quot;&gt;&gt;
    		&lt;&lt;if $base_res &gt; 3&gt;&gt;
    			&lt;&lt;set $base_res--&gt;&gt;
      			&lt;&lt;set $totalPoints++&gt;&gt;
      			&lt;&lt;replace &quot;#resistanceStat&quot;&gt;&gt;
					&lt;&lt;print $base_res&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
      			&lt;&lt;replace &quot;#pointsStat&quot;&gt;&gt;
					&lt;&lt;print $totalPoints&gt;&gt;
				&lt;&lt;/replace&gt;&gt;
    		&lt;&lt;/if&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		
		&lt;br&gt; &lt;br&gt;
		
		&lt;&lt;link &quot;[Reset Points]&quot;&gt;&gt;
    		&lt;&lt;set $base_str to 5&gt;&gt;
			&lt;&lt;set $base_dex to 5&gt;&gt;
    		&lt;&lt;set $base_int to 5&gt;&gt;
			&lt;&lt;set $base_res to 5&gt;&gt;
    		&lt;&lt;set $totalPoints to 5&gt;&gt;
    		&lt;&lt;replace &quot;#strengthStat&quot;&gt;&gt;
				&lt;&lt;print $base_str&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
			&lt;&lt;replace &quot;#dexterityStat&quot;&gt;&gt;
				&lt;&lt;print $base_dex&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
    		&lt;&lt;replace &quot;#intelligenceStat&quot;&gt;&gt;
				&lt;&lt;print $base_int&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
			&lt;&lt;replace &quot;#resistanceStat&quot;&gt;&gt;
				&lt;&lt;print $base_res&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
    		&lt;&lt;replace &quot;#pointsStat&quot;&gt;&gt;
				&lt;&lt;print $totalPoints&gt;&gt;
			&lt;&lt;/replace&gt;&gt;
		&lt;&lt;/link&gt;&gt;
		
		&lt;br&gt; &lt;br&gt;

		Strength: &lt;span id=&quot;strengthStat&quot;&gt;5&lt;/span&gt; &lt;br&gt;
		Dexterity: &lt;span id=&quot;dexterityStat&quot;&gt;5&lt;/span&gt; &lt;br&gt;
		Intelligence: &lt;span id=&quot;intelligenceStat&quot;&gt;5&lt;/span&gt; &lt;br&gt;
		Resistance: &lt;span id=&quot;resistanceStat&quot;&gt;5&lt;/span&gt; &lt;br&gt;
		
		&lt;br&gt;
		
		Remaining Points: &lt;span id=&quot;pointsStat&quot;&gt;5&lt;/span&gt;
		
		&lt;br&gt; &lt;br&gt;
		
		
		
	&lt;&lt;/replace&gt;&gt;
&lt;&lt;/button&gt;&gt;

&lt;br&gt; &lt;br&gt;
&lt;span id=&quot;name&quot;&gt;

&lt;/span&gt;</tw-passagedata><tw-passagedata pid="68" name="Choose Strength" tags="nobr" position="948,561" size="100,100">What is your best quality?
&lt;br&gt; &lt;br&gt;

&lt;span id=&#39;choice&#39;&gt;
	&lt;&lt;link &quot;My manly strength!&quot;&gt;&gt;
		&lt;&lt;replace #choice&gt;&gt;
			&lt;&lt;set $base_str += 1&gt;&gt;
			
			Your greatest attribute is your physical strength. You 
			are strong enough to overpower most weaker monsters. You
			should have little trouble breaking free of binds.
			&lt;br&gt; &lt;br&gt;
			
			Is this correct? &lt;br&gt; &lt;br&gt;
			
			[[Yes-&gt;Choose Weakness]]
			&lt;br&gt;
			&lt;&lt;link &quot;No&quot;&gt;&gt;
				&lt;&lt;set $base_str -= 1&gt;&gt;
				&lt;&lt;goto &quot;Choose Strength&quot;&gt;&gt;
			&lt;&lt;/link&gt;&gt;
			
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	
	&lt;br&gt;
	
	&lt;&lt;link &quot;My quickness and dexterity.&quot;&gt;&gt;
		&lt;&lt;replace #choice&gt;&gt;
			&lt;&lt;set $base_dex += 1&gt;&gt;
			
			Your greatest attribute is your speed and skill. You are
			skilled enough to evade and flee from just about anything.
			You can probably find other uses for those nimble fingers
			as well...
			&lt;br&gt; &lt;br&gt;
			
			Is this correct? &lt;br&gt; &lt;br&gt;
			
			[[Yes-&gt;Choose Weakness]]
			&lt;br&gt;
			&lt;&lt;link &quot;No&quot;&gt;&gt;
				&lt;&lt;set $base_dex -= 1&gt;&gt;
				&lt;&lt;goto &quot;Choose Strength&quot;&gt;&gt;
			&lt;&lt;/link&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	
	&lt;br&gt;
	
	&lt;&lt;link &quot;My supreme intellect.&quot;&gt;&gt;
		&lt;&lt;set $base_int += 1&gt;&gt;
		
		&lt;&lt;replace #choice&gt;&gt;
			Your greatest attribute is your wit and superior
			instincts. You&#39;re intelligent enough to see through
			any tricks, and cunning enough to outwit all but the 
			most keen-minded of monsters.
			&lt;br&gt; &lt;br&gt;
			
			Is this correct? &lt;br&gt; &lt;br&gt;
			
			[[Yes-&gt;Choose Weakness]]
			&lt;br&gt;
			&lt;&lt;link &quot;No&quot;&gt;&gt;
				&lt;&lt;set $base_int -= 1&gt;&gt;
				&lt;&lt;goto &quot;Choose Strength&quot;&gt;&gt;
			&lt;&lt;/link&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	
	&lt;br&gt;
	
	&lt;&lt;link &quot;My unshakeable will.&quot;&gt;&gt;
		&lt;&lt;set $base_res += 1&gt;&gt;
		
		&lt;&lt;replace #choice&gt;&gt;
			Your greatest attribute is your iron will. You can resist
			any monsters charms! ...or at least some. 
			&lt;br&gt; &lt;br&gt;
			
			Is this correct? &lt;br&gt; &lt;br&gt;
			
			[[Yes-&gt;Choose Weakness]]
			&lt;br&gt;
			&lt;&lt;link &quot;No&quot;&gt;&gt;
				&lt;&lt;set $base_res -= 1&gt;&gt;
				&lt;&lt;goto &quot;Choose Strength&quot;&gt;&gt;
			&lt;&lt;/link&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="69" name="Choose Weakness" tags="nobr" position="1035,681" size="100,100">What is your worst quality?

&lt;span id=&#39;choice&#39;&gt;
	&lt;&lt;link &quot;My scrawny muscles...&quot;&gt;&gt;
		&lt;&lt;replace #choice&gt;&gt;
			&lt;&lt;set $base_str -= 1&gt;&gt;
			
			Your weakest attribute is your pitiful physical strength.
			You&#39;ll easily be overpowered by the typical monster girl.
			If you get caught in a bind, you&#39;re screwed.
			&lt;br&gt; &lt;br&gt;
			
			Is this ok? &lt;br&gt; &lt;br&gt;
			
			[[Yes-&gt;Begin Adventure]]
			&lt;br&gt;
			&lt;&lt;link &quot;No&quot;&gt;&gt;
				&lt;&lt;set $base_str += 1&gt;&gt;
				&lt;&lt;goto &quot;Choose Weakness&quot;&gt;&gt;
			&lt;&lt;/link&gt;&gt;
			
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	
	&lt;br&gt;
	
	&lt;&lt;link &quot;My clumsiness...&quot;&gt;&gt;
		&lt;&lt;replace #choice&gt;&gt;
			&lt;&lt;set $base_dex -= 1&gt;&gt;
			
			Your weakest attribute is your clumsiness and lack of
			quickness. You&#39;ll find it hard to run from monsters, and
			you&#39;ll be quite prone to making mistakes.
			&lt;br&gt; &lt;br&gt;
			
			Is this ok? &lt;br&gt; &lt;br&gt;
			
			[[Yes-&gt;Begin Adventure]]
			&lt;br&gt;
			&lt;&lt;link &quot;No&quot;&gt;&gt;
				&lt;&lt;set $base_dex += 1&gt;&gt;
				&lt;&lt;goto &quot;Choose Weakness&quot;&gt;&gt;
			&lt;&lt;/link&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	
	&lt;br&gt;
	
	&lt;&lt;link &quot;My slow wits...&quot;&gt;&gt;
		&lt;&lt;set $base_int -= 1&gt;&gt;
		
		&lt;&lt;replace #choice&gt;&gt;
			Your weakest attribute is your brainpower. You&#39;re easily
			tricked by monster girl&#39;s wiles, and you&#39;re hopeless when
			trying to pursuade. Trickier monsters could easily outwit
			you.
			&lt;br&gt; &lt;br&gt;
			
			Is this ok? &lt;br&gt; &lt;br&gt;
			
			[[Yes-&gt;Begin Adventure]]
			&lt;br&gt;
			&lt;&lt;link &quot;No&quot;&gt;&gt;
				&lt;&lt;set $base_int += 1&gt;&gt;
				&lt;&lt;goto &quot;Choose Weakness&quot;&gt;&gt;
			&lt;&lt;/link&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	
	&lt;br&gt;
	
	&lt;&lt;link &quot;My weak will...&quot;&gt;&gt;
		&lt;&lt;set $base_res -= 1&gt;&gt;
		
		&lt;&lt;replace #choice&gt;&gt;
			Your weakest attribute is your pliable will. You&#39;ll soon
			be putty in the hands of most monster girls&#39; seduction...
			&lt;br&gt; &lt;br&gt;
			
			Is this correct? &lt;br&gt; &lt;br&gt;
			
			[[Yes-&gt;Begin Adventure]]
			&lt;br&gt;
			&lt;&lt;link &quot;No&quot;&gt;&gt;
				&lt;&lt;set $base_res += 1&gt;&gt;
				&lt;&lt;goto &quot;Choose Weakness&quot;&gt;&gt;
			&lt;&lt;/link&gt;&gt;
		&lt;&lt;/replace&gt;&gt;
	&lt;&lt;/link&gt;&gt;
	
&lt;/span&gt;</tw-passagedata><tw-passagedata pid="70" name="Begin Adventure" tags="nobr" position="1133,556" size="100,100">Your path is set. &lt;br&gt; &lt;br&gt;

You have been tasked with discovering a rare flower in the woods:
a Moondrop Flower. Prized for its medicinal properties, it&#39;s constantly in high demand. And the only place it is found near your village is the Mystic Forest, filled with monsters.
&lt;br&gt; &lt;br&gt;

Your quest begins. Now [[go forth-&gt;Forest]], adventurer!

</tw-passagedata></tw-storydata>